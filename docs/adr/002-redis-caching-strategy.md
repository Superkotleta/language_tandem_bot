# ADR-002: Стратегия кэширования с Redis

## Статус
Принято

## Контекст
При росте нагрузки на Language Exchange Bot возникла необходимость оптимизировать производительность:

- Частые запросы к базе данных для получения языков и интересов
- Медленные ответы при высокой нагрузке
- Необходимость масштабирования на несколько инстансов
- Требования к отказоустойчивости

## Рассмотренные варианты

### 1. In-memory кэширование
**Плюсы:**
- Быстрый доступ к данным
- Простота реализации
- Нет внешних зависимостей

**Минусы:**
- Не масштабируется между инстансами
- Потеря данных при перезапуске
- Ограниченная память

### 2. Database query optimization
**Плюсы:**
- Нет дополнительной инфраструктуры
- Консистентность данных

**Минусы:**
- Ограниченная производительность
- Нагрузка на базу данных

### 3. Redis кэширование
**Плюсы:**
- Высокая производительность
- Персистентность данных
- Масштабируемость
- Богатый набор структур данных

**Минусы:**
- Дополнительная инфраструктура
- Сложность настройки
- Потенциальная точка отказа

### 4. Hybrid подход (Redis + In-memory fallback)
**Плюсы:**
- Отказоустойчивость
- Лучшая производительность
- Graceful degradation

**Минусы:**
- Сложность реализации
- Дублирование логики

## Решение
Принят hybrid подход с Redis как основным кэшем и in-memory как fallback.

### Архитектура кэширования:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Application   │───▶│   Cache Layer    │───▶│   Data Source   │
│                 │    │                 │    │                 │
│ 1. Check Cache  │    │ 1. Redis (Primary)│    │ 1. PostgreSQL   │
│ 2. Fallback     │    │ 2. In-memory     │    │ 2. External APIs│
│ 3. Update Cache │    │    (Fallback)    │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Стратегии кэширования:

#### 1. **Languages Cache**
- **TTL**: 1 час (редко изменяются)
- **Ключ**: `languages:{lang_code}`
- **Fallback**: In-memory cache

#### 2. **Interests Cache**
- **TTL**: 1 час (редко изменяются)
- **Ключ**: `interests:{lang_code}`
- **Fallback**: In-memory cache

#### 3. **User Cache**
- **TTL**: 15 минут (могут изменяться)
- **Ключ**: `user:{telegram_id}`
- **Invalidation**: При обновлении профиля

#### 4. **Statistics Cache**
- **TTL**: 5 минут (часто обновляются)
- **Ключ**: `stats:{type}`
- **Fallback**: In-memory cache

### Реализация:

```go
type CacheService interface {
    GetLanguages(ctx context.Context, lang string) ([]*models.Language, bool)
    SetLanguages(ctx context.Context, lang string, languages []*models.Language)
    GetUser(ctx context.Context, telegramID int64) (*models.User, bool)
    SetUser(ctx context.Context, user *models.User)
    InvalidateUser(ctx context.Context, telegramID int64)
}
```

## Последствия

### Положительные
- **Производительность**: 60-80% ускорение ответов
- **Масштабируемость**: Поддержка множественных инстансов
- **Отказоустойчивость**: Graceful degradation при сбое Redis
- **Гибкость**: Разные TTL для разных типов данных
- **Мониторинг**: Детальные метрики кэша

### Отрицательные
- **Сложность**: Дополнительная инфраструктура
- **Консистентность**: Потенциальные проблемы с устаревшими данными
- **Отладка**: Сложнее отследить источник данных
- **Память**: Дополнительное использование RAM

## Мониторинг и метрики

### Ключевые метрики:
- **Hit Ratio**: Процент попаданий в кэш (цель: >80%)
- **Response Time**: Время ответа (цель: <100ms)
- **Memory Usage**: Использование памяти Redis
- **Evictions**: Количество вытеснений из кэша

### Алерты:
- Hit ratio < 70%
- Response time > 200ms
- Redis недоступен > 30 секунд
- Memory usage > 80%

## Связанные решения
- ADR-001: Принятие Clean Architecture
- ADR-003: Паттерн Circuit Breaker (для защиты Redis)
- ADR-005: Централизация обработки ошибок
