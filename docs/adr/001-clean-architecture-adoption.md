# ADR-001: Принятие Clean Architecture

## Статус

Принято

## Контекст

При разработке Language Exchange Bot возникла необходимость выбрать архитектурный подход, который обеспечит:

- Четкое разделение ответственности между компонентами
- Легкость тестирования
- Независимость бизнес-логики от внешних зависимостей
- Возможность замены внешних компонентов без изменения core логики
- Масштабируемость и поддерживаемость кода

## Рассмотренные варианты

### 1. Монолитная архитектура

**Плюсы:**

- Простота развертывания
- Единая кодовая база
- Простота отладки

**Минусы:**

- Сложность тестирования
- Тесная связанность компонентов
- Сложность масштабирования отдельных частей

### 2. Layered Architecture (3-tier)

**Плюсы:**

- Четкое разделение на слои
- Простота понимания

**Минусы:**

- Нарушение принципа инверсии зависимостей
- Сложность тестирования бизнес-логики
- Зависимость от конкретных технологий

### 3. Clean Architecture (Uncle Bob)

**Плюсы:**

- Независимость от фреймворков
- Тестируемость
- Независимость от UI
- Независимость от базы данных
- Независимость от внешних агентств

**Минусы:**

- Больше абстракций
- Сложность для простых проектов

## Решение

Принята Clean Architecture с адаптацией под специфику Go и микросервисной архитектуры.

### Структура проекта

```
services/bot/internal/
├── adapters/          # Внешние интерфейсы (Telegram, HTTP, Database)
├── core/              # Бизнес-логика (Use Cases, Entities)
├── database/          # Слой данных
├── models/            # Сущности (Entities)
├── config/            # Конфигурация
├── errors/            # Обработка ошибок
├── logging/           # Логирование
├── validation/        # Валидация
└── server/            # HTTP сервер
```

### Принципы

1. **Dependency Inversion**: Внешние слои зависят от внутренних через интерфейсы
2. **Single Responsibility**: Каждый компонент имеет одну ответственность
3. **Interface Segregation**: Интерфейсы разделены по функциональности
4. **Open/Closed**: Открыт для расширения, закрыт для модификации

## Последствия

### Положительные

- **Тестируемость**: Бизнес-логика легко тестируется с моками
- **Гибкость**: Легко заменить Telegram на другой мессенджер
- **Масштабируемость**: Компоненты можно масштабировать независимо
- **Поддерживаемость**: Четкое разделение ответственности
- **Независимость**: Core логика не зависит от внешних библиотек

### Отрицательные

- **Сложность**: Больше абстракций и интерфейсов
- **Кривая обучения**: Новым разработчикам нужно изучить архитектуру
- **Over-engineering**: Для простых задач может быть избыточной
- **Производительность**: Дополнительные слои абстракции

## Реализация

### Core Layer (Внутренний)

- `models/` - Сущности (User, Interest, Language)
- `core/` - Use Cases и бизнес-логика

### Adapters Layer (Внешний)

- `adapters/telegram/` - Telegram Bot API
- `adapters/http/` - HTTP API
- `database/` - PostgreSQL/SQLite

### Infrastructure

- `config/` - Конфигурация
- `errors/` - Обработка ошибок
- `logging/` - Логирование

## Связанные решения

- ADR-002: Стратегия кэширования с Redis
- ADR-003: Паттерн Circuit Breaker
- ADR-004: Подход к Rate Limiting
