# ADR-004: Подход к Rate Limiting

## Статус

Принято

## Контекст

При росте пользовательской базы Language Exchange Bot возникла необходимость защиты от:

- Спама и злоупотреблений
- DDoS атак
- Перегрузки системы
- Неравномерного распределения нагрузки
- Злонамеренного использования API

## Рассмотренные варианты

### 1. Простой счетчик запросов

**Плюсы:**

- Простота реализации
- Низкие накладные расходы

**Минусы:**

- Нет учета времени
- Не защищает от burst трафика
- Сложность настройки лимитов

### 2. Token Bucket

**Плюсы:**

- Позволяет burst трафик
- Гибкая настройка
- Хорошая производительность

**Минусы:**

- Сложность реализации
- Память для хранения токенов

### 3. Sliding Window

**Плюсы:**

- Точный контроль времени
- Справедливое распределение
- Хорошая защита от burst

**Минусы:**

- Высокие накладные расходы
- Сложность реализации
- Память для хранения меток времени

### 4. Fixed Window

**Плюсы:**

- Простота реализации
- Низкие накладные расходы
- Легко понять и настроить

**Минусы:**

- Проблемы на границах окон
- Менее точный контроль

### 5. Distributed Rate Limiting

**Плюсы:**

- Работает в кластере
- Централизованное управление
- Консистентность между инстансами

**Минусы:**

- Сложность реализации
- Зависимость от Redis
- Сетевые задержки

## Решение

Принят гибридный подход с использованием Token Bucket для пользователей и Fixed Window для API endpoints.

### Архитектура Rate Limiting

```shell
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   User Request  │───▶│  Rate Limiter   │───▶│   Application   │
│                 │    │                 │    │                 │
│ 1. Check Limits │    │ 1. Token Bucket │    │ 1. Process      │
│ 2. Update Count │    │ 2. Redis Store  │    │ 2. Response     │
│ 3. Allow/Deny   │    │ 3. Sliding Win  │    │ 3. Logging      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Стратегии лимитирования

#### 1. **Telegram Bot Messages**

- **Алгоритм**: Token Bucket
- **Лимит**: 20 сообщений в минуту
- **Burst**: До 5 сообщений за раз
- **Хранение**: Redis с TTL 1 час

#### 2. **Admin API**

- **Алгоритм**: Fixed Window
- **Лимит**: 100 запросов в минуту
- **Window**: 60 секунд
- **Хранение**: Redis с TTL 2 минуты

#### 3. **Webhook Endpoints**

- **Алгоритм**: Sliding Window
- **Лимит**: 1000 запросов в минуту
- **Window**: 60 секунд
- **Хранение**: Redis с TTL 2 минуты

### Реализация

```go
type RateLimiter interface {
    Allow(ctx context.Context, key string, limit int, window time.Duration) (bool, error)
    Remaining(ctx context.Context, key string, limit int, window time.Duration) (int, error)
    Reset(ctx context.Context, key string) error
}

type RateLimitConfig struct {
    Limit  int           // Максимальное количество запросов
    Window time.Duration // Временное окно
    Burst  int           // Размер burst (для Token Bucket)
}
```

### Конфигурация по типам запросов

#### 1. **User Messages**

```go
UserMessageConfig = RateLimitConfig{
    Limit:  20,              // 20 сообщений
    Window: time.Minute,     // в минуту
    Burst:  5,               // до 5 за раз
}
```

#### 2. **Admin API's**

```go
AdminAPIConfig = RateLimitConfig{
    Limit:  100,             // 100 запросов
    Window: time.Minute,     // в минуту
    Burst:  10,              // до 10 за раз
}
```

#### 3. **Webhook**

```go
WebhookConfig = RateLimitConfig{
    Limit:  1000,            // 1000 запросов
    Window: time.Minute,     // в минуту
    Burst:  50,              // до 50 за раз
}
```

## Последствия

### Положительные

- **Защита от спама**: Эффективная защита от злоупотреблений
- **Стабильность**: Предотвращение перегрузки системы
- **Справедливость**: Равномерное распределение ресурсов
- **Мониторинг**: Детальные метрики использования
- **Гибкость**: Разные лимиты для разных типов запросов

### Отрицательные

- **Сложность**: Дополнительная логика
- **Производительность**: Накладные расходы на проверки
- **Ложные срабатывания**: Может блокировать легитимных пользователей
- **Настройка**: Требует тщательной настройки лимитов
- **Зависимость**: Зависимость от Redis для distributed лимитов

## Мониторинг и алерты

### Метрики

- **Request Rate**: Количество запросов в секунду
- **Blocked Requests**: Количество заблокированных запросов
- **Hit Rate**: Процент попаданий в лимиты
- **Response Time**: Время обработки rate limiting

### Алерты

- Высокий процент заблокированных запросов (>10%)
- Необычно высокий трафик от одного пользователя
- Redis недоступен для rate limiting
- Превышение лимитов административными запросами

## Graceful Degradation

### При недоступности Redis

1. **Fallback на in-memory**: Локальные лимиты
2. **Уведомление**: Алерт администраторам
3. **Логирование**: Запись всех запросов
4. **Мониторинг**: Отслеживание аномалий

### При перегрузке

1. **Prioritization**: Приоритет для критических запросов
2. **Queue**: Очередь для обработки
3. **Load shedding**: Отклонение менее важных запросов

## Связанные решения

- ADR-002: Стратегия кэширования с Redis (используется для хранения лимитов)
- ADR-003: Паттерн Circuit Breaker (защита Redis)
- ADR-005: Централизация обработки ошибок
