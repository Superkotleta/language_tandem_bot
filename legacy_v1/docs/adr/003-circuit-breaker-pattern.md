# ADR-003: Паттерн Circuit Breaker

## Статус

Принято

## Контекст

При интеграции с внешними сервисами (Telegram API, Redis, PostgreSQL) возникла необходимость защиты от каскадных сбоев:

- Telegram API может быть недоступен
- Redis может падать
- База данных может быть перегружена
- Сетевые проблемы между сервисами
- Необходимость graceful degradation

## Рассмотренные варианты

### 1. Retry с exponential backoff

**Плюсы:**

- Простота реализации
- Автоматическое восстановление

**Минусы:**

- Не защищает от каскадных сбоев
- Может усугубить проблему при перегрузке
- Нет быстрого отказа при критических сбоях

### 2. Timeout-based подход

**Плюсы:**

- Простота
- Быстрый отказ

**Минусы:**

- Нет адаптации к состоянию сервиса
- Может блокировать здоровые запросы

### 3. Circuit Breaker pattern

**Плюсы:**

- Защита от каскадных сбоев
- Быстрый отказ при сбоях
- Автоматическое восстановление
- Адаптация к состоянию сервиса

**Минусы:**

- Сложность реализации
- Дополнительная логика

### 4. Bulkhead pattern

**Плюсы:**

- Изоляция ресурсов
- Защита от перегрузки

**Минусы:**

- Не решает проблему внешних сервисов
- Сложность настройки

## Решение

Принят Circuit Breaker pattern с адаптацией под Go и микросервисную архитектуру.

### Состояния Circuit Breaker

```shell
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   CLOSED    │───▶│    OPEN     │───▶│ HALF-OPEN   │
│             │    │             │    │             │
│ Нормальная  │    │ Быстрый    │    │ Тестирование│
│ работа      │    │ отказ      │    │ восстановления│
└─────────────┘    └─────────────┘    └─────────────┘
       ▲                   │                   │
       └───────────────────┴───────────────────┘
```

### Реализация для каждого сервиса

#### 1. **Telegram Circuit Breaker**

```go
type TelegramCircuitBreaker struct {
    failureThreshold int           // 5 ошибок
    timeout          time.Duration // 30 секунд
    retryInterval    time.Duration // 60 секунд
}
```

**Конфигурация:**

- **Failure Threshold**: 5 ошибок подряд
- **Timeout**: 30 секунд в OPEN состоянии
- **Retry Interval**: 60 секунд между попытками

#### 2. **Database Circuit Breaker**

```go
type DatabaseCircuitBreaker struct {
    failureThreshold int           // 3 ошибки
    timeout          time.Duration // 15 секунд
    retryInterval    time.Duration // 30 секунд
}
```

**Конфигурация:**

- **Failure Threshold**: 3 ошибки подряд
- **Timeout**: 15 секунд в OPEN состоянии
- **Retry Interval**: 30 секунд между попытками

#### 3. **Redis Circuit Breaker**

```go
type RedisCircuitBreaker struct {
    failureThreshold int           // 3 ошибки
    timeout          time.Duration // 10 секунд
    retryInterval    time.Duration // 20 секунд
}
```

**Конфигурация:**

- **Failure Threshold**: 3 ошибки подряд
- **Timeout**: 10 секунд в OPEN состоянии
- **Retry Interval**: 20 секунд между попытками

### Fallback стратегии

#### 1. **Telegram API недоступен**

- Использование in-memory кэша
- Отложенная отправка сообщений
- Логирование для последующей обработки

#### 2. **Redis недоступен**

- Fallback на in-memory кэш
- Снижение производительности
- Уведомление администраторов

#### 3. **Database недоступен**

- Критическая ошибка
- Graceful shutdown
- Алерт администраторам

## Последствия

### Положительные

- **Отказоустойчивость**: Защита от каскадных сбоев
- **Производительность**: Быстрый отказ при сбоях
- **Восстановление**: Автоматическое восстановление
- **Мониторинг**: Детальные метрики состояния
- **Graceful degradation**: Система продолжает работать

### Отрицательные

- **Сложность**: Дополнительная логика
- **Ложные срабатывания**: Может блокировать здоровые запросы
- **Настройка**: Требует тщательной настройки параметров
- **Отладка**: Сложнее диагностировать проблемы

## Мониторинг и алерты

### Метрики

- **State Changes**: Переходы между состояниями
- **Failure Rate**: Процент неудачных запросов
- **Response Time**: Время ответа сервисов
- **Recovery Time**: Время восстановления

### Алерты

- Circuit Breaker перешел в OPEN состояние
- Длительное пребывание в OPEN состоянии
- Высокий процент срабатываний
- Неудачные попытки восстановления

## Реализация

```go
type CircuitBreaker interface {
    Execute(operation func() (interface{}, error)) (interface{}, error)
    State() State
    Counts() Counts
}

type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)
```

## Связанные решения

- ADR-001: Принятие Clean Architecture
- ADR-002: Стратегия кэширования с Redis
- ADR-005: Централизация обработки ошибок
