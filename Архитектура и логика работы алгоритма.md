# Архитектура и логика работы алгоритма подбора языковых партнеров

## Общая концепция системы

**Цель**: Найти одного идеального языкового друга для каждого пользователя на основе взаимной совместимости языков, интересов, стиля общения и временной доступности.

**Принцип**: Качество важнее количества — система ищет **одного оптимального партнера**, а не множество вариантов.

## 1. Архитектура базы данных

### Основные таблицы

#### `users` — базовая информация о пользователях

```sql

CREATE TABLE users (
id SERIAL PRIMARY KEY,
telegram_id BIGINT UNIQUE NOT NULL,
username TEXT,
first_name TEXT,
created_at TIMESTAMP DEFAULT NOW(),
state TEXT DEFAULT '',
profile_completion_level INT DEFAULT 1
);

```

#### `languages` — справочник языков

```sql

CREATE TABLE languages (
id SERIAL PRIMARY KEY,
code VARCHAR(10),
name TEXT
);

```

#### `user_language_pairs` — языковые профили пользователей

```sql

CREATE TABLE user_language_pairs (
id SERIAL PRIMARY KEY,
user_id INT REFERENCES users(id),
native_language_id INT REFERENCES languages(id),
target_language_id INT REFERENCES languages(id),
target_level TEXT CHECK (target_level IN ('beginner', 'intermediate', 'advanced'))
);

CREATE INDEX idx_user_language_pairs_user_id ON user_language_pairs(user_id);
```

#### `friendship_preferences` — предпочтения по общению

```sql

CREATE TABLE friendship_preferences (
id SERIAL PRIMARY KEY,
user_id INT REFERENCES users(id),
activity_type TEXT, -- movies, games, casual_chat, creative, active, educational
communication_style TEXT, -- text, voice_msg, audio_call, video_call, meet_person
communication_frequency TEXT -- spontaneous, weekly, daily, intensive
);

```

#### `user_time_availability` — временная доступность

```sql

CREATE TABLE user_time_availability (
id SERIAL PRIMARY KEY,
user_id INT REFERENCES users(id),
day_type TEXT CHECK (day_type IN ('weekdays', 'weekends', 'any')),
time_slot TEXT CHECK (time_slot IN ('morning', 'day', 'evening', 'late'))
);

```

#### `match_queue` — очередь найденных совпадений

```sql

CREATE TABLE match_queue (
id SERIAL PRIMARY KEY,
user1_id INT REFERENCES users(id),
user2_id INT REFERENCES users(id),
compatibility_score INT,
found_at TIMESTAMP DEFAULT NOW(),
sent_at TIMESTAMP NULL,
status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'cancelled'))
);

CREATE UNIQUE INDEX idx_match_queue_users ON match_queue(user1_id, user2_id);
```

#### `interests` — справочник интересов

```sql

CREATE TABLE interests (
id SERIAL PRIMARY KEY,
name TEXT NOT NULL,
type TEXT -- Категория интереса (спорт, музыка, наука и т.д.)
);

```

#### `user_interests` — связь пользователей с интересами

```sql

CREATE TABLE user_interests (
id SERIAL PRIMARY KEY,
user_id INT REFERENCES users(id),
interest_id INT REFERENCES interests(id),
is_main BOOLEAN DEFAULT FALSE
);

CREATE INDEX idx_user_interests_user_id ON user_interests(user_id);
```

#### `user_traits` — черты характера пользователей

```sql

CREATE TABLE user_traits (
id SERIAL PRIMARY KEY,
user_id INT REFERENCES users(id),
trait TEXT,
value TEXT -- yes/no, high/low и т.д.
);

CREATE INDEX idx_user_traits_user_id ON user_traits(user_id);
```

### Рекомендуемые индексы для оптимизации

```sql
- CREATE INDEX idx_users_telegram_id ON users(telegram_id);
```

## 2. Алгоритм подбора совместимых партнеров

### Основная логика совместимости

#### **Обязательные критерии** (100% совпадение)

1. **Языковая совместимость**: Родной язык пользователя A = Изучаемый язык пользователя B, и наоборот
2. **Временная совместимость**: Пересечение по дням недели и времени суток

#### **Дополнительные критерии** (влияют на итоговый рейтинг)

- **Совместимость интересов/активностей** (40 баллов за совпадение по activity_type + 10 баллов за каждый общий интерес)
- **Совместимость стиля общения** (30 баллов)
- **Совместимость по частоте общения** (30 баллов)
- **Совместимость по чертам характера** (опционально, 20 баллов за совпадения)

### SQL-запрос алгоритма

```sql

WITH compatibility_matrix AS (
SELECT
u1.id as user1_id,
u2.id as user2_id,
-- Языковая совместимость (обязательна = 100 баллов)
CASE WHEN EXISTS (
SELECT 1 FROM user_language_pairs ulp1
JOIN user_language_pairs ulp2 ON (
ulp1.native_language_id = ulp2.target_language_id
AND ulp1.target_language_id = ulp2.native_language_id
)
WHERE ulp1.user_id = u1.id AND ulp2.user_id = u2.id
) THEN 100 ELSE 0 END as language_match,

        -- Временная совместимость (обязательна = 30 баллов за каждое совпадение)
        COALESCE((
            SELECT COUNT(*) * 30
            FROM user_time_availability ta1
            JOIN user_time_availability ta2 ON (
                (ta1.day_type = ta2.day_type OR ta1.day_type = 'any' OR ta2.day_type = 'any')
                AND ta1.time_slot = ta2.time_slot
            )
            WHERE ta1.user_id = u1.id AND ta2.user_id = u2.id
        ), 0) as time_compatibility,
        
        -- Совместимость по активностям (40 баллов)
        CASE WHEN fp1.activity_type = fp2.activity_type THEN 40 ELSE 0 END as activity_match,
        
        -- Совместимость по стилю общения (30 баллов)
        CASE WHEN fp1.communication_style = fp2.communication_style THEN 30 ELSE 0 END as communication_match,
        
        -- Совместимость по частоте (30 баллов)
        CASE WHEN fp1.communication_frequency = fp2.communication_frequency THEN 30 ELSE 0 END as frequency_match,
        
        -- Совместимость по интересам (10 баллов за каждый общий интерес, макс 50)
        COALESCE((
            SELECT LEAST(COUNT(*) * 10, 50)
            FROM user_interests ui1
            JOIN user_interests ui2 ON ui1.interest_id = ui2.interest_id
            WHERE ui1.user_id = u1.id AND ui2.user_id = u2.id
        ), 0) as interests_match,
        
        -- Совместимость по чертам характера (5 баллов за каждую совпадающую черту, макс 20)
        COALESCE((
            SELECT LEAST(COUNT(*) * 5, 20)
            FROM user_traits ut1
            JOIN user_traits ut2 ON ut1.trait = ut2.trait AND ut1.value = ut2.value
            WHERE ut1.user_id = u1.id AND ut2.user_id = u2.id
        ), 0) as traits_match
        
    FROM users u1
    CROSS JOIN users u2
    JOIN friendship_preferences fp1 ON u1.id = fp1.user_id
    JOIN friendship_preferences fp2 ON u2.id = fp2.user_id
    WHERE u1.id != u2.id
      AND u1.profile_completion_level > 0
      AND u2.profile_completion_level > 0
    )
SELECT
user1_id,
user2_id,
(language_match + time_compatibility + activity_match + communication_match + frequency_match + interests_match + traits_match) as total_score
FROM compatibility_matrix
WHERE language_match = 100
AND time_compatibility > 0
ORDER BY total_score DESC;
```

## 3. Workflow выполнения алгоритма

### **Фаза 1: Заполнение профиля пользователем**

1. Пользователь регистрируется через команду `/start`
2. Бот проводит пошаговое заполнение профиля:
    - Выбор родного и изучаемого языка
    - Выбор интересов/активностей (теперь включая детальные интересы и черты характера)
    - Выбор предпочтений по общению
    - Указание временной доступности
3. Профиль сохраняется в БД со статусом "готов к подбору"

### **Фаза 2: Запуск алгоритма администратором**

**Команда: `/admin_find_matches`**

```sql

func runMatchingAlgorithm() []Match {
// 1. Получаем всех пользователей с заполненными профилями
users := getUsersReadyForMatching()

    // 2. Запускаем SQL-алгоритм подбора
    potentialMatches := executeCompatibilityQuery()
    
    // 3. Фильтруем уже существующие совпадения
    newMatches := filterExistingMatches(potentialMatches)
    
    // 4. Применяем правило "один лучший матч на пользователя"
    finalMatches := selectBestMatchPerUser(newMatches)
    
    return finalMatches
    }

```

**Логика "лучший матч на пользователя":**

- Если для пользователя найдено несколько потенциальных партнеров, выбирается тот, с которым **наивысший общий балл совместимости**
- Каждый пользователь может получить **только одно совпадение** за запуск алгоритма

### **Фаза 3: Сохранение результатов в очередь**

Найденные совпадения сохраняются в таблицу `match_queue` со статусом `pending`, но **НЕ отправляются** пользователям автоматически.

### **Фаза 4: Проверка и отправка администратором**

**Команда: `/admin_send_matches`**

```sql

func sendQueuedMatches() {
// 1. Получаем все совпадения в статусе 'pending'
queuedMatches := getQueuedMatches()

    // 2. Для каждого совпадения отправляем уведомления
    for match := range queuedMatches {
        // Отправляем пользователю A информацию о пользователе B
        sendMatchNotification(match.User1ID, match.User2ID)
        
        // Отправляем пользователю B информацию о пользователе A  
        sendMatchNotification(match.User2ID, match.User1ID)
        
        // Обновляем статус на 'sent'
        updateMatchStatus(match.ID, "sent")
    }
    }

```

## 4. Формат уведомлений пользователям

### Уведомление о найденном языковом друге

```text

🎉 Мы нашли вам языкового друга!

👤 Имя: Анна
🗣️ Родной язык: Английский
📚 Изучает: Русский (средний уровень)
🎬 Интересы: Фильмы и сериалы, Музыка
💬 Предпочитает: Видеозвонки
⏰ Доступна: Будни вечером

📞 Телеграм: @anna_english

💡 Рекомендуем начать с короткого знакомства на 15 минут — половину времени говорите на русском, половину на английском!

[ 📝 Написать Анне ]

```

## 5. Административные команды

### `/admin_find_matches` — запуск алгоритма подбора

- Анализирует всех пользователей с заполненными профилями
- Находит оптимальные совпадения
- Сохраняет результаты в очередь `match_queue`
- Возвращает статистику найденных совпадений

### `/admin_send_matches` — отправка найденных совпадений

- Получает все совпадения в статусе `pending`
- Отправляет уведомления пользователям
- Обновляет статус совпадений на `sent`

### `/admin_match_stats` — статистика работы системы

- Количество пользователей с профилями
- Совпадения в очереди
- Общее количество отправленных совпадений
- Процент успешности алгоритма

### `/admin_preview_matches` — предпросмотр совпадений

- Показывает детали найденных совпадений перед отправкой
- Позволяет проверить качество подбора
- Отображает рейтинг совместимости и причины совпадения

## 6. Ключевые особенности алгоритма

### **Принцип взаимности**

Алгоритм ищет **взаимно совместимых** партнеров, где языковые потребности одного пользователя дополняют языковые возможности другого.

### **Фокус на качестве**

- Один пользователь = один лучший матч
- Строгие критерии совместимости (теперь включая интересы и черты характера)
- Ручная проверка администратором перед отправкой

### **Гибкость системы**

- Легко добавлять новые критерии совместимости
- Настраиваемые весовые коэффициенты для разных факторов
- Возможность отмены или переподбора совпадений

### **Предотвращение дубликатов**

- Система запоминает уже показанные совпадения
- Исключает повторную отправку тех же пар
- Ведет историю всех матчей для аналитики

## 7. Планы развития алгоритма

### **Фаза расширения 1:**

- Учет feedback'а от пользователей о качестве совпадений
- Машинное обучение для улучшения алгоритма подбора

### **Фаза расширения 2:**

- Групповые языковые сессии (3-4 участника)
- Специализированные тандемы (деловой английский, подготовка к экзаменам)
- Интеграция с календарями для автоматического планирования встреч.
