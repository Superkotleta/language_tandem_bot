
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>logging: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">language-exchange-bot/internal/logging/component_loggers.go (92.3%)</option>
				
				<option value="file1">language-exchange-bot/internal/logging/integration.go (54.8%)</option>
				
				<option value="file2">language-exchange-bot/internal/logging/logger.go (91.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package logging

import (
        "language-exchange-bot/internal/errors"
        "time"
)

// ComponentLogger предоставляет специализированное логирование для компонентов
type ComponentLogger struct {
        *Logger
}

// NewComponentLogger создает логгер для компонента
func NewComponentLogger(component string) *ComponentLogger <span class="cov8" title="1">{
        return &amp;ComponentLogger{
                Logger: NewLoggerFromEnv(component),
        }
}</span>

// TelegramLogger предоставляет логирование для Telegram бота
type TelegramLogger struct {
        *ComponentLogger
}

// NewTelegramLogger создает логгер для Telegram бота
func NewTelegramLogger() *TelegramLogger <span class="cov8" title="1">{
        return &amp;TelegramLogger{
                ComponentLogger: NewComponentLogger("telegram"),
        }
}</span>

// LogMessageReceived логирует получение сообщения
func (tl *TelegramLogger) LogMessageReceived(chatID, userID int64, text, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Message received",
                requestID,
                userID,
                chatID,
                "HandleMessage",
                map[string]interface{}{
                        "text_length": len(text),
                        "has_text":    text != "",
                },
        )
}</span>

// LogMessageSent логирует отправку сообщения
func (tl *TelegramLogger) LogMessageSent(chatID, userID int64, text, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Message sent",
                requestID,
                userID,
                chatID,
                "SendMessage",
                map[string]interface{}{
                        "text_length": len(text),
                },
        )
}</span>

// LogCallbackReceived логирует получение callback query
func (tl *TelegramLogger) LogCallbackReceived(chatID, userID int64, data, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Callback received",
                requestID,
                userID,
                chatID,
                "HandleCallback",
                map[string]interface{}{
                        "callback_data": data,
                },
        )
}</span>

// LogCommandExecuted логирует выполнение команды
func (tl *TelegramLogger) LogCommandExecuted(chatID, userID int64, command, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Command executed",
                requestID,
                userID,
                chatID,
                "ExecuteCommand",
                map[string]interface{}{
                        "command": command,
                },
        )
}</span>

// LogError логирует ошибку с контекстом
func (tl *TelegramLogger) LogError(err error, chatID, userID int64, operation, requestID string) <span class="cov8" title="1">{
        if customErr, ok := err.(*errors.CustomError); ok </span><span class="cov8" title="1">{
                tl.ErrorWithContext(
                        "Error occurred",
                        requestID,
                        userID,
                        chatID,
                        operation,
                        map[string]interface{}{
                                "error_type": customErr.Type.String(),
                                "error_msg":  customErr.Message,
                                "user_msg":   customErr.UserMessage,
                        },
                )
        }</span> else<span class="cov0" title="0"> {
                tl.ErrorWithContext(
                        "Error occurred",
                        requestID,
                        userID,
                        chatID,
                        operation,
                        map[string]interface{}{
                                "error_msg": err.Error(),
                        },
                )
        }</span>
}

// DatabaseLogger предоставляет логирование для базы данных
type DatabaseLogger struct {
        *ComponentLogger
}

// NewDatabaseLogger создает логгер для базы данных
func NewDatabaseLogger() *DatabaseLogger <span class="cov8" title="1">{
        return &amp;DatabaseLogger{
                ComponentLogger: NewComponentLogger("database"),
        }
}</span>

// LogQueryExecuted логирует выполнение запроса
func (dl *DatabaseLogger) LogQueryExecuted(query string, duration time.Duration, requestID string) <span class="cov8" title="1">{
        dl.DebugWithContext(
                "Query executed",
                requestID,
                0,
                0,
                "ExecuteQuery",
                map[string]interface{}{
                        "query":    query,
                        "duration": duration.String(),
                },
        )
}</span>

// LogConnectionEstablished логирует установление соединения
func (dl *DatabaseLogger) LogConnectionEstablished(requestID string) <span class="cov8" title="1">{
        dl.InfoWithContext(
                "Database connection established",
                requestID,
                0,
                0,
                "Connect",
        )
}</span>

// LogConnectionFailed логирует ошибку соединения
func (dl *DatabaseLogger) LogConnectionFailed(err error, requestID string) <span class="cov8" title="1">{
        dl.ErrorWithContext(
                "Database connection failed",
                requestID,
                0,
                0,
                "Connect",
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>

// LogTransactionStarted логирует начало транзакции
func (dl *DatabaseLogger) LogTransactionStarted(requestID string) <span class="cov8" title="1">{
        dl.DebugWithContext(
                "Transaction started",
                requestID,
                0,
                0,
                "BeginTransaction",
        )
}</span>

// LogTransactionCommitted логирует коммит транзакции
func (dl *DatabaseLogger) LogTransactionCommitted(requestID string) <span class="cov8" title="1">{
        dl.DebugWithContext(
                "Transaction committed",
                requestID,
                0,
                0,
                "CommitTransaction",
        )
}</span>

// LogTransactionRolledBack логирует откат транзакции
func (dl *DatabaseLogger) LogTransactionRolledBack(err error, requestID string) <span class="cov0" title="0">{
        dl.WarnWithContext(
                "Transaction rolled back",
                requestID,
                0,
                0,
                "RollbackTransaction",
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>

// CacheLogger предоставляет логирование для кэша
type CacheLogger struct {
        *ComponentLogger
}

// NewCacheLogger создает логгер для кэша
func NewCacheLogger() *CacheLogger <span class="cov8" title="1">{
        return &amp;CacheLogger{
                ComponentLogger: NewComponentLogger("cache"),
        }
}</span>

// LogCacheHit логирует попадание в кэш
func (cl *CacheLogger) LogCacheHit(key string, requestID string) <span class="cov8" title="1">{
        cl.DebugWithContext(
                "Cache hit",
                requestID,
                0,
                0,
                "GetFromCache",
                map[string]interface{}{
                        "key": key,
                },
        )
}</span>

// LogCacheMiss логирует промах кэша
func (cl *CacheLogger) LogCacheMiss(key string, requestID string) <span class="cov8" title="1">{
        cl.DebugWithContext(
                "Cache miss",
                requestID,
                0,
                0,
                "GetFromCache",
                map[string]interface{}{
                        "key": key,
                },
        )
}</span>

// LogCacheSet логирует установку значения в кэш
func (cl *CacheLogger) LogCacheSet(key string, ttl time.Duration, requestID string) <span class="cov8" title="1">{
        cl.DebugWithContext(
                "Cache set",
                requestID,
                0,
                0,
                "SetToCache",
                map[string]interface{}{
                        "key": key,
                        "ttl": ttl.String(),
                },
        )
}</span>

// LogCacheInvalidated логирует инвалидацию кэша
func (cl *CacheLogger) LogCacheInvalidated(pattern string, requestID string) <span class="cov8" title="1">{
        cl.InfoWithContext(
                "Cache invalidated",
                requestID,
                0,
                0,
                "InvalidateCache",
                map[string]interface{}{
                        "pattern": pattern,
                },
        )
}</span>

// LogCacheError логирует ошибку кэша
func (cl *CacheLogger) LogCacheError(err error, operation, requestID string) <span class="cov8" title="1">{
        cl.ErrorWithContext(
                "Cache error",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>

// ValidationLogger предоставляет логирование для валидации
type ValidationLogger struct {
        *ComponentLogger
}

// NewValidationLogger создает логгер для валидации
func NewValidationLogger() *ValidationLogger <span class="cov8" title="1">{
        return &amp;ValidationLogger{
                ComponentLogger: NewComponentLogger("validation"),
        }
}</span>

// LogValidationPassed логирует успешную валидацию
func (vl *ValidationLogger) LogValidationPassed(operation string, requestID string) <span class="cov8" title="1">{
        vl.DebugWithContext(
                "Validation passed",
                requestID,
                0,
                0,
                operation,
        )
}</span>

// LogValidationFailed логирует неудачную валидацию
func (vl *ValidationLogger) LogValidationFailed(operation string, errors map[string][]string, requestID string) <span class="cov8" title="1">{
        vl.WarnWithContext(
                "Validation failed",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "validation_errors": errors,
                },
        )
}</span>

// LogValidationError логирует ошибку валидации
func (vl *ValidationLogger) LogValidationError(err error, operation, requestID string) <span class="cov8" title="1">{
        vl.ErrorWithContext(
                "Validation error",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package logging

import (
        "language-exchange-bot/internal/errors"
)

// LoggingService предоставляет централизованное логирование
type LoggingService struct {
        telegramLogger   *TelegramLogger
        databaseLogger   *DatabaseLogger
        cacheLogger      *CacheLogger
        validationLogger *ValidationLogger
        errorHandler     *errors.ErrorHandler
}

// NewLoggingService создает новый сервис логирования
func NewLoggingService(errorHandler *errors.ErrorHandler) *LoggingService <span class="cov8" title="1">{
        return &amp;LoggingService{
                telegramLogger:   NewTelegramLogger(),
                databaseLogger:   NewDatabaseLogger(),
                cacheLogger:      NewCacheLogger(),
                validationLogger: NewValidationLogger(),
                errorHandler:     errorHandler,
        }
}</span>

// Telegram возвращает логгер для Telegram
func (ls *LoggingService) Telegram() *TelegramLogger <span class="cov0" title="0">{
        return ls.telegramLogger
}</span>

// Database возвращает логгер для базы данных
func (ls *LoggingService) Database() *DatabaseLogger <span class="cov0" title="0">{
        return ls.databaseLogger
}</span>

// Cache возвращает логгер для кэша
func (ls *LoggingService) Cache() *CacheLogger <span class="cov0" title="0">{
        return ls.cacheLogger
}</span>

// Validation возвращает логгер для валидации
func (ls *LoggingService) Validation() *ValidationLogger <span class="cov0" title="0">{
        return ls.validationLogger
}</span>

// LogErrorWithContext логирует ошибку с полным контекстом
func (ls *LoggingService) LogErrorWithContext(err error, requestID string, userID, chatID int64, operation, component string) <span class="cov8" title="1">{
        if customErr, ok := err.(*errors.CustomError); ok </span><span class="cov8" title="1">{
                // Логируем в зависимости от типа ошибки
                switch customErr.Type </span>{
                case errors.ErrorTypeTelegramAPI:<span class="cov8" title="1">
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                case errors.ErrorTypeDatabase:<span class="cov0" title="0">
                        ls.databaseLogger.ErrorWithContext(
                                "Database error",
                                requestID,
                                userID,
                                chatID,
                                operation,
                                map[string]interface{}{
                                        "error_type": customErr.Type.String(),
                                        "error_msg":  customErr.Message,
                                        "user_msg":   customErr.UserMessage,
                                },
                        )</span>
                case errors.ErrorTypeCache:<span class="cov0" title="0">
                        ls.cacheLogger.LogCacheError(err, operation, requestID)</span>
                case errors.ErrorTypeValidation:<span class="cov0" title="0">
                        ls.validationLogger.LogValidationError(err, operation, requestID)</span>
                default:<span class="cov0" title="0">
                        // Логируем в общий логгер
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                }
        } else<span class="cov0" title="0"> {
                // Логируем в зависимости от компонента
                switch component </span>{
                case "telegram":<span class="cov0" title="0">
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                case "database":<span class="cov0" title="0">
                        ls.databaseLogger.ErrorWithContext(
                                "Database error",
                                requestID,
                                userID,
                                chatID,
                                operation,
                                map[string]interface{}{
                                        "error": err.Error(),
                                },
                        )</span>
                case "cache":<span class="cov0" title="0">
                        ls.cacheLogger.LogCacheError(err, operation, requestID)</span>
                case "validation":<span class="cov0" title="0">
                        ls.validationLogger.LogValidationError(err, operation, requestID)</span>
                default:<span class="cov0" title="0">
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                }
        }
}

// LogRequestStart логирует начало запроса
func (ls *LoggingService) LogRequestStart(requestID string, userID, chatID int64, operation string) <span class="cov8" title="1">{
        ls.telegramLogger.InfoWithContext(
                "Request started",
                requestID,
                userID,
                chatID,
                operation,
        )
}</span>

// LogRequestEnd логирует завершение запроса
func (ls *LoggingService) LogRequestEnd(requestID string, userID, chatID int64, operation string, success bool) <span class="cov8" title="1">{
        level := "completed"
        if !success </span><span class="cov8" title="1">{
                level = "failed"
        }</span>

        <span class="cov8" title="1">ls.telegramLogger.InfoWithContext(
                "Request "+level,
                requestID,
                userID,
                chatID,
                operation,
                map[string]interface{}{
                        "success": success,
                },
        )</span>
}

// LogPerformance логирует метрики производительности
func (ls *LoggingService) LogPerformance(operation string, duration string, requestID string, fields map[string]interface{}) <span class="cov8" title="1">{
        ls.telegramLogger.InfoWithContext(
                "Performance metric",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "duration": duration,
                        "fields":   fields,
                },
        )
}</span>

// LogSecurityEvent логирует события безопасности
func (ls *LoggingService) LogSecurityEvent(event string, userID, chatID int64, requestID string, fields map[string]interface{}) <span class="cov8" title="1">{
        ls.telegramLogger.WarnWithContext(
                "Security event: "+event,
                requestID,
                userID,
                chatID,
                "SecurityEvent",
                fields,
        )
}</span>

// LogAdminAction логирует действия администратора
func (ls *LoggingService) LogAdminAction(action string, adminID, targetUserID int64, requestID string, fields map[string]interface{}) <span class="cov8" title="1">{
        ls.telegramLogger.InfoWithContext(
                "Admin action: "+action,
                requestID,
                adminID,
                0,
                "AdminAction",
                map[string]interface{}{
                        "target_user_id": targetUserID,
                        "fields":         fields,
                },
        )
}</span>

// SetLogLevel устанавливает уровень логирования для всех компонентов
func (ls *LoggingService) SetLogLevel(level LogLevel) <span class="cov8" title="1">{
        ls.telegramLogger.SetLevel(level)
        ls.databaseLogger.SetLevel(level)
        ls.cacheLogger.SetLevel(level)
        ls.validationLogger.SetLevel(level)
}</span>

// GetLogLevel возвращает текущий уровень логирования
func (ls *LoggingService) GetLogLevel() LogLevel <span class="cov8" title="1">{
        return ls.telegramLogger.GetLevel()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package logging

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"
)

// LogLevel определяет уровень логирования
type LogLevel int

const (
        DEBUG LogLevel = iota
        INFO
        WARN
        ERROR
)

// String возвращает строковое представление уровня логирования
func (ll LogLevel) String() string <span class="cov8" title="1">{
        switch ll </span>{
        case DEBUG:<span class="cov8" title="1">
                return "DEBUG"</span>
        case INFO:<span class="cov8" title="1">
                return "INFO"</span>
        case WARN:<span class="cov8" title="1">
                return "WARN"</span>
        case ERROR:<span class="cov8" title="1">
                return "ERROR"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// ParseLogLevel парсит строку в LogLevel
func ParseLogLevel(level string) LogLevel <span class="cov8" title="1">{
        switch level </span>{
        case "DEBUG":<span class="cov8" title="1">
                return DEBUG</span>
        case "INFO":<span class="cov8" title="1">
                return INFO</span>
        case "WARN":<span class="cov8" title="1">
                return WARN</span>
        case "ERROR":<span class="cov8" title="1">
                return ERROR</span>
        default:<span class="cov8" title="1">
                return INFO</span>
        }
}

// LogEntry представляет структурированную запись лога
type LogEntry struct {
        Timestamp time.Time              `json:"timestamp"`
        Level     LogLevel               `json:"level"`
        Message   string                 `json:"message"`
        RequestID string                 `json:"request_id,omitempty"`
        UserID    int64                  `json:"user_id,omitempty"`
        ChatID    int64                  `json:"chat_id,omitempty"`
        Operation string                 `json:"operation,omitempty"`
        Component string                 `json:"component,omitempty"`
        Fields    map[string]interface{} `json:"fields,omitempty"`
        Error     string                 `json:"error,omitempty"`
}

// Logger предоставляет структурированное логирование
type Logger struct {
        level     LogLevel
        component string
}

// NewLogger создает новый логгер
func NewLogger(level LogLevel, component string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                level:     level,
                component: component,
        }
}</span>

// NewLoggerFromEnv создает логгер из переменных окружения
func NewLoggerFromEnv(component string) *Logger <span class="cov8" title="1">{
        level := ParseLogLevel(os.Getenv("LOG_LEVEL"))
        return NewLogger(level, component)
}</span>

// Debug логирует сообщение уровня DEBUG
func (l *Logger) Debug(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(DEBUG, message, fields...)
}</span>

// Info логирует сообщение уровня INFO
func (l *Logger) Info(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(INFO, message, fields...)
}</span>

// Warn логирует сообщение уровня WARN
func (l *Logger) Warn(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(WARN, message, fields...)
}</span>

// Error логирует сообщение уровня ERROR
func (l *Logger) Error(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(ERROR, message, fields...)
}</span>

// DebugWithContext логирует сообщение уровня DEBUG с контекстом
func (l *Logger) DebugWithContext(message string, requestID string, userID, chatID int64, operation string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        entry := l.createLogEntry(DEBUG, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// InfoWithContext логирует сообщение уровня INFO с контекстом
func (l *Logger) InfoWithContext(message string, requestID string, userID, chatID int64, operation string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        entry := l.createLogEntry(INFO, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// WarnWithContext логирует сообщение уровня WARN с контекстом
func (l *Logger) WarnWithContext(message string, requestID string, userID, chatID int64, operation string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        entry := l.createLogEntry(WARN, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// ErrorWithContext логирует сообщение уровня ERROR с контекстом
func (l *Logger) ErrorWithContext(message string, requestID string, userID, chatID int64, operation string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        entry := l.createLogEntry(ERROR, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// log внутренний метод для логирования
func (l *Logger) log(level LogLevel, message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">entry := l.createLogEntry(level, message, "", 0, 0, "", fields...)
        l.writeLog(entry)</span>
}

// createLogEntry создает структурированную запись лога
func (l *Logger) createLogEntry(level LogLevel, message string, requestID string, userID, chatID int64, operation string, fields ...map[string]interface{}) *LogEntry <span class="cov8" title="1">{
        entry := &amp;LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Message:   message,
                Component: l.component,
        }

        if requestID != "" </span><span class="cov8" title="1">{
                entry.RequestID = requestID
        }</span>

        <span class="cov8" title="1">if userID &gt; 0 </span><span class="cov8" title="1">{
                entry.UserID = userID
        }</span>

        <span class="cov8" title="1">if chatID &gt; 0 </span><span class="cov8" title="1">{
                entry.ChatID = chatID
        }</span>

        <span class="cov8" title="1">if operation != "" </span><span class="cov8" title="1">{
                entry.Operation = operation
        }</span>

        // Объединяем все поля
        <span class="cov8" title="1">if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                entry.Fields = make(map[string]interface{})
                for _, fieldMap := range fields </span><span class="cov8" title="1">{
                        for key, value := range fieldMap </span><span class="cov8" title="1">{
                                entry.Fields[key] = value
                        }</span>
                }
        }

        <span class="cov8" title="1">return entry</span>
}

// writeLog записывает лог в формате JSON
func (l *Logger) writeLog(entry *LogEntry) <span class="cov8" title="1">{
        if entry.Level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">jsonData, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback на простое логирование
                log.Printf("[%s] %s: %s", entry.Level.String(), entry.Component, entry.Message)
                return
        }</span>

        // Выводим в stdout для структурированного логирования
        <span class="cov8" title="1">fmt.Println(string(jsonData))</span>
}

// SetLevel устанавливает уровень логирования
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.level = level
}</span>

// GetLevel возвращает текущий уровень логирования
func (l *Logger) GetLevel() LogLevel <span class="cov8" title="1">{
        return l.level
}</span>

// WithFields создает новый логгер с дополнительными полями
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                level:     l.level,
                component: l.component,
        }
}</span>

// WithComponent создает новый логгер с указанным компонентом
func (l *Logger) WithComponent(component string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                level:     l.level,
                component: component,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
