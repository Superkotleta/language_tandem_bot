
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">language-exchange-bot/cmd/bot/main.go (0.0%)</option>
				
				<option value="file1">language-exchange-bot/docs/docs.go (0.0%)</option>
				
				<option value="file2">language-exchange-bot/internal/adapters/telegram/bot.go (0.0%)</option>
				
				<option value="file3">language-exchange-bot/internal/adapters/telegram/callback_router.go (32.1%)</option>
				
				<option value="file4">language-exchange-bot/internal/adapters/telegram/handlers.go (10.6%)</option>
				
				<option value="file5">language-exchange-bot/internal/adapters/telegram/handlers/admin_handlers.go (0.0%)</option>
				
				<option value="file6">language-exchange-bot/internal/adapters/telegram/handlers/availability_handlers.go (0.0%)</option>
				
				<option value="file7">language-exchange-bot/internal/adapters/telegram/handlers/availability_keyboards.go (0.0%)</option>
				
				<option value="file8">language-exchange-bot/internal/adapters/telegram/handlers/base_handler.go (100.0%)</option>
				
				<option value="file9">language-exchange-bot/internal/adapters/telegram/handlers/feedback_handlers.go (0.0%)</option>
				
				<option value="file10">language-exchange-bot/internal/adapters/telegram/handlers/helpers.go (0.0%)</option>
				
				<option value="file11">language-exchange-bot/internal/adapters/telegram/handlers/improved_interest_handlers.go (0.0%)</option>
				
				<option value="file12">language-exchange-bot/internal/adapters/telegram/handlers/isolated_interest_editor.go (2.8%)</option>
				
				<option value="file13">language-exchange-bot/internal/adapters/telegram/handlers/isolated_keyboards.go (0.0%)</option>
				
				<option value="file14">language-exchange-bot/internal/adapters/telegram/handlers/keyboard_helpers.go (0.0%)</option>
				
				<option value="file15">language-exchange-bot/internal/adapters/telegram/handlers/language_handlers.go (0.0%)</option>
				
				<option value="file16">language-exchange-bot/internal/adapters/telegram/handlers/menu_handlers.go (0.0%)</option>
				
				<option value="file17">language-exchange-bot/internal/adapters/telegram/handlers/message_factory.go (12.9%)</option>
				
				<option value="file18">language-exchange-bot/internal/adapters/telegram/handlers/new_interest_handlers.go (0.0%)</option>
				
				<option value="file19">language-exchange-bot/internal/adapters/telegram/handlers/profile_handlers.go (0.0%)</option>
				
				<option value="file20">language-exchange-bot/internal/adapters/telegram/handlers/profile_interest_handlers.go (0.0%)</option>
				
				<option value="file21">language-exchange-bot/internal/adapters/telegram/handlers/utility_handlers.go (0.0%)</option>
				
				<option value="file22">language-exchange-bot/internal/adapters/telegram/keyboard_helpers.go (0.0%)</option>
				
				<option value="file23">language-exchange-bot/internal/adapters/telegram/message_factory.go (0.0%)</option>
				
				<option value="file24">language-exchange-bot/internal/adapters/telegram/rate_limiter.go (47.5%)</option>
				
				<option value="file25">language-exchange-bot/internal/cache/cache.go (24.6%)</option>
				
				<option value="file26">language-exchange-bot/internal/cache/invalidation.go (0.0%)</option>
				
				<option value="file27">language-exchange-bot/internal/cache/metrics.go (0.0%)</option>
				
				<option value="file28">language-exchange-bot/internal/cache/redis_cache.go (18.0%)</option>
				
				<option value="file29">language-exchange-bot/internal/cache/types.go (100.0%)</option>
				
				<option value="file30">language-exchange-bot/internal/circuit_breaker/circuit_breaker.go (79.2%)</option>
				
				<option value="file31">language-exchange-bot/internal/config/config.go (87.3%)</option>
				
				<option value="file32">language-exchange-bot/internal/config/interests_config.go (84.4%)</option>
				
				<option value="file33">language-exchange-bot/internal/core/interest_service.go (0.0%)</option>
				
				<option value="file34">language-exchange-bot/internal/core/service.go (9.8%)</option>
				
				<option value="file35">language-exchange-bot/internal/core/user_service.go (0.0%)</option>
				
				<option value="file36">language-exchange-bot/internal/database/batch_loader.go (6.5%)</option>
				
				<option value="file37">language-exchange-bot/internal/database/batch_operations.go (0.0%)</option>
				
				<option value="file38">language-exchange-bot/internal/database/db.go (56.1%)</option>
				
				<option value="file39">language-exchange-bot/internal/errors/alerting.go (82.4%)</option>
				
				<option value="file40">language-exchange-bot/internal/errors/centralized_handler.go (0.0%)</option>
				
				<option value="file41">language-exchange-bot/internal/errors/handler.go (82.9%)</option>
				
				<option value="file42">language-exchange-bot/internal/errors/tracing.go (50.0%)</option>
				
				<option value="file43">language-exchange-bot/internal/errors/types.go (69.7%)</option>
				
				<option value="file44">language-exchange-bot/internal/localization/localization.go (0.0%)</option>
				
				<option value="file45">language-exchange-bot/internal/logging/component_loggers.go (92.6%)</option>
				
				<option value="file46">language-exchange-bot/internal/logging/integration.go (52.9%)</option>
				
				<option value="file47">language-exchange-bot/internal/logging/logger.go (91.2%)</option>
				
				<option value="file48">language-exchange-bot/internal/logging/metrics.go (0.0%)</option>
				
				<option value="file49">language-exchange-bot/internal/logging/tracing.go (0.0%)</option>
				
				<option value="file50">language-exchange-bot/internal/monitoring/dashboard.go (0.0%)</option>
				
				<option value="file51">language-exchange-bot/internal/monitoring/integration.go (0.0%)</option>
				
				<option value="file52">language-exchange-bot/internal/server/docs/docs.go (0.0%)</option>
				
				<option value="file53">language-exchange-bot/internal/server/server.go (32.7%)</option>
				
				<option value="file54">language-exchange-bot/internal/validation/message_validator.go (91.8%)</option>
				
				<option value="file55">language-exchange-bot/internal/validation/user_validator.go (84.7%)</option>
				
				<option value="file56">language-exchange-bot/internal/validation/validation_service.go (99.0%)</option>
				
				<option value="file57">language-exchange-bot/internal/validation/validators.go (93.3%)</option>
				
				<option value="file58">language-exchange-bot/tests/helpers/config.go (0.0%)</option>
				
				<option value="file59">language-exchange-bot/tests/helpers/test_setup.go (0.0%)</option>
				
				<option value="file60">language-exchange-bot/tests/mocks/database_mock.go (0.0%)</option>
				
				<option value="file61">language-exchange-bot/tests/mocks/localizer_mock.go (0.0%)</option>
				
				<option value="file62">language-exchange-bot/tests/mocks/telegram_handler_mock.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the entry point for the Language Exchange Bot service.
//
//        @title                        Language Exchange Bot Admin API
//        @version                3.0.0
//        @description        This is the administrative API for the Language Exchange Telegram Bot.
//        @description        It provides endpoints for monitoring, user management, feedback processing, and system statistics.
//
//        @contact.name        Language Exchange Bot Team
//        @contact.url        https://github.com/your-org/language-exchange-bot
//        @contact.email        support@language-exchange-bot.com
//
//        @license.name        MIT
//        @license.url        https://opensource.org/licenses/MIT
//
//        @host                localhost:8080
//        @BasePath        /api/v1
//
//        @securityDefinitions.apikey        ApiKeyAuth
//        @in                                                        header
//        @name                                                X-Admin-Key
//        @description                                Admin API key for authentication
//
//        @externalDocs.description        OpenAPI
//        @externalDocs.url                        https://swagger.io/resources/open-api/
package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "language-exchange-bot/internal/adapters"
        "language-exchange-bot/internal/adapters/telegram"
        "language-exchange-bot/internal/config"
        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/database"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/server"
)

// Константы для таймаутов.
const (
        ForceShutdownTimeout = 10 * time.Second
)

func main() <span class="cov0" title="0">{
        cfg := config.Load()
        db := setupDatabase(cfg)

        defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing database connection: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">errorHandler := setupErrorHandler()

        ctx, cancel := setupGracefulShutdown()
        defer cancel()

        // Создаем общий сервис для всех компонентов (бот и admin API)
        service, err := initializeService(cfg, db, errorHandler)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize service: %v", err)
        }</span>

        // Start admin API server с общим сервисом
        <span class="cov0" title="0">adminServer := startAdminServerWithService(cfg, service, errorHandler)

        // Start bots с общим сервисом
        bots, wg, _ := startBotsWithService(ctx, cfg, service, errorHandler)

        waitForShutdown(bots, wg, adminServer, cancel)</span>
}

// initializeService создает общий сервис для всех компонентов
func initializeService(
        cfg *config.Config,
        db *database.DB,
        errorHandler *errors.ErrorHandler,
) (*core.BotService, error) <span class="cov0" title="0">{
        // Создаем сервис с Redis кэшем
        service, err := core.NewBotServiceWithRedis(db, cfg.RedisURL, cfg.RedisPassword, cfg.RedisDB, errorHandler)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create Redis cache, falling back to in-memory cache: %v", err)
                // Fallback на in-memory кэш если Redis недоступен
                service = core.NewBotService(db, errorHandler)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Redis cache initialized: %s", service.Cache.String())
        }</span>
        <span class="cov0" title="0">return service, nil</span>
}

// initializeTelegramBotWithService инициализирует Telegram бота с готовым сервисом.
func initializeTelegramBotWithService(
        service *core.BotService,
        cfg *config.Config,
        errorHandler *errors.ErrorHandler,
) (*telegram.TelegramBot, error) <span class="cov0" title="0">{

        // Создаем бота с Chat ID для уведомлений и username для проверки прав
        telegramBot, err := telegram.NewTelegramBotWithService(cfg.TelegramToken, service, cfg.Debug, cfg.AdminUsernames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Telegram bot: %w", err)
        }</span>

        // Передаем errorHandler в TelegramBot
        <span class="cov0" title="0">telegramBot.SetErrorHandler(errorHandler)

        // Устанавливаем Chat ID для уведомлений
        telegramBot.SetAdminChatIDs(cfg.AdminChatIDs)

        // Связываем бота с сервисом для отправки уведомлений о новых отзывах
        botService := telegramBot.GetService()
        if botService != nil </span><span class="cov0" title="0">{
                botService.SetFeedbackNotificationFunc(telegramBot.SendFeedbackNotification)
                log.Printf("Связал функцию уведомлений с сервисом отзывов")
        }</span>

        <span class="cov0" title="0">return telegramBot, nil</span>
}

// setupDatabase подключается к базе данных.
func setupDatabase(cfg *config.Config) *database.DB <span class="cov0" title="0">{
        db, err := database.NewDB(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Connected to database successfully")

        return db</span>
}

// setupErrorHandler создает систему обработки ошибок.
func setupErrorHandler() *errors.ErrorHandler <span class="cov0" title="0">{
        adminNotifier := errors.NewAdminNotifier([]int64{}, nil) // TODO: Добавить реальные Chat ID администраторов

        return errors.NewErrorHandler(adminNotifier)
}</span>

// setupGracefulShutdown настраивает graceful shutdown.
func setupGracefulShutdown() (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Received shutdown signal...")
                cancel()
        }</span>()

        <span class="cov0" title="0">return ctx, cancel</span>
}

// startAdminServerWithService запускает административный API сервер с общим сервисом
func startAdminServerWithService(cfg *config.Config, service *core.BotService, errorHandler *errors.ErrorHandler) *server.AdminServer <span class="cov0" title="0">{
        log.Printf("Admin API using shared service: %s", service.Cache.String())

        // Создаем handler для Telegram для статистики rate limiting
        telegramHandler := telegram.NewTelegramHandlerWithAdmins(
                nil, // bot API не нужен для admin API
                service,
                []int64{},  // пустой список admin chat IDs
                []string{}, // пустой список admin usernames
                errorHandler,
        )

        // Создаем и запускаем admin server
        adminPort := "8080" // можно вынести в конфиг
        webhookMode := cfg.TelegramMode == "webhook"
        adminServer := server.NewWithWebhook(adminPort, service, telegramHandler, webhookMode)

        go func() </span><span class="cov0" title="0">{
                if err := adminServer.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Admin server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">return adminServer</span>
}

// waitForShutdown ждет завершения работы ботов и admin сервера.
func waitForShutdown(bots []adapters.BotAdapter, wg *sync.WaitGroup, adminServer *server.AdminServer, cancel context.CancelFunc) <span class="cov0" title="0">{
        // Ждем завершения всех горутин
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(done)
        }</span>()

        // Ждем либо завершения работы, либо сигнала остановки
        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                log.Println("All bots stopped gracefully")</span>
        case &lt;-time.After(ForceShutdownTimeout):<span class="cov0" title="0">
                log.Println("Force shutdown")
                cancel()</span>
        }

        // Останавливаем admin сервер
        <span class="cov0" title="0">if adminServer != nil </span><span class="cov0" title="0">{
                ctx, cancelStop := context.WithTimeout(context.Background(), 5*time.Second)
                if err := adminServer.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error stopping admin server: %v", err)
                }</span>
                <span class="cov0" title="0">cancelStop()
                log.Println("Admin server stopped")</span>
        }

        // Останавливаем все боты
        <span class="cov0" title="0">ctx, cancelStop := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancelStop()

        for _, bot := range bots </span><span class="cov0" title="0">{
                if err := bot.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error stopping bot: %v", err)
                }</span>
        }

        // Останавливаем кэш-сервис только после остановки ботов
        // Используем общий сервис из любого бота
        <span class="cov0" title="0">for _, bot := range bots </span><span class="cov0" title="0">{
                if telegramBot, ok := bot.(*telegram.TelegramBot); ok </span><span class="cov0" title="0">{
                        service := telegramBot.GetService()
                        if service != nil </span><span class="cov0" title="0">{
                                service.StopCache()
                                log.Println("Cache service stopped")
                                break</span> // останавливаем только один раз для общего сервиса
                        }
                }
        }
}

// startBotsWithService запускает все боты с общим сервисом
func startBotsWithService(
        ctx context.Context,
        cfg *config.Config,
        service *core.BotService,
        errorHandler *errors.ErrorHandler,
) ([]adapters.BotAdapter, *sync.WaitGroup, *telegram.TelegramHandler) <span class="cov0" title="0">{
        var (
                wg   sync.WaitGroup
                bots []adapters.BotAdapter
        )

        // Telegram Bot
        if cfg.EnableTelegram &amp;&amp; cfg.TelegramToken != "" </span><span class="cov0" title="0">{
                telegramBot, err := initializeTelegramBotWithService(service, cfg, errorHandler)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to initialize Telegram bot: %v", err)
                }</span>

                // Создаем handler для Telegram для admin server
                <span class="cov0" title="0">telegramHandler := telegram.NewTelegramHandlerWithAdmins(
                        telegramBot.GetBotAPI(),
                        service,
                        cfg.AdminChatIDs,
                        cfg.AdminUsernames,
                        errorHandler,
                )

                // Запускаем бота
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        log.Printf("Starting Telegram bot...")
                        if err := telegramBot.Start(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Telegram bot error: %v", err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Telegram bot stopped")</span>
                }()

                <span class="cov0" title="0">bots = append(bots, telegramBot)
                return bots, &amp;wg, telegramHandler</span>
        }

        <span class="cov0" title="0">return bots, &amp;wg, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Language Exchange Bot Team",
            "url": "https://github.com/your-org/language-exchange-bot",
            "email": "support@language-exchange-bot.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/": {
            "get": {
                "description": "Returns the main navigation dashboard",
                "produces": [
                    "text/html"
                ],
                "tags": [
                    "navigation"
                ],
                "summary": "Get navigation page",
                "responses": {
                    "200": {
                        "description": "HTML page",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/cache/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve cache performance statistics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "monitoring"
                ],
                "summary": "Get cache statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/feedback/unprocessed": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve all unprocessed user feedback",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "feedback"
                ],
                "summary": "Get unprocessed feedback",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/feedback/{id}/process": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Mark feedback as processed with optional response",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "feedback"
                ],
                "summary": "Process feedback",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feedback ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Processing request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/rate-limits/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve rate limiting statistics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "monitoring"
                ],
                "summary": "Get rate limit statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve general bot statistics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "statistics"
                ],
                "summary": "Get general statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/users": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve paginated list of users",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get users list",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 50,
                        "description": "Number of users to return",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/users/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve user information by Telegram ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Telegram User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/webhook/remove": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Removes webhook configuration from Telegram bot",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "webhook"
                ],
                "summary": "Remove webhook",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/webhook/setup": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Configures webhook for Telegram bot",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "webhook"
                ],
                "summary": "Setup webhook",
                "parameters": [
                    {
                        "description": "Webhook setup parameters",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/webhook/status": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Returns current webhook configuration and status",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "webhook"
                ],
                "summary": "Get webhook status",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v2/metrics/performance": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Returns detailed performance and monitoring metrics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "metrics"
                ],
                "summary": "Get performance metrics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v2/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Returns comprehensive system statistics including performance metrics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "statistics"
                ],
                "summary": "Get enhanced statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v2/system/health": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Returns detailed health status of all system components",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Get system health",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/healthz": {
            "get": {
                "description": "Check if the service is healthy",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/readyz": {
            "get": {
                "description": "Check if the service is ready to serve requests",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Readiness check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/webhook/telegram/{token}": {
            "post": {
                "description": "Receives and processes webhook updates from Telegram",
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "webhook"
                ],
                "summary": "Handle Telegram webhook",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bot token",
                        "name": "token",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Telegram update JSON",
                        "name": "update",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.FriendshipPreferences": {
            "type": "object",
            "properties": {
                "activityType": {
                    "description": "movies, games, educational",
                    "type": "string"
                },
                "communicationFrequency": {
                    "description": "spontaneous, weekly, daily",
                    "type": "string"
                },
                "communicationStyle": {
                    "description": "text, voice_msg, meet_person",
                    "type": "string"
                }
            }
        },
        "models.TimeAvailability": {
            "type": "object",
            "properties": {
                "dayType": {
                    "description": "weekdays, weekends, any, specific",
                    "type": "string"
                },
                "specificDays": {
                    "description": "массив дней для specific",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "timeSlot": {
                    "description": "morning, day, evening, late",
                    "type": "string"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "friendshipPreferences": {
                    "description": "Предпочтения общения",
                    "allOf": [
                        {
                            "$ref": "#/definitions/models.FriendshipPreferences"
                        }
                    ]
                },
                "id": {
                    "type": "integer"
                },
                "interests": {
                    "description": "Не храним в БД, загружаем отдельно",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "interfaceLanguageCode": {
                    "type": "string"
                },
                "nativeLanguageCode": {
                    "type": "string"
                },
                "profileCompletionLevel": {
                    "type": "integer"
                },
                "state": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "targetLanguageCode": {
                    "type": "string"
                },
                "targetLanguageLevel": {
                    "type": "string"
                },
                "telegramId": {
                    "type": "integer"
                },
                "timeAvailability": {
                    "description": "Дополнительные поля для расширенного профиля",
                    "allOf": [
                        {
                            "$ref": "#/definitions/models.TimeAvailability"
                        }
                    ]
                },
                "updatedAt": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "description": "Admin API key for authentication",
            "type": "apiKey",
            "name": "X-Admin-Key",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "3.0.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Language Exchange Bot Admin API",
        Description:      "This is the administrative API for the Language Exchange Telegram Bot.\nIt provides endpoints for monitoring, user management, feedback processing, and system statistics.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package telegram provides Telegram Bot API integration and message handling.
package telegram

import (
        "context"
        "fmt"
        "log"
        "strings"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/database"
        "language-exchange-bot/internal/errors"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// ResolveUsernameToChatID - упрощенная функция валидации
// Username'ы теперь считываются только из .env файла.
func (tb *TelegramBot) ResolveUsernameToChatID(username string) (int64, error) <span class="cov0" title="0">{
        // Все username'ы теперь динамически читаются из конфигурации
        // Эта функция оставлена для совместимости, но не содержит хардкода
        log.Printf("Валидация username @%s через конфигурацию", username)

        return 0, nil // для совместимости с существующим кодом
}</span>

// TelegramBot represents a Telegram bot instance with message handling capabilities.
// The name includes "Telegram" prefix for clarity, even though it may cause stuttering with the package name.
type TelegramBot struct {
        api            *tgbotapi.BotAPI
        service        *core.BotService
        debug          bool
        adminChatIDs   []int64  // ID администраторов для уведомлений (resolved)
        adminUsernames []string // Usernames администраторов (дополнительно храним для логов)
        errorHandler   *errors.ErrorHandler
        handler        *TelegramHandler // handler для обработки сообщений
}

// NewTelegramBot creates a new Telegram bot instance with the provided configuration.
func NewTelegramBot(token string, db *database.DB, debug bool, adminChatIDs []int64) (*TelegramBot, error) <span class="cov0" title="0">{
        bot, err := tgbotapi.NewBotAPI(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create telegram bot: %w", err)
        }</span>

        <span class="cov0" title="0">bot.Debug = debug
        service := core.NewBotService(db, nil)

        return &amp;TelegramBot{
                api:            bot,
                service:        service,
                debug:          debug,
                adminChatIDs:   adminChatIDs,
                adminUsernames: make([]string, 0), // инициализируем пустой если нужно
                handler:        nil,               // будет инициализирован при запуске
        }, nil</span>
}

// NewTelegramBotWithUsernames создает бота с поддержкой usernames администраторов.
func NewTelegramBotWithUsernames(
        token string,
        db *database.DB,
        debug bool,
        adminUsernames []string,
) (*TelegramBot, error) <span class="cov0" title="0">{
        bot, err := tgbotapi.NewBotAPI(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create telegram bot: %w", err)
        }</span>

        <span class="cov0" title="0">bot.Debug = debug

        tgBot := &amp;TelegramBot{
                api:            bot,
                service:        core.NewBotService(db, nil),
                debug:          debug,
                adminChatIDs:   make([]int64, 0), // Будет установлен позже через SetAdminChatIDs
                adminUsernames: make([]string, 0),
                handler:        nil, // будет инициализирован при запуске
        }

        // Обрабатываем usernames для проверки прав
        for _, username := range adminUsernames </span><span class="cov0" title="0">{
                username = strings.TrimSpace(username)
                if username == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Убираем @ если есть
                <span class="cov0" title="0">username = strings.TrimPrefix(username, "@")

                tgBot.adminUsernames = append(tgBot.adminUsernames, username)
                log.Printf("Добавлен администратор для проверки прав: @%s", username)</span>
        }

        <span class="cov0" title="0">if len(tgBot.adminUsernames) == 0 </span><span class="cov0" title="0">{
                log.Println("Предупреждение: не настроено ни одного администратора для проверки прав")
        }</span>

        <span class="cov0" title="0">log.Printf("Бот настроен с %d администраторами для проверки прав", len(tgBot.adminUsernames))

        return tgBot, nil</span>
}

// SendFeedbackNotification отправляет уведомление администраторам о новом отзыве.
func (tb *TelegramBot) SendFeedbackNotification(feedbackData map[string]interface{}) error <span class="cov0" title="0">{
        log.Printf("Отправляем уведомление о новом отзыве администраторам...")
        log.Printf("Администраторы по ID: %v", tb.adminChatIDs)
        log.Printf("Администраторы по username: %v", tb.adminUsernames)
        // Формируем сообщение для администраторов
        adminMsg := fmt.Sprintf(`
📝 Новый отзыв от пользователя:

👤 Имя: %s
📱 Telegram ID: %d

%s

📝 Отзыв:
%s
`,
                feedbackData["first_name"].(string),
                feedbackData["telegram_id"].(int64),
                func() string </span><span class="cov0" title="0">{
                        if username, ok := feedbackData["username"].(*string); ok &amp;&amp; username != nil </span><span class="cov0" title="0">{
                                return "👤 Username: @" + *username
                        }</span>

                        <span class="cov0" title="0">return "👤 Username: отсутствует"</span>
                }(),
                feedbackData["feedback_text"].(string),
        )

        // Добавляем контактную информацию, если есть
        <span class="cov0" title="0">if contactInfo, ok := feedbackData["contact_info"].(*string); ok &amp;&amp; contactInfo != nil </span><span class="cov0" title="0">{
                adminMsg += "\n📞 Контакты: " + *contactInfo
        }</span>

        // Отправляем сообщение всем администраторам по ID
        <span class="cov0" title="0">log.Printf("Отправляем уведомления %d администраторам по ID", len(tb.adminChatIDs))

        for _, adminID := range tb.adminChatIDs </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(adminID, adminMsg)
                if _, err := tb.api.Send(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Ошибка отправки уведомления администратору %d: %v", adminID, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Уведомление отправлено администратору %d", adminID)
                }</span>
        }

        // Username администраторы используются только для проверки прав, не для уведомлений
        <span class="cov0" title="0">log.Printf("Username администраторы (%d) используются только для проверки прав", len(tb.adminUsernames))

        totalAdmins := len(tb.adminChatIDs)
        log.Printf("Отправлено уведомление %d администраторам по Chat ID", totalAdmins)

        return nil</span>
}

// GetService возвращает сервис бота для внешнего доступа.
func (tb *TelegramBot) GetService() *core.BotService <span class="cov0" title="0">{
        return tb.service
}</span>

// Start begins the Telegram bot message processing loop.
func (tb *TelegramBot) Start(ctx context.Context) error <span class="cov0" title="0">{
        log.Printf("Authorized on account %s", tb.api.Self.UserName)

        u := tgbotapi.NewUpdate(0)
        u.Timeout = 60

        updates := tb.api.GetUpdatesChan(u)
        // Передаем usernames администраторов в обработчик
        tb.handler = NewTelegramHandlerWithAdmins(tb.api, tb.service, tb.adminChatIDs, tb.adminUsernames, tb.errorHandler)
        handler := tb.handler

        for </span><span class="cov0" title="0">{
                select </span>{
                case update := &lt;-updates:<span class="cov0" title="0">
                        go func(upd tgbotapi.Update) </span><span class="cov0" title="0">{
                                if err := handler.HandleUpdate(upd); err != nil </span><span class="cov0" title="0">{
                                        // Используем новую систему обработки ошибок
                                        if tb.errorHandler != nil </span><span class="cov0" title="0">{
                                                if handlerErr := tb.errorHandler.HandleTelegramError(err, 0, 0, "HandleUpdate"); handlerErr != nil </span><span class="cov0" title="0">{
                                                        log.Printf("Error in error handler: %v", handlerErr)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                log.Printf("Error handling update: %v", err)
                                        }</span>
                                }
                        }(update)
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("Stopping Telegram bot...")
                        tb.api.StopReceivingUpdates()

                        return nil</span>
                }
        }
}

func (tb *TelegramBot) Stop(ctx context.Context) error <span class="cov0" title="0">{
        // StopReceivingUpdates уже вызван в методе Start() при отмене контекста
        // Здесь только останавливаем handler и другие компоненты

        // Останавливаем handler и все его компоненты
        if tb.handler != nil </span><span class="cov0" title="0">{
                tb.handler.Stop()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPlatformName returns the platform name for the bot.
func (tb *TelegramBot) GetPlatformName() string <span class="cov0" title="0">{
        return "telegram"
}</span>

// SetAdminChatIDs устанавливает Chat ID администраторов для уведомлений.
func (tb *TelegramBot) SetAdminChatIDs(chatIDs []int64) <span class="cov0" title="0">{
        tb.adminChatIDs = chatIDs
        log.Printf("Установлены Chat ID администраторов для уведомлений: %v", chatIDs)
}</span>

// GetAdminCount возвращает количество настроенных администраторов.
func (tb *TelegramBot) GetAdminCount() int <span class="cov0" title="0">{
        // Возвращаем максимум из двух списков, так как это одни и те же люди
        chatCount := len(tb.adminChatIDs)
        usernameCount := len(tb.adminUsernames)

        if chatCount &gt; usernameCount </span><span class="cov0" title="0">{
                return chatCount
        }</span>

        <span class="cov0" title="0">return usernameCount</span>
}

// NewTelegramBotWithService создает бота с готовым сервисом (для Redis кэша).
func NewTelegramBotWithService(
        token string,
        service *core.BotService,
        debug bool,
        adminUsernames []string,
) (*TelegramBot, error) <span class="cov0" title="0">{
        bot, err := tgbotapi.NewBotAPI(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create telegram bot: %w", err)
        }</span>

        <span class="cov0" title="0">bot.Debug = debug

        tgBot := &amp;TelegramBot{
                api:            bot,
                service:        service,
                debug:          debug,
                adminChatIDs:   make([]int64, 0), // Будет установлен позже через SetAdminChatIDs
                adminUsernames: make([]string, 0),
                handler:        nil, // будет инициализирован при запуске
        }

        // Обрабатываем usernames для проверки прав
        for _, username := range adminUsernames </span><span class="cov0" title="0">{
                username = strings.TrimSpace(username)
                if username == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Убираем @ если есть
                <span class="cov0" title="0">username = strings.TrimPrefix(username, "@")

                tgBot.adminUsernames = append(tgBot.adminUsernames, username)
                log.Printf("Добавлен username администратора: @%s", username)</span>
        }

        <span class="cov0" title="0">return tgBot, nil</span>
}

// SetErrorHandler устанавливает обработчик ошибок.
func (tb *TelegramBot) SetErrorHandler(errorHandler *errors.ErrorHandler) <span class="cov0" title="0">{
        tb.errorHandler = errorHandler

        log.Printf("Error handler установлен для TelegramBot")
}</span>

// GetBotAPI возвращает BotAPI бота
func (tb *TelegramBot) GetBotAPI() *tgbotapi.BotAPI <span class="cov0" title="0">{
        return tb.api
}</span>

// SetupWebhook настраивает webhook для бота в Telegram
func (tb *TelegramBot) SetupWebhook(webhookURL string) error <span class="cov0" title="0">{
        if webhookURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("webhook URL cannot be empty")
        }</span>

        // Создаем конфигурацию webhook
        <span class="cov0" title="0">webhookConfig, err := tgbotapi.NewWebhook(webhookURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook config: %w", err)
        }</span>

        // Настраиваем webhook в Telegram
        <span class="cov0" title="0">_, err = tb.api.Request(webhookConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set webhook: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Webhook successfully configured: %s", webhookURL)
        return nil</span>
}

// RemoveWebhook удаляет webhook для бота
func (tb *TelegramBot) RemoveWebhook() error <span class="cov0" title="0">{
        webhookConfig, err := tgbotapi.NewWebhook("")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook config: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tb.api.Request(webhookConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove webhook: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Webhook successfully removed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package telegram

import (
        "log"
        "regexp"

        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// CallbackHandler определяет функцию-обработчик callback'а
type CallbackHandler func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error

// CallbackRoute представляет маршрут для callback'а
type CallbackRoute struct {
        Pattern *regexp.Regexp
        Handler CallbackHandler
}

// CallbackRouter управляет маршрутизацией callback'ов
type CallbackRouter struct {
        routes []CallbackRoute
}

// NewCallbackRouter создает новый роутер
func NewCallbackRouter() *CallbackRouter <span class="cov8" title="1">{
        return &amp;CallbackRouter{
                routes: make([]CallbackRoute, 0),
        }
}</span>

// Register регистрирует новый маршрут с регулярным выражением
func (r *CallbackRouter) Register(pattern string, handler CallbackHandler) error <span class="cov8" title="1">{
        regex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">r.routes = append(r.routes, CallbackRoute{
                Pattern: regex,
                Handler: handler,
        })

        return nil</span>
}

// RegisterSimple регистрирует простой маршрут для точного совпадения
func (r *CallbackRouter) RegisterSimple(pattern string, handler CallbackHandler) <span class="cov8" title="1">{
        r.routes = append(r.routes, CallbackRoute{
                Pattern: regexp.MustCompile("^" + regexp.QuoteMeta(pattern) + "$"),
                Handler: handler,
        })
}</span>

// RegisterPrefix регистрирует маршрут для префикса с извлечением параметра
func (r *CallbackRouter) RegisterPrefix(prefix string, handler CallbackHandler) <span class="cov8" title="1">{
        pattern := "^" + regexp.QuoteMeta(prefix) + "(.+)$"
        r.routes = append(r.routes, CallbackRoute{
                Pattern: regexp.MustCompile(pattern),
                Handler: handler,
        })
}</span>

// Handle обрабатывает callback, находя подходящий маршрут
func (r *CallbackRouter) Handle(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov8" title="1">{
        data := callback.Data

        for _, route := range r.routes </span><span class="cov8" title="1">{
                matches := route.Pattern.FindStringSubmatch(data)
                if matches != nil </span><span class="cov8" title="1">{
                        // Извлекаем параметры из совпадений
                        params := make(map[string]string)

                        // Первый элемент - полное совпадение, остальные - группы
                        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                                // Для префиксных маршрутов сохраняем параметр
                                params["param"] = matches[1]
                        }</span>

                        <span class="cov8" title="1">return route.Handler(callback, user, params)</span>
                }
        }

        <span class="cov8" title="1">log.Printf("DEBUG: No route matched for callback data: '%s'", data)
        return nil</span> // Не найден подходящий обработчик
}

// SetupIsolatedRoutes настраивает маршруты для изолированного редактора интересов
func (r *CallbackRouter) SetupIsolatedRoutes(handler *TelegramHandler) error <span class="cov0" title="0">{
        // Простые маршруты для точного совпадения
        r.RegisterSimple("isolated_edit_start", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedEditStart(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_main_menu", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedMainMenu(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_edit_categories", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedEditCategories(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_edit_primary", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedEditPrimary(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_preview_changes", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedPreviewChanges(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_save_changes", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedSaveChanges(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_cancel_edit", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedCancelEdit(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_undo_last", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedUndoLast(callback, user)
        }</span>)

        <span class="cov0" title="0">r.RegisterSimple("isolated_show_stats", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                return handler.HandleIsolatedShowStats(callback, user)
        }</span>)

        // Префиксные маршруты с параметрами
        <span class="cov0" title="0">r.RegisterPrefix("isolated_edit_category_", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                categoryKey := params["param"]
                return handler.HandleIsolatedEditCategory(callback, user, categoryKey)
        }</span>)

        <span class="cov0" title="0">r.RegisterPrefix("isolated_toggle_interest_", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                interestIDStr := params["param"]
                return handler.HandleIsolatedToggleInterest(callback, user, interestIDStr)
        }</span>)

        <span class="cov0" title="0">r.RegisterPrefix("isolated_toggle_primary_", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                interestIDStr := params["param"]
                return handler.HandleIsolatedTogglePrimary(callback, user, interestIDStr)
        }</span>)

        <span class="cov0" title="0">r.RegisterPrefix("isolated_select_all_", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                categoryKey := params["param"]
                return handler.HandleIsolatedMassSelect(callback, user, categoryKey)
        }</span>)

        <span class="cov0" title="0">r.RegisterPrefix("isolated_clear_all_", func(callback *tgbotapi.CallbackQuery, user *models.User, params map[string]string) error </span><span class="cov0" title="0">{
                categoryKey := params["param"]
                return handler.HandleIsolatedMassClear(callback, user, categoryKey)
        }</span>)

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package telegram

import (
        "fmt"
        "log"
        "strconv"
        "strings"

        "language-exchange-bot/internal/adapters/telegram/handlers"
        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для работы с коллбэками и массивами.

// TelegramHandler handles Telegram bot message and callback processing.
// The name includes "Telegram" prefix for clarity, even though it may cause stuttering with the package name.
type TelegramHandler struct {
        bot                    *tgbotapi.BotAPI
        service                *core.BotService
        adminChatIDs           []int64  // Chat ID администраторов
        adminUsernames         []string // Usernames администраторов для проверки доступа
        keyboardBuilder        *handlers.KeyboardBuilder
        menuHandler            *handlers.MenuHandler
        profileHandler         *handlers.ProfileHandlerImpl
        feedbackHandler        *handlers.FeedbackHandlerImpl
        languageHandler        *handlers.LanguageHandlerImpl
        interestHandler        *handlers.NewInterestHandlerImpl
        profileInterestHandler *handlers.ProfileInterestHandler
        isolatedInterestEditor *handlers.IsolatedInterestEditor
        adminHandler           *handlers.AdminHandlerImpl
        utilityHandler         *handlers.UtilityHandlerImpl
        availabilityHandler    *handlers.AvailabilityHandlerImpl
        errorHandler           *errors.ErrorHandler
        isolatedRouter         *CallbackRouter // Роутер для изолированных callback'ов
        rateLimiter            *RateLimiter    // Rate limiter для защиты от спама
        messageFactory         *handlers.MessageFactory
}

// NewTelegramHandler создает новый экземпляр TelegramHandler с базовой конфигурацией.
func NewTelegramHandler(
        bot *tgbotapi.BotAPI,
        service *core.BotService,
        adminChatIDs []int64,
        errorHandler *errors.ErrorHandler,
) *TelegramHandler <span class="cov0" title="0">{
        keyboardBuilder := handlers.NewKeyboardBuilder(service)
        messageFactory := handlers.NewMessageFactory(bot, errorHandler, service.LoggingService)

        // Создаем общий BaseHandler
        baseHandler := handlers.NewBaseHandler(
                bot,
                service,
                keyboardBuilder,
                errorHandler,
                messageFactory,
        )

        menuHandler := handlers.NewMenuHandler(baseHandler)
        profileHandler := handlers.NewProfileHandler(baseHandler)
        feedbackHandler := handlers.NewFeedbackHandler(
                baseHandler,
                adminChatIDs,
                make([]string, 0),
        )
        languageHandler := handlers.NewLanguageHandler(baseHandler)

        var interestService *core.InterestService
        if service.DB != nil </span><span class="cov0" title="0">{
                interestService = core.NewInterestService(service.DB.GetConnection())
        }</span> else<span class="cov0" title="0"> {
                interestService = nil // Для тестов без DB
        }</span>

        <span class="cov0" title="0">interestHandler := handlers.NewNewInterestHandler(baseHandler, interestService)
        profileInterestHandler := handlers.NewProfileInterestHandler(
                service,
                interestService,
                bot,
                keyboardBuilder,
                errorHandler,
        )
        isolatedInterestEditor := handlers.NewIsolatedInterestEditor(
                service,
                interestService,
                bot,
                keyboardBuilder,
                errorHandler,
                service.Cache,
        )
        adminHandler := handlers.NewAdminHandler(baseHandler, adminChatIDs, make([]string, 0))
        utilityHandler := handlers.NewUtilityHandler(baseHandler)
        availabilityHandler := handlers.NewAvailabilityHandler(baseHandler)

        // Создаем rate limiter для защиты от спама
        rateLimiter := NewRateLimiter(DefaultRateLimitConfig())

        // Создаем и настраиваем роутер для изолированных callback'ов
        isolatedRouter := NewCallbackRouter()
        handler := &amp;TelegramHandler{
                bot:                    bot,
                service:                service,
                adminChatIDs:           adminChatIDs,
                adminUsernames:         make([]string, 0),
                keyboardBuilder:        keyboardBuilder,
                menuHandler:            menuHandler,
                profileHandler:         profileHandler,
                feedbackHandler:        feedbackHandler,
                languageHandler:        languageHandler,
                interestHandler:        interestHandler,
                profileInterestHandler: profileInterestHandler,
                isolatedInterestEditor: isolatedInterestEditor,
                adminHandler:           adminHandler,
                utilityHandler:         utilityHandler,
                availabilityHandler:    availabilityHandler,
                errorHandler:           errorHandler,
                isolatedRouter:         isolatedRouter,
                rateLimiter:            rateLimiter,
                messageFactory:         messageFactory,
        }

        // Настраиваем маршруты для изолированных callback'ов
        if err := isolatedRouter.SetupIsolatedRoutes(handler); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to setup isolated routes: %v", err))</span>
        }

        <span class="cov0" title="0">return handler</span>
}

// NewTelegramHandlerWithAdmins создает новый экземпляр TelegramHandler с полной конфигурацией администраторов.
func NewTelegramHandlerWithAdmins(
        bot *tgbotapi.BotAPI,
        service *core.BotService,
        adminChatIDs []int64,
        adminUsernames []string,
        errorHandler *errors.ErrorHandler,
) *TelegramHandler <span class="cov0" title="0">{
        keyboardBuilder := handlers.NewKeyboardBuilder(service)
        messageFactory := handlers.NewMessageFactory(bot, errorHandler, service.LoggingService)

        // Создаем общий BaseHandler
        baseHandler := handlers.NewBaseHandler(
                bot,
                service,
                keyboardBuilder,
                errorHandler,
                messageFactory,
        )

        menuHandler := handlers.NewMenuHandler(baseHandler)
        profileHandler := handlers.NewProfileHandler(baseHandler)
        feedbackHandler := handlers.NewFeedbackHandler(
                baseHandler,
                adminChatIDs,
                adminUsernames,
        )
        languageHandler := handlers.NewLanguageHandler(baseHandler)
        interestService := core.NewInterestService(service.DB.GetConnection())
        interestHandler := handlers.NewNewInterestHandler(baseHandler, interestService)
        profileInterestHandler := handlers.NewProfileInterestHandler(
                service,
                interestService,
                bot,
                keyboardBuilder,
                errorHandler,
        )
        isolatedInterestEditor := handlers.NewIsolatedInterestEditor(
                service,
                interestService,
                bot,
                keyboardBuilder,
                errorHandler,
                service.Cache,
        )
        adminHandler := handlers.NewAdminHandler(baseHandler, adminChatIDs, adminUsernames)
        utilityHandler := handlers.NewUtilityHandler(baseHandler)
        availabilityHandler := handlers.NewAvailabilityHandler(baseHandler)

        // Создаем rate limiter для защиты от спама
        rateLimiter := NewRateLimiter(DefaultRateLimitConfig())

        // Создаем и настраиваем роутер для изолированных callback'ов
        isolatedRouter := NewCallbackRouter()
        handler := &amp;TelegramHandler{
                bot:                    bot,
                service:                service,
                adminChatIDs:           adminChatIDs,
                adminUsernames:         adminUsernames,
                keyboardBuilder:        keyboardBuilder,
                menuHandler:            menuHandler,
                profileHandler:         profileHandler,
                feedbackHandler:        feedbackHandler,
                languageHandler:        languageHandler,
                interestHandler:        interestHandler,
                profileInterestHandler: profileInterestHandler,
                isolatedInterestEditor: isolatedInterestEditor,
                adminHandler:           adminHandler,
                utilityHandler:         utilityHandler,
                availabilityHandler:    availabilityHandler,
                errorHandler:           errorHandler,
                isolatedRouter:         isolatedRouter,
                rateLimiter:            rateLimiter,
                messageFactory:         messageFactory,
        }

        // Настраиваем маршруты для изолированных callback'ов
        if err := isolatedRouter.SetupIsolatedRoutes(handler); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to setup isolated routes: %v", err))</span>
        }

        <span class="cov0" title="0">return handler</span>
}

// HandleUpdate обрабатывает входящие обновления от Telegram API.
func (h *TelegramHandler) HandleUpdate(update tgbotapi.Update) error <span class="cov8" title="1">{
        // Получаем ID пользователя
        var userID int64
        if update.Message != nil </span><span class="cov8" title="1">{
                userID = update.Message.From.ID
        }</span> else<span class="cov8" title="1"> if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                userID = update.CallbackQuery.From.ID
        }</span> else<span class="cov0" title="0"> {
                // Неизвестный тип обновления, пропускаем
                return nil
        }</span>

        // Проверяем rate limit
        <span class="cov8" title="1">if err := h.rateLimiter.CheckRateLimit(userID); err != nil </span><span class="cov0" title="0">{
                // Отправляем сообщение о превышении лимита
                h.sendRateLimitMessage(userID, err)
                return nil // Не возвращаем ошибку, чтобы не логировать её как системную
        }</span>

        <span class="cov8" title="1">if update.Message != nil </span><span class="cov8" title="1">{
                return h.handleMessage(update.Message)
        }</span>

        <span class="cov8" title="1">if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                return h.handleCallbackQuery(update.CallbackQuery)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleMessage обрабатывает входящие текстовые сообщения.
func (h *TelegramHandler) handleMessage(message *tgbotapi.Message) error <span class="cov8" title="1">{
        if h.service == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("service not initialized")
        }</span>

        <span class="cov0" title="0">user, err := h.service.HandleUserRegistration(
                message.From.ID,
                message.From.UserName,
                message.From.FirstName,
                message.From.LanguageCode,
        )
        if err != nil </span><span class="cov0" title="0">{
                // Используем новую систему обработки ошибок
                if h.errorHandler != nil </span><span class="cov0" title="0">{
                        userID := int64(0)
                        if user != nil </span><span class="cov0" title="0">{
                                userID = int64(user.ID)
                        }</span>

                        <span class="cov0" title="0">return h.errorHandler.HandleDatabaseError(
                                err,
                                userID,
                                message.Chat.ID,
                                "HandleUserRegistration",
                        )</span>
                }
                // Fallback к простому логированию если errorHandler не инициализирован
                <span class="cov0" title="0">log.Printf("Database error in HandleUserRegistration: %v", err)

                return nil</span>
        }

        <span class="cov0" title="0">if message.IsCommand() </span><span class="cov0" title="0">{
                return h.handleCommand(message, user)
        }</span>

        <span class="cov0" title="0">return h.handleState(message, user)</span>
}

// handleCommand обрабатывает команды пользователя (начинающиеся с /).
func (h *TelegramHandler) handleCommand(message *tgbotapi.Message, user *models.User) error <span class="cov8" title="1">{
        if h.service == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("service not initialized")
        }</span>

        <span class="cov0" title="0">switch message.Command() </span>{
        case "start":<span class="cov0" title="0">
                return h.menuHandler.HandleStartCommand(message, user)</span>
        case "status":<span class="cov0" title="0">
                return h.menuHandler.HandleStatusCommand(message, user)</span>
        case "reset":<span class="cov0" title="0">
                return h.menuHandler.HandleResetCommand(message, user)</span>
        case "language":<span class="cov0" title="0">
                return h.menuHandler.HandleLanguageCommand(message, user)</span>
        case "profile":<span class="cov0" title="0">
                return h.profileHandler.HandleProfileCommand(message, user)</span>
        case "feedback":<span class="cov0" title="0">
                return h.feedbackHandler.HandleFeedbackCommand(
                        message,
                        user,
                )</span>
        case "feedbacks":<span class="cov0" title="0">
                return h.feedbackHandler.HandleFeedbacksCommand(
                        message,
                        user,
                )</span>
        default:<span class="cov0" title="0">
                log.Printf("Unknown command: %s", message.Command())

                return h.utilityHandler.SendMessage(
                        message.Chat.ID,
                        h.service.Localizer.Get(user.InterfaceLanguageCode, "unknown_command"),
                )</span>
        }
}

// handleState обрабатывает сообщения в зависимости от текущего состояния пользователя.
func (h *TelegramHandler) handleState(message *tgbotapi.Message, user *models.User) error <span class="cov8" title="1">{
        if h.service == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("service not initialized")
        }</span>

        <span class="cov0" title="0">switch user.State </span>{
        case models.StateWaitingLanguage,
                models.StateWaitingInterests,
                models.StateWaitingTime,
                models.StateWaitingTimeAvailability,
                models.StateWaitingFriendshipPreferences:<span class="cov0" title="0">
                return h.utilityHandler.SendMessage(
                        message.Chat.ID,
                        h.service.Localizer.Get(user.InterfaceLanguageCode, "use_menu_above"),
                )</span>
        case models.StateWaitingFeedback:<span class="cov0" title="0">
                return h.feedbackHandler.HandleFeedbackMessage(message, user)</span>
        case models.StateWaitingFeedbackContact:<span class="cov0" title="0">
                return h.feedbackHandler.HandleFeedbackContactMessage(message, user)</span>
        default:<span class="cov0" title="0">
                // Игнорируем текстовые сообщения, если пользователь не в специальном состоянии
                // Пользователь должен использовать кнопки меню
                return nil</span>
        }
}

// handleCallbackQuery обрабатывает нажатия на inline-кнопки.
func (h *TelegramHandler) handleCallbackQuery(callback *tgbotapi.CallbackQuery) error <span class="cov8" title="1">{
        if h.service == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("service not initialized")
        }</span>

        <span class="cov0" title="0">log.Printf("DEBUG: handleCallbackQuery called with data: '%s' from user %d", callback.Data, callback.From.ID)

        user, err := h.service.HandleUserRegistration(
                callback.From.ID,
                callback.From.UserName,
                callback.From.FirstName,
                callback.From.LanguageCode,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Failed to handle user registration for user %d: %v", callback.From.ID, err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("DEBUG: User found: ID=%d, State=%s, InterfaceLang=%s", user.ID, user.State, user.InterfaceLanguageCode)

        data := callback.Data
        _, _ = h.bot.Request(tgbotapi.NewCallback(callback.ID, ""))

        // Разделяем обработку callback'ов по категориям для уменьшения сложности
        if err := h.handleLanguageCallbacks(callback, user, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: handleLanguageCallbacks returned error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := h.handleInterestCallbacks(callback, user, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: handleInterestCallbacks returned error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := h.handleProfileCallbacks(
                callback,
                user,
                data,
        ); err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: handleProfileCallbacks returned error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := h.handleMenuCallbacks(
                callback,
                user,
                data,
        ); err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: handleMenuCallbacks returned error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := h.handleFeedbackCallbacks(callback, user, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: handleFeedbackCallbacks returned error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := h.handleAvailabilityCallbacks(callback, user, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: handleAvailabilityCallbacks returned error: %v", err)
                return err
        }</span>

        // Если callback не был обработан ни одним обработчиком, просто игнорируем
        <span class="cov0" title="0">log.Printf("DEBUG: No handler processed callback data: '%s'", data)
        return nil</span>
}

// isAdmin проверяет, является ли пользователь администратором
func (h *TelegramHandler) isAdmin(userID int64, username string) bool <span class="cov8" title="1">{
        // Проверяем по Chat ID
        for _, adminID := range h.adminChatIDs </span><span class="cov8" title="1">{
                if userID == adminID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Проверяем по username
        <span class="cov8" title="1">if username != "" </span><span class="cov8" title="1">{
                for _, adminUsername := range h.adminUsernames </span><span class="cov8" title="1">{
                        if username == adminUsername </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// === ОБРАБОТЧИКИ ВИДОВ ОТЗЫВОВ ===

// вспомогательная функция для сохранения состояния навигации отзывов

// === ОБРАБОТЧИКИ КОНТРОЛЯ ОТЗЫВОВ ===

// === НОВЫЕ МЕТОДЫ ДЛЯ СНИЖЕНИЯ ЦИКЛОМАТИЧЕСКОЙ СЛОЖНОСТИ ===

// handleLanguageCallbacks обрабатывает callback'и связанные с языками.
func (h *TelegramHandler) handleLanguageCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        // Обработка выбора языков
        if strings.HasPrefix(data, "lang_") </span><span class="cov0" title="0">{
                return h.handleLanguageSelection(
                        callback,
                        user,
                        data,
                )
        }</span>

        // Обработка уровней языка
        <span class="cov0" title="0">if strings.HasPrefix(data, "level_") </span><span class="cov0" title="0">{
                levelCode := strings.TrimPrefix(data, "level_")

                return h.languageHandler.HandleLanguageLevelSelection(callback, user, levelCode)
        }</span>

        // Обработка редактирования
        <span class="cov0" title="0">if strings.HasPrefix(data, "edit_") </span><span class="cov0" title="0">{
                return h.handleLanguageEditing(
                        callback,
                        user,
                        data,
                )
        }</span>

        // Обработка специальных команд
        <span class="cov0" title="0">return h.handleLanguageSpecialCommands(
                callback,
                user,
                data,
        )</span>
}

func (h *TelegramHandler) handleLanguageSelection(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(data, "lang_native_"):<span class="cov0" title="0">
                return h.languageHandler.HandleNativeLanguageCallback(callback, user)</span>
        case strings.HasPrefix(data, "lang_target_"):<span class="cov0" title="0">
                return h.languageHandler.HandleTargetLanguageCallback(callback, user)</span>
        case strings.HasPrefix(data, "lang_interface_"):<span class="cov0" title="0">
                langCode := strings.TrimPrefix(data, "lang_interface_")

                return h.languageHandler.HandleInterfaceLanguageSelection(callback, user, langCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *TelegramHandler) handleLanguageEditing(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(data, "edit_level_"):<span class="cov0" title="0">
                levelCode := strings.TrimPrefix(data, "edit_level_")

                return h.profileHandler.HandleEditLevelSelection(
                        callback,
                        user,
                        levelCode,
                )</span>
        case strings.HasPrefix(data, "lang_edit_native_"):<span class="cov0" title="0">
                return h.profileHandler.HandleEditNativeLanguage(callback, user)</span>
        case strings.HasPrefix(data, "lang_edit_target_"):<span class="cov0" title="0">
                return h.profileHandler.HandleEditTargetLanguage(callback, user)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *TelegramHandler) handleLanguageSpecialCommands(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        switch data </span>{
        case "back_to_language_level":<span class="cov0" title="0">
                return h.languageHandler.HandleBackToLanguageLevel(
                        callback,
                        user,
                )</span>
        case "languages_continue_filling":<span class="cov0" title="0">
                return h.languageHandler.HandleLanguagesContinueFilling(callback, user)</span>
        case "languages_reselect":<span class="cov0" title="0">
                return h.languageHandler.HandleLanguagesReselect(
                        callback,
                        user,
                )</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleInterestCallbacks обрабатывает callback'и связанные с интересами.
func (h *TelegramHandler) handleInterestCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        log.Printf("DEBUG: handleInterestCallbacks called with data: '%s' for user %d", data, user.ID)
        switch </span>{
        case data == "back_to_categories":<span class="cov0" title="0">
                return h.interestHandler.HandleBackToCategories(callback, user)</span>
        case data == "interests_continue":<span class="cov0" title="0">
                return h.interestHandler.HandleInterestsContinue(
                        callback,
                        user,
                )</span>
        case strings.HasPrefix(data, "interest_category_"):<span class="cov0" title="0">
                categoryKey := strings.TrimPrefix(data, "interest_category_")

                return h.interestHandler.HandleInterestCategorySelection(callback, user, categoryKey)</span>
        case strings.HasPrefix(data, "interest_select_"):<span class="cov0" title="0">
                interestID := strings.TrimPrefix(data, "interest_select_")

                return h.interestHandler.HandleInterestSelection(
                        callback,
                        user,
                        interestID,
                )</span>
        case strings.HasPrefix(data, "primary_interest_"):<span class="cov0" title="0">
                interestID := strings.TrimPrefix(data, "primary_interest_")

                return h.interestHandler.HandlePrimaryInterestSelection(callback, user, interestID)</span>
        case data == "primary_interests_continue":<span class="cov0" title="0">
                return h.interestHandler.HandlePrimaryInterestsContinue(callback, user)</span>
        case data == "back_to_interests":<span class="cov0" title="0">
                return h.interestHandler.HandleBackToInterests(callback, user)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleProfileCallbacks обрабатывает callback'и связанные с профилем.
func (h *TelegramHandler) handleProfileCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        // Обработка изолированного редактирования интересов
        if strings.HasPrefix(data, "isolated_") </span><span class="cov0" title="0">{
                return h.handleIsolatedCallbacks(callback, user, data)
        }</span>

        // Обработка редактирования интересов (только для совместимости с существующими сессиями)
        <span class="cov0" title="0">if strings.HasPrefix(data, "edit_interest") || data == "save_interest_edits" </span><span class="cov0" title="0">{
                return h.handleProfileInterestEditing(
                        callback,
                        user,
                        data,
                )
        }</span>

        // Обработка команд профиля
        <span class="cov0" title="0">if strings.HasPrefix(data, "profile_") ||
                strings.HasPrefix(data, "edit_") ||
                data == "back_to_previous_step" ||
                data == "continue_to_availability" </span><span class="cov0" title="0">{
                return h.handleProfileCommands(
                        callback,
                        user,
                        data,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *TelegramHandler) handleProfileInterestEditing(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        log.Printf("DEBUG: handleProfileInterestEditing called with data: '%s' for user %d", data, user.ID)

        switch </span>{
        case strings.HasPrefix(data, "edit_interest_category_"):<span class="cov0" title="0">
                categoryKey := strings.TrimPrefix(data, "edit_interest_category_")

                return h.profileInterestHandler.HandleEditInterestCategoryFromProfile(callback, user, categoryKey)</span>
        case strings.HasPrefix(data, "edit_interest_select_"):<span class="cov0" title="0">
                interestID := strings.TrimPrefix(data, "edit_interest_select_")

                return h.profileInterestHandler.HandleEditInterestSelectionFromProfile(callback, user, interestID)</span>
        case data == "edit_primary_interests":<span class="cov0" title="0">
                return h.profileInterestHandler.HandleEditPrimaryInterestsFromProfile(callback, user)</span>
        case strings.HasPrefix(data, "edit_primary_interest_"):<span class="cov0" title="0">
                interestID := strings.TrimPrefix(data, "edit_primary_interest_")

                return h.profileInterestHandler.HandleEditPrimaryInterestSelectionFromProfile(callback, user, interestID)</span>
        case data == "save_interest_edits":<span class="cov0" title="0">
                return h.profileInterestHandler.HandleSaveInterestEditsFromProfile(callback, user)</span>
        case data == "back_to_categories":<span class="cov0" title="0">
                return h.profileInterestHandler.HandleEditInterestsFromProfile(callback, user)</span>
        case data == "back_to_edit_categories":<span class="cov0" title="0">
                return h.profileInterestHandler.HandleEditInterestsFromProfile(callback, user)</span>
        case data == "back_to_profile":<span class="cov0" title="0">
                return h.profileHandler.HandleProfileShow(callback, user)</span>
        }

        <span class="cov0" title="0">log.Printf("DEBUG: No handler found in handleProfileInterestEditing for data: '%s'", data)
        return nil</span>
}

// HandleIsolatedEditStart начинает изолированное редактирование интересов
func (h *TelegramHandler) HandleIsolatedEditStart(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Starting isolated edit session for user %d", user.ID)
        return h.isolatedInterestEditor.StartEditSession(callback, user)
}</span>

// HandleIsolatedMainMenu обрабатывает главное меню изолированного редактирования
func (h *TelegramHandler) HandleIsolatedMainMenu(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Showing isolated main menu for user %d", user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.ShowEditMainMenu(callback, user, session)</span>
}

// HandleIsolatedEditCategories обрабатывает меню категорий
func (h *TelegramHandler) HandleIsolatedEditCategories(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Showing isolated categories menu for user %d", user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.ShowEditCategoriesMenu(callback, user, session)</span>
}

// HandleIsolatedEditCategory обрабатывает выбор категории для редактирования
func (h *TelegramHandler) HandleIsolatedEditCategory(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        log.Printf("Showing isolated category interests for user %d, category: %s", user.ID, categoryKey)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.ShowEditCategoryInterests(callback, user, session, categoryKey)</span>
}

// HandleIsolatedEditPrimary обрабатывает редактирование основных интересов
func (h *TelegramHandler) HandleIsolatedEditPrimary(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.ShowEditPrimaryInterests(callback, user, session)</span>
}

// HandleIsolatedToggleInterest обрабатывает переключение выбора интереса
func (h *TelegramHandler) HandleIsolatedToggleInterest(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        <span class="cov0" title="0">log.Printf("Toggling interest %d for user %d", interestID, user.ID)
        return h.isolatedInterestEditor.ToggleInterestSelection(callback, user, interestID)</span>
}

// HandleIsolatedTogglePrimary обрабатывает переключение основного интереса
func (h *TelegramHandler) HandleIsolatedTogglePrimary(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        <span class="cov0" title="0">log.Printf("Toggling primary status for interest %d for user %d", interestID, user.ID)
        return h.isolatedInterestEditor.TogglePrimaryInterest(callback, user, interestID)</span>
}

// HandleIsolatedPreviewChanges обрабатывает предварительный просмотр изменений
func (h *TelegramHandler) HandleIsolatedPreviewChanges(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Showing changes preview for user %d", user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.ShowChangesPreview(callback, user, session)</span>
}

// HandleIsolatedSaveChanges обрабатывает сохранение изменений
func (h *TelegramHandler) HandleIsolatedSaveChanges(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Saving changes for user %d", user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.SaveChanges(callback, user, session)</span>
}

// HandleIsolatedCancelEdit обрабатывает отмену редактирования
func (h *TelegramHandler) HandleIsolatedCancelEdit(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Canceling edit for user %d", user.ID)
        return h.isolatedInterestEditor.CancelEdit(callback, user)
}</span>

// HandleIsolatedMassSelect обрабатывает массовый выбор в категории
func (h *TelegramHandler) HandleIsolatedMassSelect(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        log.Printf("Mass selecting all interests in category %s for user %d", categoryKey, user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.MassSelectCategory(callback, user, session, categoryKey)</span>
}

// HandleIsolatedMassClear обрабатывает массовую очистку категории
func (h *TelegramHandler) HandleIsolatedMassClear(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        log.Printf("Mass clearing all interests in category %s for user %d", categoryKey, user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.MassClearCategory(callback, user, session, categoryKey)</span>
}

// HandleIsolatedUndoLast обрабатывает отмену последнего действия
func (h *TelegramHandler) HandleIsolatedUndoLast(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Undoing last action for user %d", user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.UndoLastChange(callback, user, session)</span>
}

// HandleIsolatedShowStats обрабатывает показ статистики
func (h *TelegramHandler) HandleIsolatedShowStats(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        log.Printf("Showing edit statistics for user %d", user.ID)

        session, err := h.isolatedInterestEditor.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        <span class="cov0" title="0">return h.isolatedInterestEditor.ShowEditStatistics(callback, user, session)</span>
}

// handleIsolatedCallbacks обрабатывает все callback'и изолированной системы через роутер
func (h *TelegramHandler) handleIsolatedCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        // Используем роутер для обработки callback'а
        return h.isolatedRouter.Handle(callback, user)
}</span>

func (h *TelegramHandler) handleProfileCommands(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        log.Printf("DEBUG: handleProfileCommands called with data: '%s' for user %d", data, user.ID)

        switch data </span>{
        case "profile_show":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling profile_show for user %d", user.ID)
                return h.profileHandler.HandleProfileShow(callback, user)</span>
        case "profile_reset_ask":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling profile_reset_ask for user %d", user.ID)
                return h.profileHandler.HandleProfileResetAsk(callback, user)</span>
        case "profile_reset_yes":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling profile_reset_yes for user %d", user.ID)
                return h.profileHandler.HandleProfileResetYes(callback, user)</span>
        case "profile_reset_no":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling profile_reset_no for user %d", user.ID)
                return h.menuHandler.HandleBackToMainMenu(callback, user)</span>
        case "back_to_previous_step":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling back_to_previous_step for user %d", user.ID)
                return h.profileHandler.HandleProfileShow(callback, user)</span>
        case "edit_languages":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling edit_languages for user %d", user.ID)
                return h.profileHandler.HandleEditLanguages(callback, user)</span>
        case "edit_native_lang":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling edit_native_lang for user %d", user.ID)
                return h.profileHandler.HandleEditNativeLang(callback, user)</span>
        case "edit_target_lang":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling edit_target_lang for user %d", user.ID)
                return h.profileHandler.HandleEditTargetLang(callback, user)</span>
        case "edit_level":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling edit_level for user %d", user.ID)
                return h.profileHandler.HandleEditLevelLang(callback, user)</span>
        case "edit_availability":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling edit_availability for user %d", user.ID)
                return h.availabilityHandler.HandleTimeAvailabilityStart(callback, user)</span>
        case "continue_to_availability":<span class="cov0" title="0">
                log.Printf("DEBUG: Handling continue_to_availability for user %d", user.ID)
                return h.startAvailabilitySetup(callback, user)</span>
        }

        <span class="cov0" title="0">log.Printf("DEBUG: No handler found for data: '%s' for user %d", data, user.ID)
        return nil</span>
}

// handleMenuCallbacks обрабатывает callback'и связанные с меню.
func (h *TelegramHandler) handleMenuCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        switch data </span>{
        case "main_change_language":<span class="cov0" title="0">
                return h.menuHandler.HandleMainChangeLanguage(callback, user)</span>
        case "main_view_profile":<span class="cov0" title="0">
                return h.menuHandler.HandleMainViewProfile(callback, user, h.profileHandler)</span>
        case "main_edit_profile":<span class="cov0" title="0">
                return h.menuHandler.HandleMainEditProfile(callback, user, h.profileHandler)</span>
        case "main_feedback":<span class="cov0" title="0">
                return h.menuHandler.HandleMainFeedback(callback, user, h.feedbackHandler)</span>
        case "feedback_help":<span class="cov0" title="0">
                return h.menuHandler.HandleFeedbackHelp(callback, user)</span>
        case "start_profile_setup":<span class="cov0" title="0">
                return h.profileHandler.StartProfileSetup(callback, user)</span>
        case "show_profile_setup_features":<span class="cov0" title="0">
                return h.profileHandler.ShowProfileSetupFeatures(callback, user)</span>
        case "profile_setup_continue":<span class="cov0" title="0">
                return h.profileHandler.StartProfileSetup(callback, user)</span>
        case "back_to_main_menu":<span class="cov0" title="0">
                return h.menuHandler.HandleBackToMainMenu(callback, user)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleFeedbackCallbacks обрабатывает callback'и связанные с отзывами.
func (h *TelegramHandler) handleFeedbackCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        // Проверяем права администратора для доступа к отзывам
        if !h.isAdmin(callback.From.ID, callback.From.UserName) </span><span class="cov0" title="0">{
                // Если это не администратор, игнорируем callback
                return nil
        }</span>
        <span class="cov0" title="0">switch </span>{
        case strings.HasPrefix(data, "fb_process_"):<span class="cov0" title="0">
                feedbackIDStr := strings.TrimPrefix(data, "fb_process_")

                return h.feedbackHandler.HandleFeedbackProcess(callback, user, feedbackIDStr)</span>
        case strings.HasPrefix(data, "fb_unprocess_"):<span class="cov0" title="0">
                feedbackIDStr := strings.TrimPrefix(data, "fb_unprocess_")

                return h.feedbackHandler.HandleFeedbackUnprocess(callback, user, feedbackIDStr)</span>
        case strings.HasPrefix(data, "fb_delete_"):<span class="cov0" title="0">
                feedbackIDStr := strings.TrimPrefix(data, "fb_delete_")

                return h.feedbackHandler.HandleFeedbackDelete(callback, user, feedbackIDStr)</span>
        case strings.HasPrefix(data, "browse_active_feedbacks_"):<span class="cov0" title="0">
                indexStr := strings.TrimPrefix(data, "browse_active_feedbacks_")

                return h.feedbackHandler.HandleBrowseActiveFeedbacks(callback, user, indexStr)</span>
        case strings.HasPrefix(data, "browse_archive_feedbacks_"):<span class="cov0" title="0">
                indexStr := strings.TrimPrefix(data, "browse_archive_feedbacks_")

                return h.feedbackHandler.HandleBrowseArchiveFeedbacks(callback, user, indexStr)</span>
        case strings.HasPrefix(data, "browse_all_feedbacks_"):<span class="cov0" title="0">
                indexStr := strings.TrimPrefix(data, "browse_all_feedbacks_")

                return h.feedbackHandler.HandleBrowseAllFeedbacks(callback, user, indexStr)</span>
        case strings.HasPrefix(data, "feedback_prev_"):<span class="cov0" title="0">
                parts := strings.TrimPrefix(data, "feedback_prev_")

                indexAndType := strings.Split(parts, "_")
                if len(indexAndType) == localization.MinPartsForFeedbackNav </span><span class="cov0" title="0">{
                        return h.feedbackHandler.HandleFeedbackPrev(callback, user, indexAndType[0], indexAndType[1])
                }</span>

                <span class="cov0" title="0">return nil</span>
        case strings.HasPrefix(data, "feedback_next_"):<span class="cov0" title="0">
                parts := strings.TrimPrefix(data, "feedback_next_")

                indexAndType := strings.Split(parts, "_")
                if len(indexAndType) == localization.MinPartsForFeedbackNav </span><span class="cov0" title="0">{
                        return h.feedbackHandler.HandleFeedbackNext(callback, user, indexAndType[0], indexAndType[1])
                }</span>

                <span class="cov0" title="0">return nil</span>
        case strings.HasPrefix(data, "feedback_back_"):<span class="cov0" title="0">
                feedbackType := strings.TrimPrefix(data, "feedback_back_")

                return h.feedbackHandler.HandleFeedbackBack(callback, user, feedbackType)</span>
        case data == "show_active_feedbacks":<span class="cov0" title="0">
                return h.feedbackHandler.HandleShowActiveFeedbacks(callback, user)</span>
        case data == "show_archive_feedbacks":<span class="cov0" title="0">
                return h.feedbackHandler.HandleShowArchiveFeedbacks(callback, user)</span>
        case data == "show_all_feedbacks":<span class="cov0" title="0">
                return h.feedbackHandler.HandleShowAllFeedbacks(callback, user)</span>
        case strings.HasPrefix(data, "nav_"):<span class="cov0" title="0">
                parts := strings.Split(data, "_")
                if len(parts) &gt;= localization.MinPartsForNav </span><span class="cov0" title="0">{
                        feedbackType := parts[1] // active, archive, all
                        indexStr := parts[3]     // 0, 1, 2, etc.

                        return h.feedbackHandler.HandleNavigateFeedback(callback, user, feedbackType, indexStr)
                }</span>

                <span class="cov0" title="0">return nil</span>
        case strings.HasPrefix(data, "archive_feedback_"):<span class="cov0" title="0">
                // Обработка архивирования: archive_feedback_0
                indexStr := strings.TrimPrefix(data, "archive_feedback_")

                return h.feedbackHandler.HandleArchiveFeedback(callback, user, indexStr)</span>
        case strings.HasPrefix(data, "back_to_active_feedbacks") ||
                strings.HasPrefix(data, "back_to_archive_feedbacks") ||
                strings.HasPrefix(data, "back_to_all_feedbacks"):<span class="cov0" title="0">
                // Обработка возврата к списку отзывов: back_to_active_feedbacks, back_to_archive_feedbacks, etc.
                parts := strings.Split(data, "_")
                if len(parts) &gt;= localization.MinPartsForNav </span><span class="cov0" title="0">{
                        feedbackType := parts[2] // active, archive, all

                        return h.feedbackHandler.HandleBackToFeedbacks(callback, user, feedbackType)
                }</span>

                <span class="cov0" title="0">return nil</span>
        case data == "back_to_feedback_stats":<span class="cov0" title="0">
                // Обработка возврата к статистике отзывов
                return h.feedbackHandler.HandleBackToFeedbackStats(callback, user)</span>
        case strings.HasPrefix(data, "delete_current_feedback_"):<span class="cov0" title="0">
                // Обработка удаления текущего отзыва: delete_current_feedback_0
                indexStr := strings.TrimPrefix(data, "delete_current_feedback_")

                return h.feedbackHandler.HandleDeleteCurrentFeedback(callback, user, indexStr)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// startAvailabilitySetup начинает настройку доступности после завершения интересов
func (h *TelegramHandler) startAvailabilitySetup(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Переводим пользователя в состояние ожидания настройки доступности
        err := h.service.DB.UpdateUserState(user.ID, models.StateWaitingTimeAvailability)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user state: %w", err)
        }</span>

        // Автоматически начинаем настройку доступности
        <span class="cov0" title="0">return h.availabilityHandler.HandleTimeAvailabilityStart(callback, user)</span>
}

// handleAvailabilityCallbacks обрабатывает callback'и связанные с настройкой доступности
func (h *TelegramHandler) handleAvailabilityCallbacks(callback *tgbotapi.CallbackQuery, user *models.User, data string) error <span class="cov0" title="0">{
        switch </span>{
        case data == "setup_availability":<span class="cov0" title="0">
                return h.availabilityHandler.HandleTimeAvailabilityStart(callback, user)</span>
        case strings.HasPrefix(data, "availability_daytype_"):<span class="cov0" title="0">
                dayType := strings.TrimPrefix(data, "availability_daytype_")
                return h.availabilityHandler.HandleDayTypeSelection(callback, user, dayType)</span>
        case strings.HasPrefix(data, "availability_specific_day_"):<span class="cov0" title="0">
                day := strings.TrimPrefix(data, "availability_specific_day_")
                return h.availabilityHandler.HandleSpecificDaysSelection(callback, user, day)</span>
        case data == "availability_proceed_to_time":<span class="cov0" title="0">
                // Получаем текущую доступность, чтобы определить следующий шаг
                availability, err := h.service.DB.GetTimeAvailability(user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get time availability: %w", err)
                }</span>
                <span class="cov0" title="0">if availability.DayType == "specific" &amp;&amp; len(availability.SpecificDays) == 0 </span><span class="cov0" title="0">{
                        // Если выбраны specific дни, но ничего не выбрано, показываем ошибку
                        return h.availabilityHandler.ShowSpecificDaysSelection(callback, user)
                }</span>
                <span class="cov0" title="0">return h.availabilityHandler.ShowTimeSlotSelection(callback, user)</span>
        case strings.HasPrefix(data, "availability_timeslot_"):<span class="cov0" title="0">
                timeSlot := strings.TrimPrefix(data, "availability_timeslot_")
                return h.availabilityHandler.HandleTimeSlotSelection(callback, user, timeSlot)</span>
        case data == "setup_friendship_preferences":<span class="cov0" title="0">
                return h.availabilityHandler.HandleFriendshipPreferencesStart(callback, user)</span>
        case strings.HasPrefix(data, "availability_activity_"):<span class="cov0" title="0">
                activityType := strings.TrimPrefix(data, "availability_activity_")
                return h.availabilityHandler.HandleActivityTypeSelection(callback, user, activityType)</span>
        case strings.HasPrefix(data, "availability_communication_"):<span class="cov0" title="0">
                communicationStyle := strings.TrimPrefix(data, "availability_communication_")
                return h.availabilityHandler.HandleCommunicationStyleSelection(callback, user, communicationStyle)</span>
        case strings.HasPrefix(data, "availability_frequency_"):<span class="cov0" title="0">
                frequency := strings.TrimPrefix(data, "availability_frequency_")
                return h.availabilityHandler.HandleCommunicationFrequencySelection(callback, user, frequency)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// sendRateLimitMessage отправляет сообщение о превышении лимита запросов
func (h *TelegramHandler) sendRateLimitMessage(userID int64, err error) <span class="cov8" title="1">{
        // Получаем локализацию (используем английский по умолчанию)
        message := "Too many requests. Please try again later."

        // В будущем можно добавить локализацию для сообщений rate limiting

        // Отправляем сообщение пользователю
        msg := tgbotapi.NewMessage(userID, message)
        msg.ParseMode = "HTML"

        if _, sendErr := h.bot.Send(msg); sendErr != nil </span><span class="cov8" title="1">{
                // Логируем ошибку отправки, но не возвращаем её
                log.Printf("Failed to send rate limit message to user %d: %v", userID, sendErr)
        }</span>
}

// GetRateLimiterStats возвращает статистику rate limiter'а (для администраторов)
func (h *TelegramHandler) GetRateLimiterStats() map[string]interface{} <span class="cov8" title="1">{
        if h.rateLimiter != nil </span><span class="cov8" title="1">{
                return h.rateLimiter.GetStats()
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{"error": "rate limiter not initialized"}</span>
}

// Stop останавливает все компоненты handler'а
func (h *TelegramHandler) Stop() <span class="cov8" title="1">{
        if h.rateLimiter != nil </span><span class="cov8" title="1">{
                h.rateLimiter.Stop()
        }</span>
}

// SetService устанавливает сервис для handler'а
func (h *TelegramHandler) SetService(service *core.BotService) <span class="cov8" title="1">{
        h.service = service
}</span>

// SetBotAPI устанавливает BotAPI для handler'а
func (h *TelegramHandler) SetBotAPI(bot *tgbotapi.BotAPI) <span class="cov8" title="1">{
        h.bot = bot
}</span>

// GetService возвращает сервис handler'а
func (h *TelegramHandler) GetService() *core.BotService <span class="cov8" title="1">{
        return h.service
}</span>

// GetBotAPI возвращает BotAPI handler'а
func (h *TelegramHandler) GetBotAPI() *tgbotapi.BotAPI <span class="cov8" title="1">{
        return h.bot
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "fmt"
        "strconv"
        "strings"

        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для типов отзывов.
const (
        FeedbackTypeArchive = "archive"
        FeedbackTypeAll     = "all"
        FeedbackTypeActive  = "active"
)

// AdminHandler интерфейс для обработки административных функций.
type AdminHandler interface {
        ShowFeedbackStatisticsEdit(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleBrowseActiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleBrowseArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        ShowFeedbackItemWithNavigationEdit(
                callback *tgbotapi.CallbackQuery,
                fb map[string]interface{},
                currentIndex int,
                totalCount int,
                feedbackType string,
        ) error
        IsAdmin(chatID int64, username string) bool
}

// AdminHandlerImpl реализация административного обработчика.
type AdminHandlerImpl struct {
        base           *BaseHandler
        adminChatIDs   []int64
        adminUsernames []string
}

// NewAdminHandler создает новый административный обработчик.
func NewAdminHandler(
        base *BaseHandler,
        adminChatIDs []int64,
        adminUsernames []string,
) *AdminHandlerImpl <span class="cov0" title="0">{
        return &amp;AdminHandlerImpl{
                base:           base,
                adminChatIDs:   adminChatIDs,
                adminUsernames: adminUsernames,
        }
}</span>

// IsAdmin проверяет права администратора.
func (h *AdminHandlerImpl) IsAdmin(chatID int64, username string) bool <span class="cov0" title="0">{
        // Проверяем по Chat ID
        for _, adminID := range h.adminChatIDs </span><span class="cov0" title="0">{
                if chatID == adminID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Проверяем по username
        <span class="cov0" title="0">if username != "" </span><span class="cov0" title="0">{
                for _, adminUsername := range h.adminUsernames </span><span class="cov0" title="0">{
                        cleanUsername := strings.TrimPrefix(adminUsername, "@")
                        if username == cleanUsername </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// ShowFeedbackStatisticsEdit показывает статистику отзывов с редактированием текущего сообщения.
func (h *AdminHandlerImpl) ShowFeedbackStatisticsEdit(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Проверяем права администратора
        if !h.IsAdmin(callback.Message.Chat.ID, user.Username) </span><span class="cov0" title="0">{
                // Используем MessageFactory для отправки сообщения об отказе доступа
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "❌ Данная команда доступна только администраторам бота.")
        }</span>

        // Получаем все отзывы
        <span class="cov0" title="0">feedbacks, err := h.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем MessageFactory для отправки сообщения об ошибке
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                err = h.base.messageFactory.EditText(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        "📝 Отзывов пока нет",
                )
                return err
        }</span>

        // Подсчитываем статистику
        <span class="cov0" title="0">totalCount := len(feedbacks)
        processedCount := 0

        for _, fb := range feedbacks </span><span class="cov0" title="0">{
                if fb["is_processed"].(bool) </span><span class="cov0" title="0">{
                        processedCount++
                }</span>
        }

        <span class="cov0" title="0">pendingCount := totalCount - processedCount

        // Формируем текст статистики
        statsText := fmt.Sprintf("📊 Статистика отзывов:\n\n"+
                "📝 Всего отзывов: %d\n"+
                "✅ Обработано: %d\n"+
                "⏳ Ожидают обработки: %d",
                totalCount, processedCount, pendingCount)

        // Создаем клавиатуру для управления отзывами
        keyboard := h.base.keyboardBuilder.CreateFeedbackAdminKeyboard(user.InterfaceLanguageCode)

        err = h.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                statsText,
                &amp;keyboard,
        )
        return err</span>
}

// HandleBrowseActiveFeedbacks показывает активные отзывы в интерактивном режиме с редактированием.
func (h *AdminHandlerImpl) HandleBrowseActiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                h.base.service.LoggingService.Telegram().ErrorWithContext(
                        "Parse index error",
                        generateRequestID("HandleBrowseActiveFeedbacks"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleBrowseActiveFeedbacks",
                        map[string]interface{}{"error": err.Error()},
                )

                // Используем MessageFactory для отправки сообщения об ошибке индекса
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "❌ Ошибка индекса")
        }</span>

        // Получаем активные отзывы
        <span class="cov0" title="0">feedbacks, err := h.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                h.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        generateRequestID("HandleBrowseActiveFeedbacks"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleBrowseActiveFeedbacks",
                        map[string]interface{}{"error": err.Error()},
                )

                // Используем MessageFactory для отправки сообщения об ошибке
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        // Фильтруем только необработанные отзывы
        <span class="cov0" title="0">var activeFeedbacks []map[string]interface{}

        type feedbackKey struct {
                userID       int64
                feedbackText string
        }

        seen := make(map[feedbackKey][]map[string]interface{})

        for _, fb := range feedbacks </span><span class="cov0" title="0">{
                if !fb["is_processed"].(bool) </span><span class="cov0" title="0">{
                        key := feedbackKey{
                                userID:       fb["telegram_id"].(int64),
                                feedbackText: fb["feedback_text"].(string),
                        }
                        seen[key] = append(seen[key], fb)
                }</span>
        }

        <span class="cov0" title="0">for _, group := range seen </span><span class="cov0" title="0">{
                for _, fb := range group </span><span class="cov0" title="0">{
                        activeFeedbacks = append(activeFeedbacks, fb)

                        break</span>
                }
        }

        <span class="cov0" title="0">if len(activeFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Используем MessageFactory для отправки сообщения
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "🎉 Все отзывы обработаны!")
        }</span>

        // Проверяем границы
        <span class="cov0" title="0">if index &lt; 0 || index &gt;= len(activeFeedbacks) </span><span class="cov0" title="0">{
                index = 0
        }</span>

        // Показываем текущий отзыв с редактированием текущего сообщения
        <span class="cov0" title="0">return h.ShowFeedbackItemWithNavigationEdit(
                callback,
                activeFeedbacks[index],
                index,
                len(activeFeedbacks),
                FeedbackTypeActive,
        )</span>
}

// HandleBrowseArchiveFeedbacks показывает обработанные отзывы в интерактивном режиме.
func (h *AdminHandlerImpl) HandleBrowseArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                h.base.service.LoggingService.Telegram().ErrorWithContext(
                        "Parse index error",
                        generateRequestID("HandleBrowseActiveFeedbacks"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleBrowseActiveFeedbacks",
                        map[string]interface{}{"error": err.Error()},
                )

                // Используем MessageFactory для отправки сообщения об ошибке индекса
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "❌ Ошибка индекса")
        }</span>

        // Получаем обработанные отзывы
        <span class="cov0" title="0">feedbacks, err := h.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                h.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        generateRequestID("HandleBrowseActiveFeedbacks"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleBrowseActiveFeedbacks",
                        map[string]interface{}{"error": err.Error()},
                )

                // Используем MessageFactory для отправки сообщения об ошибке
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        // Фильтруем только обработанные отзывы
        <span class="cov0" title="0">var archivedFeedbacks []map[string]interface{}

        type feedbackKey struct {
                userID       int64
                feedbackText string
        }

        seen := make(map[feedbackKey][]map[string]interface{})

        for _, fb := range feedbacks </span><span class="cov0" title="0">{
                if fb["is_processed"].(bool) </span><span class="cov0" title="0">{
                        key := feedbackKey{
                                userID:       fb["telegram_id"].(int64),
                                feedbackText: fb["feedback_text"].(string),
                        }
                        seen[key] = append(seen[key], fb)
                }</span>
        }

        <span class="cov0" title="0">for _, group := range seen </span><span class="cov0" title="0">{
                for _, fb := range group </span><span class="cov0" title="0">{
                        archivedFeedbacks = append(archivedFeedbacks, fb)

                        break</span>
                }
        }

        <span class="cov0" title="0">if len(archivedFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Используем MessageFactory для отправки сообщения
                return h.base.messageFactory.SendText(callback.Message.Chat.ID, "📝 Обработанных отзывов пока нет")
        }</span>

        // Проверяем границы
        <span class="cov0" title="0">if index &lt; 0 || index &gt;= len(archivedFeedbacks) </span><span class="cov0" title="0">{
                index = 0
        }</span>

        // Показываем текущий отзыв с редактированием текущего сообщения
        <span class="cov0" title="0">return h.ShowFeedbackItemWithNavigationEdit(
                callback,
                archivedFeedbacks[index],
                index,
                len(archivedFeedbacks),
                FeedbackTypeArchive,
        )</span>
}

// ShowFeedbackItemWithNavigationEdit показывает отзыв с навигацией (редактирует текущее сообщение).
func (h *AdminHandlerImpl) ShowFeedbackItemWithNavigationEdit(
        callback *tgbotapi.CallbackQuery,
        fb map[string]interface{},
        currentIndex int,
        totalCount int,
        feedbackType string,
) error <span class="cov0" title="0">{
        // Формируем текст отзыва
        feedbackText := h.formatFeedbackText(fb, currentIndex, totalCount, feedbackType)

        // Создаем клавиатуру навигации
        keyboard := h.createFeedbackNavigationKeyboard(fb, currentIndex, totalCount, feedbackType)

        err := h.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                feedbackText,
                &amp;keyboard,
        )
        return err
}</span>

// formatFeedbackText форматирует текст отзыва для отображения.
func (h *AdminHandlerImpl) formatFeedbackText(fb map[string]interface{}, currentIndex int, totalCount int, feedbackType string) string <span class="cov0" title="0">{
        userID := fb["telegram_id"].(int64)

        username := ""
        if fb["username"] != nil </span><span class="cov0" title="0">{
                username = fb["username"].(string)
        }</span>

        <span class="cov0" title="0">firstName := ""
        if fb["first_name"] != nil </span><span class="cov0" title="0">{
                firstName = fb["first_name"].(string)
        }</span>

        <span class="cov0" title="0">feedbackText := fb["feedback_text"].(string)

        contactInfo := ""
        if fb["contact_info"] != nil &amp;&amp; fb["contact_info"].(string) != "" </span><span class="cov0" title="0">{
                contactInfo = fb["contact_info"].(string)
        }</span>

        // Определяем статус и тип
        <span class="cov0" title="0">status := "❌ Не обработан"
        if fb["is_processed"].(bool) </span><span class="cov0" title="0">{
                status = "✅ Обработан"
        }</span>

        <span class="cov0" title="0">typeText := "📝 Активные отзывы"

        switch feedbackType </span>{
        case FeedbackTypeArchive:<span class="cov0" title="0">
                typeText = "📁 Архив отзывов"</span>
        case FeedbackTypeAll:<span class="cov0" title="0">
                typeText = "📊 Все отзывы"</span>
        }

        // Формируем информацию о пользователе
        <span class="cov0" title="0">userInfo := fmt.Sprintf("ID: %d", userID)
        if username != "" </span><span class="cov0" title="0">{
                userInfo += fmt.Sprintf(" (@%s)", username)
        }</span>

        <span class="cov0" title="0">if firstName != "" </span><span class="cov0" title="0">{
                userInfo += " - " + firstName
        }</span>

        // Формируем полный текст
        <span class="cov0" title="0">text := fmt.Sprintf("%s (%d/%d)\n\n"+
                "👤 Пользователь: %s\n"+
                "📝 Отзыв: %s\n"+
                "📊 Статус: %s",
                typeText, currentIndex+1, totalCount,
                userInfo, feedbackText, status)

        if contactInfo != "" </span><span class="cov0" title="0">{
                text += "\n📞 Контакт: " + contactInfo
        }</span>

        <span class="cov0" title="0">return text</span>
}

// createFeedbackNavigationKeyboard создает клавиатуру навигации для отзывов.
func (h *AdminHandlerImpl) createFeedbackNavigationKeyboard(
        fb map[string]interface{},
        currentIndex int,
        totalCount int,
        feedbackType string,
) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var keyboard [][]tgbotapi.InlineKeyboardButton

        // Кнопки навигации
        if totalCount &gt; 1 </span><span class="cov0" title="0">{
                var navRow []tgbotapi.InlineKeyboardButton
                if currentIndex &gt; 0 </span><span class="cov0" title="0">{
                        navRow = append(navRow, tgbotapi.NewInlineKeyboardButtonData(
                                "⬅️ Пред",
                                fmt.Sprintf("browse_%s_%d", feedbackType, currentIndex-1),
                        ))
                }</span>

                <span class="cov0" title="0">if currentIndex &lt; totalCount-1 </span><span class="cov0" title="0">{
                        navRow = append(navRow, tgbotapi.NewInlineKeyboardButtonData(
                                "След ➡️",
                                fmt.Sprintf("browse_%s_%d", feedbackType, currentIndex+1),
                        ))
                }</span>

                <span class="cov0" title="0">if len(navRow) &gt; 0 </span><span class="cov0" title="0">{
                        keyboard = append(keyboard, navRow)
                }</span>
        }

        // Кнопки действий для необработанных отзывов
        <span class="cov0" title="0">if feedbackType == FeedbackTypeActive &amp;&amp; !fb["is_processed"].(bool) </span><span class="cov0" title="0">{
                actionRow := []tgbotapi.InlineKeyboardButton{
                        tgbotapi.NewInlineKeyboardButtonData("✅ Обработать", fmt.Sprintf("fb_process_%v", fb["id"])),
                }
                keyboard = append(keyboard, actionRow)
        }</span>

        // Кнопки действий для обработанных отзывов
        <span class="cov0" title="0">if feedbackType == FeedbackTypeArchive &amp;&amp; fb["is_processed"].(bool) </span><span class="cov0" title="0">{
                actionRow := []tgbotapi.InlineKeyboardButton{
                        tgbotapi.NewInlineKeyboardButtonData("❌ Снять обработку", fmt.Sprintf("fb_unprocess_%v", fb["id"])),
                }
                keyboard = append(keyboard, actionRow)
        }</span>

        // Кнопка "Назад к статистике"
        <span class="cov0" title="0">backRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData("🔙 К статистике", "feedback_stats"),
        }
        keyboard = append(keyboard, backRow)

        return tgbotapi.NewInlineKeyboardMarkup(keyboard...)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "fmt"
        "strings"

        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// AvailabilityHandlerImpl реализует обработчики для настройки доступности пользователя
type AvailabilityHandlerImpl struct {
        base *BaseHandler
}

// NewAvailabilityHandler создает новый обработчик доступности
func NewAvailabilityHandler(base *BaseHandler) *AvailabilityHandlerImpl <span class="cov0" title="0">{
        return &amp;AvailabilityHandlerImpl{
                base: base,
        }
}</span>

// HandleTimeAvailabilityStart начинает настройку временной доступности
func (ah *AvailabilityHandlerImpl) HandleTimeAvailabilityStart(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "time_availability_intro")
        keyboard := ah.createDayTypeSelectionKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := ah.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send time availability start message: %w", err)
        }</span>

        // Переводим пользователя в состояние ожидания выбора типа дней
        <span class="cov0" title="0">return ah.base.service.DB.UpdateUserState(user.ID, models.StateWaitingTimeAvailability)</span>
}

// HandleDayTypeSelection обрабатывает выбор типа дней (weekdays/weekends/any/specific)
func (ah *AvailabilityHandlerImpl) HandleDayTypeSelection(callback *tgbotapi.CallbackQuery, user *models.User, dayType string) error <span class="cov0" title="0">{
        // Сохраняем выбранный тип дней
        availability := &amp;models.TimeAvailability{
                DayType:      dayType,
                SpecificDays: []string{}, // Пока пустой
                TimeSlot:     "",         // Будет выбран позже
        }

        // Сохраняем в БД
        err := ah.base.service.DB.SaveTimeAvailability(user.ID, availability)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save time availability: %w", err)
        }</span>

        // Если выбран specific, показываем выбор конкретных дней
        <span class="cov0" title="0">if dayType == "specific" </span><span class="cov0" title="0">{
                return ah.ShowSpecificDaysSelection(callback, user)
        }</span>

        // Иначе переходим к выбору времени дня
        <span class="cov0" title="0">return ah.ShowTimeSlotSelection(callback, user)</span>
}

// HandleSpecificDaysSelection обрабатывает выбор конкретных дней недели
func (ah *AvailabilityHandlerImpl) HandleSpecificDaysSelection(callback *tgbotapi.CallbackQuery, user *models.User, day string) error <span class="cov0" title="0">{
        // Получаем текущую доступность
        availability, err := ah.base.service.DB.GetTimeAvailability(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get time availability: %w", err)
        }</span>

        // Добавляем или убираем день из списка
        <span class="cov0" title="0">if ah.containsDay(availability.SpecificDays, day) </span><span class="cov0" title="0">{
                // Убираем день
                availability.SpecificDays = ah.removeDay(availability.SpecificDays, day)
        }</span> else<span class="cov0" title="0"> {
                // Добавляем день
                availability.SpecificDays = append(availability.SpecificDays, day)
        }</span>

        // Сохраняем обновленную доступность
        <span class="cov0" title="0">err = ah.base.service.DB.SaveTimeAvailability(user.ID, availability)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save time availability: %w", err)
        }</span>

        // Обновляем клавиатуру
        <span class="cov0" title="0">return ah.ShowSpecificDaysSelection(callback, user)</span>
}

// HandleTimeSlotSelection обрабатывает выбор временного слота
func (ah *AvailabilityHandlerImpl) HandleTimeSlotSelection(callback *tgbotapi.CallbackQuery, user *models.User, timeSlot string) error <span class="cov0" title="0">{
        // Получаем текущую доступность
        availability, err := ah.base.service.DB.GetTimeAvailability(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get time availability: %w", err)
        }</span>

        // Устанавливаем временной слот
        <span class="cov0" title="0">availability.TimeSlot = timeSlot

        // Сохраняем в БД
        err = ah.base.service.DB.SaveTimeAvailability(user.ID, availability)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save time availability: %w", err)
        }</span>

        // Переходим к настройке предпочтений общения
        <span class="cov0" title="0">return ah.startFriendshipPreferencesSetup(callback, user)</span>
}

// HandleFriendshipPreferencesStart начинает настройку предпочтений общения
func (ah *AvailabilityHandlerImpl) HandleFriendshipPreferencesStart(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "friendship_preferences_intro")
        keyboard := ah.createActivityTypeSelectionKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := ah.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send friendship preferences start message: %w", err)
        }</span>

        // Переводим пользователя в состояние ожидания выбора типа активности
        <span class="cov0" title="0">return ah.base.service.DB.UpdateUserState(user.ID, models.StateWaitingFriendshipPreferences)</span>
}

// HandleActivityTypeSelection обрабатывает выбор типа активности
func (ah *AvailabilityHandlerImpl) HandleActivityTypeSelection(callback *tgbotapi.CallbackQuery, user *models.User, activityType string) error <span class="cov0" title="0">{
        // Сохраняем выбранный тип активности
        preferences := &amp;models.FriendshipPreferences{
                ActivityType:       activityType,
                CommunicationStyle: "", // Будет выбран позже
                CommunicationFreq:  "", // Будет выбран позже
        }

        // Сохраняем в БД
        err := ah.base.service.DB.SaveFriendshipPreferences(user.ID, preferences)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save friendship preferences: %w", err)
        }</span>

        // Переходим к выбору стиля общения
        <span class="cov0" title="0">return ah.showCommunicationStyleSelection(callback, user)</span>
}

// HandleCommunicationStyleSelection обрабатывает выбор стиля общения
func (ah *AvailabilityHandlerImpl) HandleCommunicationStyleSelection(callback *tgbotapi.CallbackQuery, user *models.User, communicationStyle string) error <span class="cov0" title="0">{
        // Получаем текущие предпочтения
        preferences, err := ah.base.service.DB.GetFriendshipPreferences(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get friendship preferences: %w", err)
        }</span>

        // Устанавливаем стиль общения
        <span class="cov0" title="0">preferences.CommunicationStyle = communicationStyle

        // Сохраняем в БД
        err = ah.base.service.DB.SaveFriendshipPreferences(user.ID, preferences)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save friendship preferences: %w", err)
        }</span>

        // Переходим к выбору частоты общения
        <span class="cov0" title="0">return ah.showCommunicationFrequencySelection(callback, user)</span>
}

// HandleCommunicationFrequencySelection обрабатывает выбор частоты общения
func (ah *AvailabilityHandlerImpl) HandleCommunicationFrequencySelection(callback *tgbotapi.CallbackQuery, user *models.User, frequency string) error <span class="cov0" title="0">{
        // Получаем текущие предпочтения
        preferences, err := ah.base.service.DB.GetFriendshipPreferences(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get friendship preferences: %w", err)
        }</span>

        // Устанавливаем частоту общения
        <span class="cov0" title="0">preferences.CommunicationFreq = frequency

        // Сохраняем в БД
        err = ah.base.service.DB.SaveFriendshipPreferences(user.ID, preferences)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save friendship preferences: %w", err)
        }</span>

        // Завершаем настройку доступности
        <span class="cov0" title="0">return ah.completeAvailabilitySetup(callback, user)</span>
}

// completeAvailabilitySetup завершает настройку доступности и переводит пользователя в активное состояние
func (ah *AvailabilityHandlerImpl) completeAvailabilitySetup(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Обновляем уровень завершения профиля
        err := ah.base.service.DB.UpdateUserProfileCompletionLevel(user.ID, 100)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update profile completion level: %w", err)
        }</span>

        // Переводим пользователя в активное состояние
        <span class="cov0" title="0">err = ah.base.service.DB.UpdateUserState(user.ID, models.StateActive)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user state: %w", err)
        }</span>

        // Показываем финальное сообщение
        <span class="cov0" title="0">text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "availability_setup_complete")
        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "back_to_main_menu"),
                                "back_to_main_menu",
                        ),
                ),
        )

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = ah.base.bot.Request(editMsg)
        return err</span>
}

// === Вспомогательные методы ===

// ShowSpecificDaysSelection показывает интерфейс выбора конкретных дней недели
func (ah *AvailabilityHandlerImpl) ShowSpecificDaysSelection(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        availability, err := ah.base.service.DB.GetTimeAvailability(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get time availability: %w", err)
        }</span>

        <span class="cov0" title="0">text := fmt.Sprintf(
                "%s\n\n%s: %s",
                ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "select_specific_days"),
                ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "selected_days"),
                ah.formatSelectedDays(availability.SpecificDays, user.InterfaceLanguageCode),
        )

        keyboard := ah.createSpecificDaysSelectionKeyboard(user.InterfaceLanguageCode, availability.SpecificDays)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = ah.base.bot.Request(editMsg)
        return err</span>
}

// ShowTimeSlotSelection показывает интерфейс выбора временного слота
func (ah *AvailabilityHandlerImpl) ShowTimeSlotSelection(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "select_time_slot")
        keyboard := ah.createTimeSlotSelectionKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := ah.base.bot.Request(editMsg)
        return err
}</span>

// startFriendshipPreferencesSetup начинает настройку предпочтений общения
func (ah *AvailabilityHandlerImpl) startFriendshipPreferencesSetup(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "friendship_preferences_intro")
        keyboard := ah.createActivityTypeSelectionKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := ah.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send friendship preferences start message: %w", err)
        }</span>

        // Переводим пользователя в состояние ожидания выбора типа активности
        <span class="cov0" title="0">return ah.base.service.DB.UpdateUserState(user.ID, models.StateWaitingFriendshipPreferences)</span>
}

// showCommunicationStyleSelection показывает интерфейс выбора стиля общения
func (ah *AvailabilityHandlerImpl) showCommunicationStyleSelection(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "select_communication_style")
        keyboard := ah.createCommunicationStyleSelectionKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := ah.base.bot.Request(editMsg)
        return err
}</span>

// showCommunicationFrequencySelection показывает интерфейс выбора частоты общения
func (ah *AvailabilityHandlerImpl) showCommunicationFrequencySelection(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ah.base.service.Localizer.Get(user.InterfaceLanguageCode, "select_communication_frequency")
        keyboard := ah.createCommunicationFrequencySelectionKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := ah.base.bot.Request(editMsg)
        return err
}</span>

// === Методы для работы с массивами дней ===

func (ah *AvailabilityHandlerImpl) containsDay(days []string, day string) bool <span class="cov0" title="0">{
        for _, d := range days </span><span class="cov0" title="0">{
                if d == day </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ah *AvailabilityHandlerImpl) removeDay(days []string, day string) []string <span class="cov0" title="0">{
        var result []string
        for _, d := range days </span><span class="cov0" title="0">{
                if d != day </span><span class="cov0" title="0">{
                        result = append(result, d)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func (ah *AvailabilityHandlerImpl) formatSelectedDays(days []string, lang string) string <span class="cov0" title="0">{
        if len(days) == 0 </span><span class="cov0" title="0">{
                return ah.base.service.Localizer.Get(lang, "no_days_selected")
        }</span>

        // Сортируем дни для последовательного отображения
        <span class="cov0" title="0">dayOrder := []string{"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"}
        var sortedDays []string

        for _, day := range dayOrder </span><span class="cov0" title="0">{
                if ah.containsDay(days, day) </span><span class="cov0" title="0">{
                        dayName := ah.base.service.Localizer.Get(lang, "day_"+day)
                        sortedDays = append(sortedDays, dayName)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(sortedDays, ", ")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "fmt"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// createDayTypeSelectionKeyboard создает клавиатуру выбора типа дней
func (ah *AvailabilityHandlerImpl) createDayTypeSelectionKeyboard(lang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📅 "+ah.base.service.Localizer.Get(lang, "time_weekdays"),
                                "availability_daytype_weekdays",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🏖️ "+ah.base.service.Localizer.Get(lang, "time_weekends"),
                                "availability_daytype_weekends",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🌟 "+ah.base.service.Localizer.Get(lang, "time_any"),
                                "availability_daytype_any",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📝 "+ah.base.service.Localizer.Get(lang, "select_specific_days_button"),
                                "availability_daytype_specific",
                        ),
                ),
        )
}</span>

// createSpecificDaysSelectionKeyboard создает клавиатуру выбора конкретных дней
func (ah *AvailabilityHandlerImpl) createSpecificDaysSelectionKeyboard(lang string, selectedDays []string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        days := []string{"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"}
        var rows [][]tgbotapi.InlineKeyboardButton

        // Создаем кнопки для каждого дня (2 в ряд)
        for i := 0; i &lt; len(days); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                day1 := days[i]
                day1Name := ah.base.service.Localizer.Get(lang, "day_"+day1)
                prefix1 := "☐"
                if ah.containsDay(selectedDays, day1) </span><span class="cov0" title="0">{
                        prefix1 = "☑"
                }</span>

                <span class="cov0" title="0">row = append(row, tgbotapi.NewInlineKeyboardButtonData(
                        fmt.Sprintf("%s %s", prefix1, day1Name),
                        fmt.Sprintf("availability_specific_day_%s", day1),
                ))

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(days) </span><span class="cov0" title="0">{
                        day2 := days[i+1]
                        day2Name := ah.base.service.Localizer.Get(lang, "day_"+day2)
                        prefix2 := "☐"
                        if ah.containsDay(selectedDays, day2) </span><span class="cov0" title="0">{
                                prefix2 = "☑"
                        }</span>

                        <span class="cov0" title="0">row = append(row, tgbotapi.NewInlineKeyboardButtonData(
                                fmt.Sprintf("%s %s", prefix2, day2Name),
                                fmt.Sprintf("availability_specific_day_%s", day2),
                        ))</span>
                }

                <span class="cov0" title="0">rows = append(rows, row)</span>
        }

        // Кнопка "Продолжить"
        <span class="cov0" title="0">rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                tgbotapi.NewInlineKeyboardButtonData(
                        "✅ "+ah.base.service.Localizer.Get(lang, "continue_button"),
                        "availability_proceed_to_time",
                ),
        ))

        return tgbotapi.NewInlineKeyboardMarkup(rows...)</span>
}

// createTimeSlotSelectionKeyboard создает клавиатуру выбора временного слота
func (ah *AvailabilityHandlerImpl) createTimeSlotSelectionKeyboard(lang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🌅 "+ah.base.service.Localizer.Get(lang, "time_morning"),
                                "availability_timeslot_morning",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "☀️ "+ah.base.service.Localizer.Get(lang, "time_day"),
                                "availability_timeslot_day",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🌆 "+ah.base.service.Localizer.Get(lang, "time_evening"),
                                "availability_timeslot_evening",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🌙 "+ah.base.service.Localizer.Get(lang, "time_late"),
                                "availability_timeslot_late",
                        ),
                ),
        )
}</span>

// createActivityTypeSelectionKeyboard создает клавиатуру выбора типа активности
func (ah *AvailabilityHandlerImpl) createActivityTypeSelectionKeyboard(lang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🎬 "+ah.base.service.Localizer.Get(lang, "activity_movies"),
                                "availability_activity_movies",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🎮 "+ah.base.service.Localizer.Get(lang, "activity_games"),
                                "availability_activity_games",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "☕ "+ah.base.service.Localizer.Get(lang, "activity_casual_chat"),
                                "availability_activity_casual_chat",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🎨 "+ah.base.service.Localizer.Get(lang, "activity_creative"),
                                "availability_activity_creative",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "⚽ "+ah.base.service.Localizer.Get(lang, "activity_active"),
                                "availability_activity_active",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📚 "+ah.base.service.Localizer.Get(lang, "activity_educational"),
                                "availability_activity_educational",
                        ),
                ),
        )
}</span>

// createCommunicationStyleSelectionKeyboard создает клавиатуру выбора стиля общения
func (ah *AvailabilityHandlerImpl) createCommunicationStyleSelectionKeyboard(lang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "💬 "+ah.base.service.Localizer.Get(lang, "communication_text"),
                                "availability_communication_text",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🎤 "+ah.base.service.Localizer.Get(lang, "communication_voice_msg"),
                                "availability_communication_voice_msg",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📞 "+ah.base.service.Localizer.Get(lang, "communication_audio_call"),
                                "availability_communication_audio_call",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📹 "+ah.base.service.Localizer.Get(lang, "communication_video_call"),
                                "availability_communication_video_call",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🤝 "+ah.base.service.Localizer.Get(lang, "communication_meet_person"),
                                "availability_communication_meet_person",
                        ),
                ),
        )
}</span>

// createCommunicationFrequencySelectionKeyboard создает клавиатуру выбора частоты общения
func (ah *AvailabilityHandlerImpl) createCommunicationFrequencySelectionKeyboard(lang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        return tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "⚡ "+ah.base.service.Localizer.Get(lang, "frequency_spontaneous"),
                                "availability_frequency_spontaneous",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📅 "+ah.base.service.Localizer.Get(lang, "frequency_weekly"),
                                "availability_frequency_weekly",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "📆 "+ah.base.service.Localizer.Get(lang, "frequency_daily"),
                                "availability_frequency_daily",
                        ),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "🔥 "+ah.base.service.Localizer.Get(lang, "frequency_intensive"),
                                "availability_frequency_intensive",
                        ),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/errors"
)

// BaseHandler содержит общие зависимости для всех handlers.
// Используется через композицию для уменьшения дублирования кода.
//
// Пример использования:
//
//        base := NewBaseHandler(bot, service, keyboardBuilder, errorHandler, messageFactory)
//        handler := NewFeedbackHandler(base, adminChatIDs, adminUsernames)
//        handler.base.messageFactory.SendText(chatID, "Hello")
type BaseHandler struct {
        bot             *tgbotapi.BotAPI
        service         *core.BotService
        keyboardBuilder *KeyboardBuilder
        errorHandler    *errors.ErrorHandler
        messageFactory  *MessageFactory
}

// NewBaseHandler создает новый BaseHandler с общими зависимостями.
func NewBaseHandler(
        bot *tgbotapi.BotAPI,
        service *core.BotService,
        keyboardBuilder *KeyboardBuilder,
        errorHandler *errors.ErrorHandler,
        messageFactory *MessageFactory,
) *BaseHandler <span class="cov8" title="1">{
        return &amp;BaseHandler{
                bot:             bot,
                service:         service,
                keyboardBuilder: keyboardBuilder,
                errorHandler:    errorHandler,
                messageFactory:  messageFactory,
        }
}</span>

// GetBot возвращает экземпляр Telegram Bot API.
func (b *BaseHandler) GetBot() *tgbotapi.BotAPI <span class="cov8" title="1">{
        return b.bot
}</span>

// GetService возвращает основной сервис бота.
func (b *BaseHandler) GetService() *core.BotService <span class="cov8" title="1">{
        return b.service
}</span>

// GetKeyboardBuilder возвращает построитель клавиатур.
func (b *BaseHandler) GetKeyboardBuilder() *KeyboardBuilder <span class="cov8" title="1">{
        return b.keyboardBuilder
}</span>

// GetErrorHandler возвращает обработчик ошибок.
func (b *BaseHandler) GetErrorHandler() *errors.ErrorHandler <span class="cov8" title="1">{
        return b.errorHandler
}</span>

// GetMessageFactory возвращает фабрику сообщений.
func (b *BaseHandler) GetMessageFactory() *MessageFactory <span class="cov8" title="1">{
        return b.messageFactory
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "fmt"
        "log"
        "strconv"
        "strings"
        "time"

        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для работы с отзывами.
const (
        ButtonsPerRow        = 2    // Количество кнопок в ряду
        MinFeedbackLength    = 10   // Минимальная длина отзыва
        MaxFeedbackLength    = 50   // Максимальная длина отзыва для проверки
        MaxContactInfoLength = 200  // Максимальная длина контактной информации
        MaxKeyboardButtons   = 10   // Максимальное количество кнопок в клавиатуре
        MaxFeedbackItems     = 1000 // Максимальное количество отзывов для отображения

        // FeedbackTypeActiveLocal активные отзывы.
        FeedbackTypeActiveLocal = "active"
        // FeedbackTypeArchiveLocal архивные отзывы.
        FeedbackTypeArchiveLocal = "archive"
        // FeedbackTypeAllLocal все отзывы.
        FeedbackTypeAllLocal = "all"
)

// FeedbackHandler интерфейс для обработчиков отзывов.
type FeedbackHandler interface {
        HandleFeedbackCommand(message *tgbotapi.Message, user *models.User) error
        HandleFeedbacksCommand(message *tgbotapi.Message, user *models.User) error
        HandleMainFeedback(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleFeedbackMessage(message *tgbotapi.Message, user *models.User) error
        HandleFeedbackContactMessage(message *tgbotapi.Message, user *models.User) error
        HandleFeedbackProcess(callback *tgbotapi.CallbackQuery, user *models.User, feedbackIDStr string) error
        HandleFeedbackUnprocess(callback *tgbotapi.CallbackQuery, user *models.User, feedbackIDStr string) error
        HandleFeedbackDelete(callback *tgbotapi.CallbackQuery, user *models.User, feedbackIDStr string) error
        HandleShowActiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleShowArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleShowAllFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleBrowseActiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleBrowseArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleBrowseAllFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleNavigateFeedback(callback *tgbotapi.CallbackQuery, user *models.User, feedbackType string, indexStr string) error
        HandleArchiveFeedback(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleBackToFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, feedbackType string) error
        HandleBackToFeedbackStats(callback *tgbotapi.CallbackQuery, user *models.User) error
        editActiveFeedbacks(chatID int64, messageID int, user *models.User) error
        editArchiveFeedbacks(chatID int64, messageID int, user *models.User) error
        editAllFeedbacks(chatID int64, messageID int, user *models.User) error
        editActiveFeedbacksList(chatID int64, messageID int, user *models.User) error
        editArchiveFeedbacksList(chatID int64, messageID int, user *models.User) error
        editAllFeedbacksList(chatID int64, messageID int, user *models.User) error
        HandleDeleteCurrentFeedback(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleDeleteAllArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleConfirmDeleteAllArchive(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleUnarchiveFeedback(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error
        HandleFeedbackPrev(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string, feedbackType string) error
        HandleFeedbackNext(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string, feedbackType string) error
        HandleFeedbackBack(callback *tgbotapi.CallbackQuery, user *models.User, feedbackType string) error
}

// FeedbackHandlerImpl реализация обработчиков отзывов.
type FeedbackHandlerImpl struct {
        base           *BaseHandler
        adminChatIDs   []int64
        adminUsernames []string
}

// NewFeedbackHandler создает новый экземпляр FeedbackHandler.
func NewFeedbackHandler(
        base *BaseHandler,
        adminChatIDs []int64,
        adminUsernames []string,
) *FeedbackHandlerImpl <span class="cov0" title="0">{
        return &amp;FeedbackHandlerImpl{
                base:           base,
                adminChatIDs:   adminChatIDs,
                adminUsernames: adminUsernames,
        }
}</span>

// HandleFeedbackCommand обрабатывает команду /feedback.
func (fh *FeedbackHandlerImpl) HandleFeedbackCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        text := fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_text")
        if err := fh.base.service.DB.UpdateUserState(user.ID, models.StateWaitingFeedback); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update user state to waiting feedback for user %d: %v", user.ID, err)
        }</span>

        <span class="cov0" title="0">return fh.sendMessage(message.Chat.ID, text)</span>
}

// HandleFeedbacksCommand обрабатывает команду /feedbacks (только для администраторов).
func (fh *FeedbackHandlerImpl) HandleFeedbacksCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        // Проверяем права администратора по Chat ID и username
        isAdminByID := false
        isAdminByUsername := false

        // Проверяем по Chat ID
        for _, adminID := range fh.adminChatIDs </span><span class="cov0" title="0">{
                if message.Chat.ID == adminID </span><span class="cov0" title="0">{
                        isAdminByID = true

                        break</span>
                }
        }

        // Проверяем по username
        <span class="cov0" title="0">if message.From != nil &amp;&amp; message.From.UserName != "" </span><span class="cov0" title="0">{
                for _, adminUsername := range fh.adminUsernames </span><span class="cov0" title="0">{
                        if message.From.UserName == adminUsername </span><span class="cov0" title="0">{
                                isAdminByUsername = true

                                break</span>
                        }
                }
        }

        // Если пользователь не является администратором, отправляем сообщение об отказе
        <span class="cov0" title="0">if !isAdminByID &amp;&amp; !isAdminByUsername </span><span class="cov0" title="0">{
                return fh.sendMessage(message.Chat.ID, fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "access_denied"))
        }</span>

        // Показываем статистику отзывов и меню управления
        <span class="cov0" title="0">return fh.showFeedbackStatistics(message.Chat.ID, user)</span>
}

// HandleMainFeedback обрабатывает нажатие кнопки "Отзыв" в главном меню.
func (fh *FeedbackHandlerImpl) HandleMainFeedback(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Создаем message объект для handleFeedbackCommand
        message := &amp;tgbotapi.Message{
                Chat: callback.Message.Chat,
        }

        return fh.HandleFeedbackCommand(message, user)
}</span>

// sendMessage отправляет сообщение (deprecated - используйте messageFactory.SendText).
func (fh *FeedbackHandlerImpl) sendMessage(chatID int64, text string) error <span class="cov0" title="0">{
        return fh.base.messageFactory.SendText(chatID, text)
}</span>

// editFeedbackStatistics редактирует сообщение со статистикой отзывов.
func (fh *FeedbackHandlerImpl) editFeedbackStatistics(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Подсчитываем статистику
        <span class="cov0" title="0">activeCount := 0
        archivedCount := 0
        totalCount := len(allFeedbacks)

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := feedback["is_processed"].(bool); ok &amp;&amp; isArchived </span><span class="cov0" title="0">{
                        archivedCount++
                }</span> else<span class="cov0" title="0"> {
                        activeCount++
                }</span>
        }

        // Формируем текст
        <span class="cov0" title="0">text := "📊 Статистика отзывов:\n\n"
        text += fmt.Sprintf("🔥 Активные: %d\n", activeCount)
        text += fmt.Sprintf("📦 Обработанные: %d\n", archivedCount)
        text += fmt.Sprintf("📈 Всего: %d", totalCount)

        // Создаем клавиатуру
        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔥 Активные", "show_active_feedbacks"),
                        tgbotapi.NewInlineKeyboardButtonData("📦 Обработанные", "show_archive_feedbacks"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("📋 Все отзывы", "show_all_feedbacks"),
                ),
        )

        // Редактируем сообщение
        err = fh.base.messageFactory.EditWithKeyboard(chatID, messageID, text, &amp;keyboard)

        return err</span>
}

// showFeedbackStatistics показывает статистику отзывов.
func (fh *FeedbackHandlerImpl) showFeedbackStatistics(chatID int64, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        chatID,
                        "GetAllFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )

                return fh.sendMessage(chatID, "❌ Ошибка загрузки отзывов")
        }</span>

        // Подсчитываем статистику
        <span class="cov0" title="0">activeCount := 0
        archivedCount := 0
        totalCount := len(allFeedbacks)

        for _, fb := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := fb["is_processed"].(bool); ok &amp;&amp; isArchived </span><span class="cov0" title="0">{
                        archivedCount++
                }</span> else<span class="cov0" title="0"> {
                        activeCount++
                }</span>
        }

        // Формируем текст статистики
        <span class="cov0" title="0">text := "📊 Статистика отзывов:\n\n"
        text += fmt.Sprintf("🔥 Активные: %d\n", activeCount)
        text += fmt.Sprintf("📦 Обработанные: %d\n", archivedCount)
        text += fmt.Sprintf("📈 Всего: %d", totalCount)

        // Создаем клавиатуру управления отзывами
        keyboard := fh.base.keyboardBuilder.CreateFeedbackAdminKeyboard(user.InterfaceLanguageCode)

        // Используем MessageFactory для отправки сообщения
        return fh.base.messageFactory.SendWithKeyboard(chatID, text, keyboard)</span>
}

// editFeedbackWithNavigation обновляет существующее сообщение с отзывом.
func (fh *FeedbackHandlerImpl) editFeedbackWithNavigation(
        chatID int64,
        messageID int,
        feedbackList []map[string]interface{},
        currentIndex int,
        feedbackType string,
) error <span class="cov0" title="0">{
        if currentIndex &lt; 0 || currentIndex &gt;= len(feedbackList) </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Неверный индекс отзыва")
        }</span>

        <span class="cov0" title="0">feedback := feedbackList[currentIndex]

        // Формируем текст отзыва
        text := fh.formatFeedbackText(feedback, currentIndex+1, len(feedbackList))

        // Создаем клавиатуру навигации
        keyboard := fh.createNavigationKeyboard(currentIndex, len(feedbackList), feedbackType)

        err := fh.base.messageFactory.EditHTMLWithKeyboard(chatID, messageID, text, &amp;keyboard)

        return err</span>
}

// formatFeedbackText форматирует текст отзыва.
func (fh *FeedbackHandlerImpl) formatFeedbackText(feedback map[string]interface{}, currentNum, totalCount int) string <span class="cov0" title="0">{
        feedbackID := feedback["id"].(int)
        firstName := feedback["first_name"].(string)
        telegramID := feedback["telegram_id"].(int64)
        feedbackText := feedback["feedback_text"].(string)
        createdAt := feedback["created_at"].(time.Time)

        text := fmt.Sprintf("📝 &lt;b&gt;Отзыв #%d (%d из %d)&lt;/b&gt;\n\n", feedbackID, currentNum, totalCount)
        text += fmt.Sprintf("👤 &lt;b&gt;Имя:&lt;/b&gt; %s\n", firstName)
        text += fmt.Sprintf("🆔 &lt;b&gt;Telegram ID:&lt;/b&gt; %d\n", telegramID)

        // Добавляем username если есть
        if username, ok := feedback["username"].(string); ok &amp;&amp; username != "" </span><span class="cov0" title="0">{
                text += fmt.Sprintf("👤 &lt;b&gt;Username:&lt;/b&gt; @%s\n", username)
        }</span>

        <span class="cov0" title="0">text += fmt.Sprintf("📅 &lt;b&gt;Дата:&lt;/b&gt; %s\n\n", createdAt.Format("02.01.2006 15:04"))
        text += "💬 &lt;b&gt;Отзыв:&lt;/b&gt;\n" + feedbackText

        // Добавляем контактную информацию если есть
        if contactInfo, ok := feedback["contact_info"].(*string); ok &amp;&amp; contactInfo != nil </span><span class="cov0" title="0">{
                text += "\n\n📞 &lt;b&gt;Контакты:&lt;/b&gt; " + *contactInfo
        }</span>

        <span class="cov0" title="0">return text</span>
}

// createNavigationKeyboard создает клавиатуру навигации.
//
//nolint:funlen
func (fh *FeedbackHandlerImpl) createNavigationKeyboard(currentIndex, totalCount int, feedbackType string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttons []tgbotapi.InlineKeyboardButton

        // Кнопка "Предыдущий"
        if currentIndex &gt; 0 </span><span class="cov0" title="0">{
                buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                        "⬅️ Предыдущий",
                        fmt.Sprintf("nav_%s_feedback_%d", feedbackType, currentIndex-1),
                ))
        }</span>

        // Кнопка "Следующий"
        <span class="cov0" title="0">if currentIndex &lt; totalCount-1 </span><span class="cov0" title="0">{
                buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                        "➡️ Следующий",
                        fmt.Sprintf("nav_%s_feedback_%d", feedbackType, currentIndex+1),
                ))
        }</span>

        // Кнопка "В обработанные" (только для активных отзывов)
        <span class="cov0" title="0">if feedbackType == FeedbackTypeActiveLocal </span><span class="cov0" title="0">{
                buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                        "📦 В обработанные",
                        fmt.Sprintf("archive_feedback_%d", currentIndex),
                ))
        }</span>

        // Кнопки для архивных отзывов
        <span class="cov0" title="0">if feedbackType == FeedbackTypeArchiveLocal </span><span class="cov0" title="0">{
                buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                        "🔄 Вернуть в активные",
                        fmt.Sprintf("unarchive_feedback_%d", currentIndex),
                ))
                buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                        "🗑️ Удалить текущий",
                        fmt.Sprintf("delete_current_feedback_%d", currentIndex),
                ))
                buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                        "🗑️ Удалить все",
                        "delete_all_archive_feedbacks",
                ))
        }</span>

        // Кнопка "Назад к списку"
        <span class="cov0" title="0">buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                "📋 К списку",
                fmt.Sprintf("back_to_%s_feedbacks", feedbackType),
        ))

        // Кнопка "К статистике"
        buttons = append(buttons, tgbotapi.NewInlineKeyboardButtonData(
                "📊 К статистике",
                "back_to_feedback_stats",
        ))

        // Разбиваем кнопки на строки
        var rows [][]tgbotapi.InlineKeyboardButton

        if len(buttons) &gt; 0 </span><span class="cov0" title="0">{
                // Первая строка: навигация
                if len(buttons) &gt;= ButtonsPerRow </span><span class="cov0" title="0">{
                        rows = append(rows, []tgbotapi.InlineKeyboardButton{buttons[0], buttons[1]})
                        buttons = buttons[ButtonsPerRow:]
                }</span> else<span class="cov0" title="0"> if len(buttons) == 1 </span><span class="cov0" title="0">{
                        rows = append(rows, []tgbotapi.InlineKeyboardButton{buttons[0]})
                        buttons = buttons[1:]
                }</span>

                // Остальные кнопки
                <span class="cov0" title="0">for _, button := range buttons </span><span class="cov0" title="0">{
                        rows = append(rows, []tgbotapi.InlineKeyboardButton{button})
                }</span>
        }

        <span class="cov0" title="0">return tgbotapi.NewInlineKeyboardMarkup(rows...)</span>
}

// ========== Заглушки для интерфейса (будут реализованы позже) ==========

// HandleFeedbackMessage обрабатывает сообщение с отзывом.
func (fh *FeedbackHandlerImpl) HandleFeedbackMessage(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        feedbackText := message.Text

        // Проверяем валидность отзыва
        if len([]rune(feedbackText)) &lt; MinFeedbackLength </span><span class="cov0" title="0">{
                return fh.handleFeedbackTooShort(message, user)
        }</span>

        <span class="cov0" title="0">if len([]rune(feedbackText)) &gt; MaxFeedbackItems </span><span class="cov0" title="0">{
                return fh.handleFeedbackTooLong(message, user)
        }</span>

        // Проверяем наличие username
        <span class="cov0" title="0">if user.Username == "" </span><span class="cov0" title="0">{
                return fh.handleFeedbackContactRequest(message, user, feedbackText)
        }</span>

        // Логируем принятие отзыва
        <span class="cov0" title="0">fh.base.service.LoggingService.Telegram().InfoWithContext(
                "Feedback received",
                "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                int64(user.ID),
                message.Chat.ID,
                "HandleFeedbackMessage",
                map[string]interface{}{
                        "text_length":  len([]rune(feedbackText)),
                        "has_username": user.Username != "",
                        "username":     user.Username,
                },
        )

        // Сохраняем полный отзыв и отправляем уведомление
        return fh.handleFeedbackComplete(message, user, feedbackText, nil)</span>
}

// handleFeedbackTooShort обрабатывает слишком короткий отзыв.
func (fh *FeedbackHandlerImpl) handleFeedbackTooShort(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        feedbackText := message.Text
        count := len([]rune(feedbackText))

        errorText := fmt.Sprintf("%s\n\n%s",
                fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_too_short"),
                fh.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "feedback_char_count", map[string]string{
                        "count": strconv.Itoa(count),
                }),
        )

        return fh.sendMessage(message.Chat.ID, errorText)
}</span>

// handleFeedbackTooLong обрабатывает слишком длинный отзыв.
func (fh *FeedbackHandlerImpl) handleFeedbackTooLong(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        feedbackText := message.Text
        count := len([]rune(feedbackText))

        errorText := fmt.Sprintf("%s\n\n%s",
                fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_too_long"),
                fh.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "feedback_char_count", map[string]string{
                        "count": strconv.Itoa(count),
                }),
        )

        return fh.sendMessage(message.Chat.ID, errorText)
}</span>

// handleFeedbackContactRequest запрашивает контактные данные при отсутствии username.
func (fh *FeedbackHandlerImpl) handleFeedbackContactRequest(message *tgbotapi.Message, user *models.User, feedbackText string) error <span class="cov0" title="0">{
        // Сохраняем отзыв во временном хранилище (в будущем можно добавить в redis/кэш)
        // Пока просто переходим к следующему состоянию

        // Обновляем состояние для ожидания контактных данных
        err := fh.base.service.DB.UpdateUserState(user.ID, models.StateWaitingFeedbackContact)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запрашиваем контактные данные
        <span class="cov0" title="0">contactText := fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_contact_request")

        return fh.sendMessage(
                message.Chat.ID,
                contactText,
        )</span>
}

// handleFeedbackComplete завершает процесс обратной связи.
func (fh *FeedbackHandlerImpl) handleFeedbackComplete(message *tgbotapi.Message, user *models.User, feedbackText string, contactInfo *string) error <span class="cov0" title="0">{
        // Используем ID администраторов из обработчика
        adminIDs := fh.adminChatIDs

        // Сохраняем отзыв через сервис
        err := fh.base.service.SaveUserFeedback(user.ID, feedbackText, contactInfo, adminIDs)
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to save feedback",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        message.Chat.ID,
                        "SaveUserFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
                // Используем локализацию для ошибки
                errorText := fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_error_generic")
                if errorText == "feedback_error_generic" </span><span class="cov0" title="0">{ // fallback в случае отсутствия перевода
                        errorText = "❌ Произошла ошибка при сохранении отзыва. Попробуйте позже."
                }</span>

                <span class="cov0" title="0">return fh.sendMessage(message.Chat.ID, errorText)</span>
        }

        // Отправляем подтверждение пользователю
        <span class="cov0" title="0">successText := fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_saved")
        if successText == "feedback_saved" </span><span class="cov0" title="0">{ // fallback в случае отсутствия перевода
                successText = "✅ Спасибо за ваш отзыв! Мы обязательно его рассмотрим."
        }</span>

        // Возвращаем пользователя в активное состояние
        <span class="cov0" title="0">err = fh.base.service.DB.UpdateUserState(user.ID, models.StateActive)
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to update user state",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        message.Chat.ID,
                        "UpdateUserState",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">err = fh.base.service.DB.UpdateUserStatus(user.ID, models.StatusActive)
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to update user status",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        message.Chat.ID,
                        "UpdateUserStatus",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        // Создаем клавиатуру с кнопкой "Главное меню"
        <span class="cov0" title="0">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "main_menu_title"),
                                "back_to_main_menu",
                        ),
                ),
        )

        // Используем MessageFactory для отправки сообщения
        if err := fh.base.messageFactory.SendWithKeyboard(message.Chat.ID, successText, keyboard); err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to send success message",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        message.Chat.ID,
                        "SendMessage",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleFeedbackContactMessage обрабатывает сообщение с контактными данными.
func (fh *FeedbackHandlerImpl) HandleFeedbackContactMessage(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        contactInfo := strings.TrimSpace(message.Text)

        // Валидируем контактные данные
        if contactInfo == "" </span><span class="cov0" title="0">{
                return fh.sendMessage(message.Chat.ID,
                        fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_contact_placeholder"))
        }</span>

        // Подтверждаем получение контактов
        <span class="cov0" title="0">confirmedText := fh.base.service.Localizer.Get(user.InterfaceLanguageCode, "feedback_contact_provided")
        if err := fh.sendMessage(message.Chat.ID, confirmedText); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Теперь нужно получить сохраненный отзыв пользователя
        // Пока что используем временное решение - просим написать отзыв заново
        // В будущем здесь будет получение из кэша

        <span class="cov0" title="0">feedbackText := "Отзыв был сохранен в предыдущем шаге (требуется интеграция с кэшем)" // временное решение

        return fh.handleFeedbackComplete(message, user, feedbackText, &amp;contactInfo)</span>
}

// changeFeedbackStatus изменяет статус отзыва и отправляет подтверждение.
func (fh *FeedbackHandlerImpl) changeFeedbackStatus(callback *tgbotapi.CallbackQuery, user *models.User, feedbackID int, processed bool, confirmMsg string) error <span class="cov0" title="0">{
        // Обновляем статус отзыва
        err := fh.base.service.UpdateFeedbackStatus(feedbackID, processed)
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to update feedback status",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "UpdateFeedbackStatus",
                        map[string]interface{}{
                                "feedback_id": feedbackID,
                                "error":       err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка обновления статуса")
        }</span>

        // Используем MessageFactory для отправки HTML сообщения
        <span class="cov0" title="0">if err := fh.base.messageFactory.SendHTML(callback.Message.Chat.ID, confirmMsg); err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Telegram().ErrorWithContext(
                        "Failed to send status change confirmation",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "SendStatusChangeConfirmation",
                        map[string]interface{}{
                                "feedback_id": feedbackID,
                                "error":       err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processArchiveFeedbackAction обрабатывает действия над архивными отзывами.
//
//nolint:cyclop // функция содержит последовательную логику обработки, сложность оправдана
func (fh *FeedbackHandlerImpl) processArchiveFeedbackAction(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string, actionFunc func(int) error, successMessage string) error <span class="cov0" title="0">{
        // Получаем все обработанные отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Фильтруем только обработанные отзывы
        <span class="cov0" title="0">var archiveFeedbacks []map[string]interface{}

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isProcessed, ok := feedback["is_processed"].(bool); ok &amp;&amp; isProcessed </span><span class="cov0" title="0">{
                        archiveFeedbacks = append(archiveFeedbacks, feedback)
                }</span>
        }

        // Парсим индекс
        <span class="cov0" title="0">index, err := strconv.Atoi(indexStr)
        if err != nil || index &lt; 0 || index &gt;= len(archiveFeedbacks) </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Неверный индекс отзыва")
        }</span>

        // Получаем ID отзыва
        <span class="cov0" title="0">feedbackID := archiveFeedbacks[index]["id"].(int)

        // Выполняем действие
        err = actionFunc(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ "+err.Error())
        }</span>

        // Обновляем список (удаляем обработанный отзыв)
        <span class="cov0" title="0">archiveFeedbacks = append(archiveFeedbacks[:index], archiveFeedbacks[index+1:]...)

        // Показываем следующий отзыв или сообщение об отсутствии отзывов
        if len(archiveFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Редактируем сообщение
                text := successMessage
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                err = fh.base.messageFactory.EditWithKeyboard(callback.Message.Chat.ID, callback.Message.MessageID, text, &amp;keyboard)

                return err
        }</span>

        // Показываем следующий отзыв (или предыдущий, если это был последний)
        <span class="cov0" title="0">nextIndex := index
        if nextIndex &gt;= len(archiveFeedbacks) </span><span class="cov0" title="0">{
                nextIndex = len(archiveFeedbacks) - 1
        }</span>

        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                archiveFeedbacks,
                nextIndex,
                "archive",
        )</span>
}

// HandleFeedbackProcess обрабатывает отметку отзыва как обработанного.
func (fh *FeedbackHandlerImpl) HandleFeedbackProcess(callback *tgbotapi.CallbackQuery, user *models.User, feedbackIDStr string) error <span class="cov0" title="0">{
        feedbackID, err := strconv.Atoi(feedbackIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка идентификатора отзыва")
        }</span>

        <span class="cov0" title="0">confirmMsg := fmt.Sprintf("✅ Отзыв #%d отмечен как &lt;b&gt;обработанный&lt;/b&gt;", feedbackID)

        return fh.changeFeedbackStatus(callback, user, feedbackID, true, confirmMsg)</span>
}

// HandleFeedbackUnprocess возвращает отзыв в необработанные.
func (fh *FeedbackHandlerImpl) HandleFeedbackUnprocess(callback *tgbotapi.CallbackQuery, user *models.User, feedbackIDStr string) error <span class="cov0" title="0">{
        feedbackID, err := strconv.Atoi(feedbackIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка идентификатора отзыва")
        }</span>

        <span class="cov0" title="0">confirmMsg := fmt.Sprintf("🔄 Отзыв #%d возвращен в &lt;b&gt;обработку&lt;/b&gt;", feedbackID)

        return fh.changeFeedbackStatus(callback, user, feedbackID, false, confirmMsg)</span>
}

// HandleFeedbackDelete удаляет отзыв.
func (fh *FeedbackHandlerImpl) HandleFeedbackDelete(callback *tgbotapi.CallbackQuery, user *models.User, feedbackIDStr string) error <span class="cov0" title="0">{
        feedbackID, err := strconv.Atoi(feedbackIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка идентификатора отзыва")
        }</span>

        // Удаляем отзыв
        <span class="cov0" title="0">err = fh.base.service.DeleteFeedback(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to delete feedback",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "DeleteFeedback",
                        map[string]interface{}{
                                "feedback_id": feedbackID,
                                "error":       err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка удаления отзыва")
        }</span>

        // Используем MessageFactory для отправки HTML сообщения
        <span class="cov0" title="0">deleteMsg := fmt.Sprintf("🗑️ Отзыв #%d &lt;b&gt;удален&lt;/b&gt;", feedbackID)
        if err := fh.base.messageFactory.SendHTML(callback.Message.Chat.ID, deleteMsg); err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Telegram().ErrorWithContext(
                        "Failed to send deletion confirmation",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "SendDeletionConfirmation",
                        map[string]interface{}{
                                "feedback_id": feedbackID,
                                "error":       err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleShowActiveFeedbacks показывает активные отзывы.
func (fh *FeedbackHandlerImpl) HandleShowActiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        feedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "GetAllFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "📝 Отзывов пока нет")
        }</span>

        // Фильтруем только активные отзывы (не архивные)
        <span class="cov0" title="0">var activeFeedbacks []map[string]interface{}

        for _, fb := range feedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := fb["is_processed"].(bool); !ok || !isArchived </span><span class="cov0" title="0">{
                        activeFeedbacks = append(activeFeedbacks, fb)
                }</span>
        }

        <span class="cov0" title="0">if len(activeFeedbacks) == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "🎉 Все отзывы в архиве!")
        }</span>

        // Показываем первый отзыв с навигацией (редактируем существующее сообщение)
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(callback.Message.Chat.ID, callback.Message.MessageID, activeFeedbacks, 0, "active")</span>
}

// HandleShowArchiveFeedbacks показывает архивные отзывы.
func (fh *FeedbackHandlerImpl) HandleShowArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        feedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "GetAllFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "📝 Отзывов пока нет")
        }</span>

        // Фильтруем только архивные отзывы
        <span class="cov0" title="0">var archivedFeedbacks []map[string]interface{}

        for _, fb := range feedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := fb["is_processed"].(bool); ok &amp;&amp; isArchived </span><span class="cov0" title="0">{
                        archivedFeedbacks = append(archivedFeedbacks, fb)
                }</span>
        }

        <span class="cov0" title="0">if len(archivedFeedbacks) == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "📦 Архив пуст")
        }</span>

        // Показываем первый отзыв с навигацией (редактируем существующее сообщение)
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(callback.Message.Chat.ID, callback.Message.MessageID, archivedFeedbacks, 0, "archive")</span>
}

// HandleShowAllFeedbacks показывает все отзывы.
func (fh *FeedbackHandlerImpl) HandleShowAllFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        feedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "GetAllFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "📝 Отзывов пока нет")
        }</span>

        // Показываем первый отзыв с навигацией (редактируем существующее сообщение)
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                feedbacks,
                0,
                "all",
        )</span>
}

// HandleBrowseActiveFeedbacks просматривает активные отзывы.
func (fh *FeedbackHandlerImpl) HandleBrowseActiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        return fh.handleBrowseFeedbacks(callback, user, indexStr, "active")
}</span>

// HandleBrowseArchiveFeedbacks просматривает архивные отзывы.
func (fh *FeedbackHandlerImpl) HandleBrowseArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        return fh.handleBrowseFeedbacks(callback, user, indexStr, "archive")
}</span>

// HandleBrowseAllFeedbacks просматривает все отзывы.
func (fh *FeedbackHandlerImpl) HandleBrowseAllFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        return fh.handleBrowseFeedbacks(callback, user, indexStr, "all")
}</span>

// handleBrowseFeedbacks общая функция для навигации по отзывам.
func (fh *FeedbackHandlerImpl) handleBrowseFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string, feedbackType string) error <span class="cov0" title="0">{
        // Парсим индекс
        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка в параметрах")
        }</span>

        // Получаем все отзывы
        <span class="cov0" title="0">allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "GetAllFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        // Фильтруем отзывы по типу
        <span class="cov0" title="0">var feedbacks []map[string]interface{}

        switch feedbackType </span>{
        case "active":<span class="cov0" title="0">
                for _, fb := range allFeedbacks </span><span class="cov0" title="0">{
                        if isArchived, ok := fb["is_processed"].(bool); !ok || !isArchived </span><span class="cov0" title="0">{
                                feedbacks = append(feedbacks, fb)
                        }</span>
                }
        case "archive":<span class="cov0" title="0">
                for _, fb := range allFeedbacks </span><span class="cov0" title="0">{
                        if isArchived, ok := fb["is_processed"].(bool); ok &amp;&amp; isArchived </span><span class="cov0" title="0">{
                                feedbacks = append(feedbacks, fb)
                        }</span>
                }
        case "all":<span class="cov0" title="0">
                feedbacks = allFeedbacks</span>
        }

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "📝 Отзывов нет")
        }</span>

        <span class="cov0" title="0">if index &lt; 0 || index &gt;= len(feedbacks) </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Неверный индекс отзыва")
        }</span>

        // Показываем отзыв с навигацией (редактируем существующее сообщение)
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                feedbacks,
                index,
                feedbackType,
        )</span>
}

// HandleNavigateFeedback обрабатывает навигацию по отзывам.
func (fh *FeedbackHandlerImpl) HandleNavigateFeedback(callback *tgbotapi.CallbackQuery, user *models.User, feedbackType string, indexStr string) error <span class="cov0" title="0">{
        return fh.handleBrowseFeedbacks(callback, user, indexStr, feedbackType)
}</span>

// HandleArchiveFeedback архивирует отзыв.
//
//nolint:cyclop,funlen // функция содержит последовательную логику архивирования, длина оправдана
func (fh *FeedbackHandlerImpl) HandleArchiveFeedback(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        // Получаем все активные отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get feedbacks",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "GetAllFeedback",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов")
        }</span>

        // Фильтруем активные отзывы
        <span class="cov0" title="0">var activeFeedbacks []map[string]interface{}

        for _, fb := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := fb["is_processed"].(bool); !ok || !isArchived </span><span class="cov0" title="0">{
                        activeFeedbacks = append(activeFeedbacks, fb)
                }</span>
        }

        // Парсим индекс
        <span class="cov0" title="0">index, err := strconv.Atoi(indexStr)
        if err != nil || index &lt; 0 || index &gt;= len(activeFeedbacks) </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Неверный индекс отзыва")
        }</span>

        // Получаем ID отзыва для архивирования
        <span class="cov0" title="0">feedback := activeFeedbacks[index]
        feedbackID := feedback["id"].(int)

        // Архивируем отзыв
        err = fh.base.service.ArchiveFeedback(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                // Используем структурированное логирование
                fh.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to archive feedback",
                        "req_"+strconv.FormatInt(time.Now().UnixNano(), 10),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "ArchiveFeedback",
                        map[string]interface{}{
                                "feedback_id": feedbackID,
                                "error":       err.Error(),
                        },
                )

                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка архивирования отзыва")
        }</span>

        // Обновляем список активных отзывов
        <span class="cov0" title="0">activeFeedbacks = append(activeFeedbacks[:index], activeFeedbacks[index+1:]...)

        // Показываем следующий отзыв или сообщение об отсутствии отзывов
        if len(activeFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Редактируем сообщение, показывая что все отзывы обработаны
                text := "✅ Отзыв обработан!\n\n🎉 Все отзывы обработаны!"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                err = fh.base.messageFactory.EditWithKeyboard(callback.Message.Chat.ID, callback.Message.MessageID, text, &amp;keyboard)

                return err
        }</span>

        // Показываем следующий отзыв (или предыдущий, если это был последний)
        <span class="cov0" title="0">nextIndex := index
        if nextIndex &gt;= len(activeFeedbacks) </span><span class="cov0" title="0">{
                nextIndex = len(activeFeedbacks) - 1
        }</span>

        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(callback.Message.Chat.ID, callback.Message.MessageID, activeFeedbacks, nextIndex, "active")</span>
}

// HandleBackToFeedbacks возвращает к списку отзывов.
func (fh *FeedbackHandlerImpl) HandleBackToFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User, feedbackType string) error <span class="cov0" title="0">{
        switch feedbackType </span>{
        case "active":<span class="cov0" title="0">
                return fh.editActiveFeedbacksList(callback.Message.Chat.ID, callback.Message.MessageID, user)</span>
        case "archive":<span class="cov0" title="0">
                return fh.editArchiveFeedbacksList(callback.Message.Chat.ID, callback.Message.MessageID, user)</span>
        case "all":<span class="cov0" title="0">
                return fh.editAllFeedbacksList(callback.Message.Chat.ID, callback.Message.MessageID, user)</span>
        default:<span class="cov0" title="0">
                return fh.editFeedbackStatistics(callback.Message.Chat.ID, callback.Message.MessageID, user)</span>
        }
}

// HandleBackToFeedbackStats возвращает к статистике отзывов.
func (fh *FeedbackHandlerImpl) HandleBackToFeedbackStats(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        return fh.editFeedbackStatistics(callback.Message.Chat.ID, callback.Message.MessageID, user)
}</span>

// editActiveFeedbacks редактирует сообщение со списком активных отзывов.
func (fh *FeedbackHandlerImpl) editActiveFeedbacks(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Фильтруем только активные отзывы
        <span class="cov0" title="0">var activeFeedbacks []map[string]interface{}

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := feedback["is_processed"].(bool); !ok || !isArchived </span><span class="cov0" title="0">{
                        activeFeedbacks = append(activeFeedbacks, feedback)
                }</span>
        }

        // Проверяем, есть ли активные отзывы
        <span class="cov0" title="0">if len(activeFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Показываем сообщение об отсутствии активных отзывов
                text := "🎉 Все отзывы обработаны!"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                editMsg := tgbotapi.NewEditMessageText(chatID, messageID, text)
                editMsg.ReplyMarkup = &amp;keyboard
                _, err := fh.base.bot.Send(editMsg)

                return err
        }</span>

        // Показываем первый отзыв с навигацией
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(chatID, messageID, activeFeedbacks, 0, "active")</span>
}

// editArchiveFeedbacks редактирует сообщение со списком обработанных отзывов.
func (fh *FeedbackHandlerImpl) editArchiveFeedbacks(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Фильтруем только обработанные отзывы
        <span class="cov0" title="0">var archiveFeedbacks []map[string]interface{}

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := feedback["is_processed"].(bool); ok &amp;&amp; isArchived </span><span class="cov0" title="0">{
                        archiveFeedbacks = append(archiveFeedbacks, feedback)
                }</span>
        }

        // Проверяем, есть ли обработанные отзывы
        <span class="cov0" title="0">if len(archiveFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Показываем сообщение об отсутствии обработанных отзывов
                text := "📦 Обработанных отзывов пока нет"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                editMsg := tgbotapi.NewEditMessageText(chatID, messageID, text)
                editMsg.ReplyMarkup = &amp;keyboard
                _, err := fh.base.bot.Send(editMsg)

                return err
        }</span>

        // Показываем первый отзыв с навигацией
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(chatID, messageID, archiveFeedbacks, 0, "archive")</span>
}

// editAllFeedbacks редактирует сообщение со списком всех отзывов.
func (fh *FeedbackHandlerImpl) editAllFeedbacks(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Проверяем, есть ли отзывы
        <span class="cov0" title="0">if len(allFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Показываем сообщение об отсутствии отзывов
                text := "📝 Отзывов пока нет"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                editMsg := tgbotapi.NewEditMessageText(chatID, messageID, text)
                editMsg.ReplyMarkup = &amp;keyboard
                _, err := fh.base.bot.Send(editMsg)

                return err
        }</span>

        // Показываем первый отзыв с навигацией
        <span class="cov0" title="0">return fh.editFeedbackWithNavigation(chatID, messageID, allFeedbacks, 0, "all")</span>
}

// editActiveFeedbacksList редактирует сообщение со списком активных отзывов (заголовок).
func (fh *FeedbackHandlerImpl) editActiveFeedbacksList(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Фильтруем только активные отзывы
        <span class="cov0" title="0">var activeFeedbacks []map[string]interface{}

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := feedback["is_processed"].(bool); !ok || !isArchived </span><span class="cov0" title="0">{
                        activeFeedbacks = append(activeFeedbacks, feedback)
                }</span>
        }

        // Проверяем, есть ли активные отзывы
        <span class="cov0" title="0">if len(activeFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Показываем сообщение об отсутствии активных отзывов
                text := "🎉 Все отзывы обработаны!"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                sendErr := fh.base.messageFactory.EditWithKeyboard(chatID, messageID, text, &amp;keyboard)

                return sendErr
        }</span>

        // Показываем заголовок списка активных отзывов
        <span class="cov0" title="0">text := fmt.Sprintf("🔥 &lt;b&gt;Активные отзывы (%d):&lt;/b&gt;\n\nВыберите отзыв для просмотра:", len(activeFeedbacks))

        // Создаем клавиатуру с кнопками для каждого отзыва
        rows := make([][]tgbotapi.InlineKeyboardButton, 0, len(activeFeedbacks))

        for i, feedback := range activeFeedbacks </span><span class="cov0" title="0">{
                feedbackID := feedback["id"].(int)
                firstName := feedback["first_name"].(string)

                buttonText := fmt.Sprintf("📝 %s (ID: %d)", firstName, feedbackID)
                if username, ok := feedback["username"].(string); ok &amp;&amp; username != "" </span><span class="cov0" title="0">{
                        buttonText = fmt.Sprintf("📝 %s (@%s) (ID: %d)", firstName, username, feedbackID)
                }</span>

                <span class="cov0" title="0">buttonData := fmt.Sprintf("nav_active_feedback_%d", i)

                rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(buttonText, buttonData),
                ))</span>
        }

        // Добавляем кнопки навигации
        <span class="cov0" title="0">rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
        ))

        keyboard := tgbotapi.NewInlineKeyboardMarkup(rows...)

        err = fh.base.messageFactory.EditHTMLWithKeyboard(chatID, messageID, text, &amp;keyboard)

        return err</span>
}

// editArchiveFeedbacksList редактирует сообщение со списком обработанных отзывов (заголовок).
func (fh *FeedbackHandlerImpl) editArchiveFeedbacksList(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Фильтруем только обработанные отзывы
        <span class="cov0" title="0">var archiveFeedbacks []map[string]interface{}

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isArchived, ok := feedback["is_processed"].(bool); ok &amp;&amp; isArchived </span><span class="cov0" title="0">{
                        archiveFeedbacks = append(archiveFeedbacks, feedback)
                }</span>
        }

        // Проверяем, есть ли обработанные отзывы
        <span class="cov0" title="0">if len(archiveFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Показываем сообщение об отсутствии обработанных отзывов
                text := "📦 Обработанных отзывов пока нет"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                sendErr := fh.base.messageFactory.EditWithKeyboard(chatID, messageID, text, &amp;keyboard)

                return sendErr
        }</span>

        // Показываем заголовок списка обработанных отзывов
        <span class="cov0" title="0">text := fmt.Sprintf("📦 &lt;b&gt;Обработанные отзывы (%d):&lt;/b&gt;\n\nВыберите отзыв для просмотра:", len(archiveFeedbacks))

        // Создаем клавиатуру с кнопками для каждого отзыва
        rows := make([][]tgbotapi.InlineKeyboardButton, 0, len(archiveFeedbacks))

        for i, feedback := range archiveFeedbacks </span><span class="cov0" title="0">{
                feedbackID := feedback["id"].(int)
                firstName := feedback["first_name"].(string)

                buttonText := fmt.Sprintf("📝 %s (ID: %d)", firstName, feedbackID)
                if username, ok := feedback["username"].(string); ok &amp;&amp; username != "" </span><span class="cov0" title="0">{
                        buttonText = fmt.Sprintf("📝 %s (@%s) (ID: %d)", firstName, username, feedbackID)
                }</span>

                <span class="cov0" title="0">buttonData := fmt.Sprintf("nav_archive_feedback_%d", i)

                rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(buttonText, buttonData),
                ))</span>
        }

        // Добавляем кнопки навигации
        <span class="cov0" title="0">rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
        ))

        keyboard := tgbotapi.NewInlineKeyboardMarkup(rows...)

        err = fh.base.messageFactory.EditHTMLWithKeyboard(chatID, messageID, text, &amp;keyboard)

        return err</span>
}

// editAllFeedbacksList редактирует сообщение со списком всех отзывов (заголовок).
func (fh *FeedbackHandlerImpl) editAllFeedbacksList(chatID int64, messageID int, user *models.User) error <span class="cov0" title="0">{
        // Получаем все отзывы
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(chatID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Проверяем, есть ли отзывы
        <span class="cov0" title="0">if len(allFeedbacks) == 0 </span><span class="cov0" title="0">{
                // Показываем сообщение об отсутствии отзывов
                text := "📝 Отзывов пока нет"
                keyboard := tgbotapi.NewInlineKeyboardMarkup(
                        tgbotapi.NewInlineKeyboardRow(
                                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                        ),
                )

                sendErr := fh.base.messageFactory.EditWithKeyboard(chatID, messageID, text, &amp;keyboard)

                return sendErr
        }</span>

        // Показываем заголовок списка всех отзывов
        <span class="cov0" title="0">text := fmt.Sprintf("📋 &lt;b&gt;Все отзывы (%d):&lt;/b&gt;\n\nВыберите отзыв для просмотра:", len(allFeedbacks))

        // Создаем клавиатуру с кнопками для каждого отзыва
        rows := make([][]tgbotapi.InlineKeyboardButton, 0, len(allFeedbacks))

        for i, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                feedbackID := feedback["id"].(int)
                firstName := feedback["first_name"].(string)
                isProcessed := feedback["is_processed"].(bool)

                status := "🔥"
                if isProcessed </span><span class="cov0" title="0">{
                        status = "📦"
                }</span>

                <span class="cov0" title="0">buttonText := fmt.Sprintf("%s %s (ID: %d)", status, firstName, feedbackID)
                if username, ok := feedback["username"].(string); ok &amp;&amp; username != "" </span><span class="cov0" title="0">{
                        buttonText = fmt.Sprintf("%s %s (@%s) (ID: %d)", status, firstName, username, feedbackID)
                }</span>

                <span class="cov0" title="0">buttonData := fmt.Sprintf("nav_all_feedback_%d", i)

                rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(buttonText, buttonData),
                ))</span>
        }

        // Добавляем кнопки навигации
        <span class="cov0" title="0">rows = append(rows, tgbotapi.NewInlineKeyboardRow(
                tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
        ))

        keyboard := tgbotapi.NewInlineKeyboardMarkup(rows...)

        err = fh.base.messageFactory.EditHTMLWithKeyboard(chatID, messageID, text, &amp;keyboard)

        return err</span>
}

// HandleDeleteCurrentFeedback удаляет текущий отзыв.
func (fh *FeedbackHandlerImpl) HandleDeleteCurrentFeedback(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        return fh.processArchiveFeedbackAction(
                callback,
                user,
                indexStr,
                fh.base.service.DeleteFeedback,
                "✅ Отзыв удален!\n\n🎉 Все обработанные отзывы удалены!",
        )
}</span>

// HandleDeleteAllArchiveFeedbacks показывает подтверждение удаления всех обработанных отзывов.
func (fh *FeedbackHandlerImpl) HandleDeleteAllArchiveFeedbacks(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем количество обработанных отзывов
        allFeedbacks, err := fh.base.service.GetAllFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка получения отзывов: "+err.Error())
        }</span>

        // Подсчитываем обработанные отзывы
        <span class="cov0" title="0">processedCount := 0

        for _, feedback := range allFeedbacks </span><span class="cov0" title="0">{
                if isProcessed, ok := feedback["is_processed"].(bool); ok &amp;&amp; isProcessed </span><span class="cov0" title="0">{
                        processedCount++
                }</span>
        }

        <span class="cov0" title="0">if processedCount == 0 </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "📦 Нет обработанных отзывов для удаления")
        }</span>

        // Показываем подтверждение
        <span class="cov0" title="0">text := fmt.Sprintf("⚠️ &lt;b&gt;Подтверждение удаления&lt;/b&gt;\n\nВы действительно хотите удалить &lt;b&gt;%d обработанных отзывов&lt;/b&gt;?\n\n❗️ &lt;b&gt;Это действие нельзя отменить!&lt;/b&gt;", processedCount)

        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("✅ Да, удалить все", "confirm_delete_all_archive"),
                        tgbotapi.NewInlineKeyboardButtonData("❌ Отмена", "back_to_archive_feedbacks"),
                ),
        )

        err = fh.base.messageFactory.EditHTMLWithKeyboard(callback.Message.Chat.ID, callback.Message.MessageID, text, &amp;keyboard)

        return err</span>
}

// HandleConfirmDeleteAllArchive подтверждает и выполняет удаление всех обработанных отзывов.
func (fh *FeedbackHandlerImpl) HandleConfirmDeleteAllArchive(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Удаляем все обработанные отзывы
        deletedCount, err := fh.base.service.DeleteAllProcessedFeedbacks()
        if err != nil </span><span class="cov0" title="0">{
                return fh.sendMessage(callback.Message.Chat.ID, "❌ Ошибка удаления отзывов: "+err.Error())
        }</span>

        // Показываем результат
        <span class="cov0" title="0">text := fmt.Sprintf("✅ &lt;b&gt;Удаление завершено!&lt;/b&gt;\n\n🗑️ Удалено отзывов: &lt;b&gt;%d&lt;/b&gt;\n\n📊 Все обработанные отзывы удалены из базы данных.", deletedCount)

        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("📊 К статистике", "back_to_feedback_stats"),
                ),
        )

        err = fh.base.messageFactory.EditHTMLWithKeyboard(callback.Message.Chat.ID, callback.Message.MessageID, text, &amp;keyboard)

        return err</span>
}

// HandleUnarchiveFeedback возвращает отзыв в активные.
func (fh *FeedbackHandlerImpl) HandleUnarchiveFeedback(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string) error <span class="cov0" title="0">{
        return fh.processArchiveFeedbackAction(
                callback,
                user,
                indexStr,
                fh.base.service.UnarchiveFeedback,
                "✅ Отзыв возвращен в активные!\n\n🎉 Все обработанные отзывы возвращены!",
        )
}</span>

// HandleFeedbackPrev переходит к предыдущему отзыву.
func (fh *FeedbackHandlerImpl) HandleFeedbackPrev(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string, feedbackType string) error <span class="cov0" title="0">{
        // TODO: Реализовать позже - навигация назад
        return fh.sendMessage(callback.Message.Chat.ID, "⬅️ Предыдущий отзыв (в разработке)")
}</span>

// HandleFeedbackNext переходит к следующему отзыву.
func (fh *FeedbackHandlerImpl) HandleFeedbackNext(callback *tgbotapi.CallbackQuery, user *models.User, indexStr string, feedbackType string) error <span class="cov0" title="0">{
        // TODO: Реализовать позже - навигация вперед
        return fh.sendMessage(callback.Message.Chat.ID, "➡️ Следующий отзыв (в разработке)")
}</span>

// HandleFeedbackBack возвращается к списку отзывов.
func (fh *FeedbackHandlerImpl) HandleFeedbackBack(callback *tgbotapi.CallbackQuery, user *models.User, feedbackType string) error <span class="cov0" title="0">{
        // TODO: Реализовать позже - возврат к списку
        return fh.sendMessage(callback.Message.Chat.ID, "🔙 Назад к списку (в разработке)")
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "fmt"
        "time"
)

// generateRequestID создает уникальный request ID для логирования.
func generateRequestID(operation string) string <span class="cov0" title="0">{
        return fmt.Sprintf("req_%d_%s", time.Now().UnixNano(), operation)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "math"
        "strconv"
        "strings"
        "sync"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для работы с профилем.

// Константы для сообщений.
const (
        MessageChooseAtLeastOneInterest = "choose_at_least_one_interest"
)

// TemporaryInterestStorage временное хранилище выборов пользователей.
type TemporaryInterestStorage struct {
        mu      sync.RWMutex
        storage map[int][]TemporaryInterestSelection // userID -&gt; selections
}

// NewTemporaryInterestStorage создает новое временное хранилище.
func NewTemporaryInterestStorage() *TemporaryInterestStorage <span class="cov0" title="0">{
        return &amp;TemporaryInterestStorage{
                storage: make(map[int][]TemporaryInterestSelection),
        }
}</span>

// AddInterest добавляет интерес во временное хранилище.
func (s *TemporaryInterestStorage) AddInterest(userID, interestID int, isPrimary bool) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Проверяем, не выбран ли уже этот интерес
        for i, selection := range s.storage[userID] </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        // Обновляем существующий выбор
                        s.storage[userID][i].IsPrimary = isPrimary

                        return
                }</span>
        }

        // Добавляем новый выбор
        <span class="cov0" title="0">nextOrder := len(s.storage[userID]) + 1
        selection := TemporaryInterestSelection{
                InterestID:     interestID,
                IsPrimary:      isPrimary,
                SelectionOrder: nextOrder,
        }
        s.storage[userID] = append(s.storage[userID], selection)</span>
}

// RemoveInterest удаляет интерес из временного хранилища.
func (s *TemporaryInterestStorage) RemoveInterest(userID, interestID int) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        selections := s.storage[userID]
        for i, selection := range selections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        // Удаляем из слайса
                        s.storage[userID] = append(selections[:i], selections[i+1:]...)

                        return
                }</span>
        }
}

// ToggleInterest переключает выбор интереса.
func (s *TemporaryInterestStorage) ToggleInterest(userID, interestID int) bool <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        selections := s.storage[userID]
        for i, selection := range selections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        // Удаляем из временного хранилища
                        s.storage[userID] = append(selections[:i], selections[i+1:]...)

                        return false // был выбран, теперь не выбран
                }</span>
        }

        // Добавляем в временное хранилище
        <span class="cov0" title="0">nextOrder := len(selections) + 1
        selection := TemporaryInterestSelection{
                InterestID:     interestID,
                IsPrimary:      false, // по умолчанию не основной
                SelectionOrder: nextOrder,
        }
        s.storage[userID] = append(s.storage[userID], selection)

        return true</span> // теперь выбран
}

// TogglePrimary переключает статус основного интереса.
func (s *TemporaryInterestStorage) TogglePrimary(userID, interestID int) bool <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        selections := s.storage[userID]
        for i, selection := range selections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        // Переключаем статус
                        s.storage[userID][i].IsPrimary = !selection.IsPrimary

                        return s.storage[userID][i].IsPrimary
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// GetSelections возвращает выборы пользователя.
func (s *TemporaryInterestStorage) GetSelections(userID int) []TemporaryInterestSelection <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        return s.storage[userID]
}</span>

// GetSelectedInterests возвращает ID выбранных интересов.
func (s *TemporaryInterestStorage) GetSelectedInterests(userID int) []int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        selected := make([]int, 0, len(s.storage[userID]))
        for _, selection := range s.storage[userID] </span><span class="cov0" title="0">{
                selected = append(selected, selection.InterestID)
        }</span>

        <span class="cov0" title="0">return selected</span>
}

// GetPrimaryInterests возвращает ID основных интересов.
func (s *TemporaryInterestStorage) GetPrimaryInterests(userID int) []int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var primary []int

        for _, selection := range s.storage[userID] </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        primary = append(primary, selection.InterestID)
                }</span>
        }

        <span class="cov0" title="0">return primary</span>
}

// ClearSelections очищает выборы пользователя.
func (s *TemporaryInterestStorage) ClearSelections(userID int) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        delete(s.storage, userID)
}</span>

// SaveToDatabase сохраняет выборы в базу данных.
func (s *TemporaryInterestStorage) SaveToDatabase(userID int, interestService *core.InterestService) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        selections := s.storage[userID]
        if len(selections) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Сначала удаляем все существующие выборы пользователя
        // (это делается в рамках транзакции в InterestService)

        // Добавляем новые выборы
        <span class="cov0" title="0">for _, selection := range selections </span><span class="cov0" title="0">{
                err := interestService.AddUserInterestSelection(userID, selection.InterestID, selection.IsPrimary)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Очищаем временное хранилище после успешного сохранения
        <span class="cov0" title="0">delete(s.storage, userID)

        return nil</span>
}

// ImprovedInterestHandler улучшенный обработчик с временным хранением.
type ImprovedInterestHandler struct {
        service         *core.BotService
        interestService *core.InterestService
        bot             *tgbotapi.BotAPI
        keyboardBuilder *KeyboardBuilder
        errorHandler    *errors.ErrorHandler
        tempStorage     *TemporaryInterestStorage
}

// NewImprovedInterestHandler создает улучшенный обработчик.
func NewImprovedInterestHandler(
        service *core.BotService,
        interestService *core.InterestService,
        bot *tgbotapi.BotAPI,
        keyboardBuilder *KeyboardBuilder,
        errorHandler *errors.ErrorHandler,
) *ImprovedInterestHandler <span class="cov0" title="0">{
        return &amp;ImprovedInterestHandler{
                service:         service,
                interestService: interestService,
                bot:             bot,
                keyboardBuilder: keyboardBuilder,
                errorHandler:    errorHandler,
                tempStorage:     NewTemporaryInterestStorage(),
        }
}</span>

// HandleInterestCategorySelection обрабатывает выбор категории.
func (h *ImprovedInterestHandler) HandleInterestCategorySelection(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        // Получаем категории
        categories, err := h.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategories")
        }</span>

        // Находим выбранную категорию
        <span class="cov0" title="0">var selectedCategory *models.InterestCategory

        for _, category := range categories </span><span class="cov0" title="0">{
                if category.KeyName == categoryKey </span><span class="cov0" title="0">{
                        selectedCategory = &amp;category

                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedCategory == nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "CategoryNotFound")
        }</span>

        // Получаем интересы в категории
        <span class="cov0" title="0">interests, err := h.interestService.GetInterestsByCategory(selectedCategory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategory")
        }</span>

        // Получаем временные выборы пользователя
        <span class="cov0" title="0">tempSelections := h.tempStorage.GetSelections(user.ID)

        selectedMap := make(map[int]bool)
        for _, selection := range tempSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем клавиатуру
        <span class="cov0" title="0">keyboard := h.keyboardBuilder.CreateCategoryInterestsKeyboard(
                interests,
                selectedMap,
                selectedCategory.KeyName,
                user.InterfaceLanguageCode,
        )

        // Создаем текст сообщения
        categoryName := h.service.Localizer.Get(user.InterfaceLanguageCode, "category_"+categoryKey)
        messageText := categoryName + " - " + h.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChooseInterests)

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.bot.Request(editMsg)

        return err</span>
}

// HandleInterestSelection обрабатывает выбор интереса (только во временном хранилище).
func (h *ImprovedInterestHandler) HandleInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        // Переключаем выбор во временном хранилище
        <span class="cov0" title="0">isSelected := h.tempStorage.ToggleInterest(user.ID, interestID)

        h.service.LoggingService.Telegram().InfoWithContext(
                "User toggled interest",
                generateRequestID("HandleInterestSelection"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleInterestSelection",
                map[string]interface{}{"userID": user.ID, "interestID": interestID, "isSelected": isSelected},
        )

        // Обновляем клавиатуру (получаем categoryKey из callback data)
        // В реальной реализации нужно извлекать categoryKey из контекста
        return h.updateCategoryInterestsKeyboard(
                callback,
                user,
                "entertainment",
        )</span> // упрощенно
}

// HandlePrimaryInterestSelection обрабатывает выбор основного интереса.
func (h *ImprovedInterestHandler) HandlePrimaryInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        // Переключаем статус основного во временном хранилище
        <span class="cov0" title="0">isPrimary := h.tempStorage.TogglePrimary(user.ID, interestID)

        h.service.LoggingService.Telegram().InfoWithContext(
                "User toggled primary status for interest",
                generateRequestID("HandlePrimaryInterestSelection"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandlePrimaryInterestSelection",
                map[string]interface{}{"userID": user.ID, "interestID": interestID, "isPrimary": isPrimary},
        )

        // Обновляем клавиатуру выбора основных интересов
        return h.updatePrimaryInterestsKeyboard(callback, user)</span>
}

// HandleInterestsContinue обрабатывает продолжение после выбора интересов.
func (h *ImprovedInterestHandler) HandleInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем временные выборы
        selectedInterests := h.tempStorage.GetSelectedInterests(user.ID)

        // Проверяем, выбраны ли интересы
        if len(selectedInterests) == 0 </span><span class="cov0" title="0">{
                warningMsg := "❗ " + h.service.Localizer.Get(user.InterfaceLanguageCode, MessageChooseAtLeastOneInterest)
                if warningMsg == MessageChooseAtLeastOneInterest </span><span class="cov0" title="0">{
                        warningMsg = "❗ Пожалуйста, выберите хотя бы один интерес"
                }</span>

                // Показываем предупреждение и возвращаем к категориям
                <span class="cov0" title="0">keyboard := h.keyboardBuilder.CreateInterestCategoriesKeyboard(user.InterfaceLanguageCode)
                editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        warningMsg+"\n\n"+h.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChooseInterests),
                        keyboard,
                )
                _, err := h.bot.Request(editMsg)

                return err</span>
        }

        // Получаем конфигурацию лимитов
        <span class="cov0" title="0">limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestLimitsConfig")
        }</span>

        // Получаем общее количество интересов в системе
        <span class="cov0" title="0">allInterests, err := h.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetAllInterests")
        }</span>

        // Вычисляем рекомендуемое количество основных интересов
        <span class="cov0" title="0">totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(math.Ceil(float64(totalInterestsInSystem) * limits.PrimaryPercentage))

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MinPrimaryInterests
        }</span>

        <span class="cov0" title="0">if recommendedPrimary &gt; limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MaxPrimaryInterests
        }</span>

        // Если выбранных интересов меньше или равно максимальному количеству основных,
        // то сразу делаем их все основными
        <span class="cov0" title="0">if len(selectedInterests) &lt;= recommendedPrimary </span><span class="cov0" title="0">{
                // Делаем все выбранные интересы основными во временном хранилище
                for _, interestID := range selectedInterests </span><span class="cov0" title="0">{
                        // Сначала проверяем, не является ли уже основным
                        selections := h.tempStorage.GetSelections(user.ID)
                        for _, selection := range selections </span><span class="cov0" title="0">{
                                if selection.InterestID == interestID &amp;&amp; !selection.IsPrimary </span><span class="cov0" title="0">{
                                        // Переключаем на основной
                                        h.tempStorage.TogglePrimary(user.ID, interestID)
                                }</span>
                        }
                }

                // Сохраняем в базу данных
                <span class="cov0" title="0">err = h.tempStorage.SaveToDatabase(user.ID, h.interestService)
                if err != nil </span><span class="cov0" title="0">{
                        return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "SaveToDatabase")
                }</span>

                // Завершаем настройку профиля
                <span class="cov0" title="0">return h.completeProfileSetup(callback, user)</span>
        }

        // Переходим к выбору основных интересов
        <span class="cov0" title="0">return h.showPrimaryInterestsSelection(callback, user)</span>
}

// HandlePrimaryInterestsContinue обрабатывает завершение выбора основных интересов.
func (h *ImprovedInterestHandler) HandlePrimaryInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем временные выборы
        tempSelections := h.tempStorage.GetSelections(user.ID)
        primaryCount := len(h.tempStorage.GetPrimaryInterests(user.ID))

        // Получаем конфигурацию лимитов
        limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestLimitsConfig")
        }</span>

        // Проверяем минимальное количество основных интересов
        <span class="cov0" title="0">if primaryCount &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                warningMsg := h.service.Localizer.Get(user.InterfaceLanguageCode, "choose_at_least_primary_interests")
                if warningMsg == "choose_at_least_primary_interests" </span><span class="cov0" title="0">{
                        warningMsg = "❗ Пожалуйста, выберите минимум " + strconv.Itoa(limits.MinPrimaryInterests) + " основных интереса"
                }</span>

                // Показываем предупреждение
                <span class="cov0" title="0">editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        warningMsg+"\n\n"+h.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests"),
                        h.keyboardBuilder.CreatePrimaryInterestsKeyboard(tempSelections, user.InterfaceLanguageCode),
                )
                _, err = h.bot.Request(editMsg)

                return err</span>
        }

        // Сохраняем в базу данных
        <span class="cov0" title="0">err = h.tempStorage.SaveToDatabase(user.ID, h.interestService)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "SaveToDatabase")
        }</span>

        // Завершаем настройку профиля
        <span class="cov0" title="0">return h.completeProfileSetup(callback, user)</span>
}

// showPrimaryInterestsSelection показывает интерфейс выбора основных интересов.
func (h *ImprovedInterestHandler) showPrimaryInterestsSelection(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем временные выборы
        tempSelections := h.tempStorage.GetSelections(user.ID)

        // Создаем клавиатуру для выбора основных интересов
        keyboard := h.keyboardBuilder.CreatePrimaryInterestsKeyboard(tempSelections, user.InterfaceLanguageCode)

        // Получаем рекомендуемое количество основных интересов
        limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestLimitsConfig")
        }</span>

        // Получаем общее количество интересов в системе
        <span class="cov0" title="0">allInterests, err := h.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetAllInterests")
        }</span>

        // Вычисляем рекомендуемое количество основных интересов от общего количества интересов в системе
        <span class="cov0" title="0">totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(math.Ceil(float64(totalInterestsInSystem) * limits.PrimaryPercentage))

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MinPrimaryInterests
        }</span>

        <span class="cov0" title="0">if recommendedPrimary &gt; limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MaxPrimaryInterests
        }</span>

        // Подсчитываем уже выбранные основные интересы
        <span class="cov0" title="0">selectedPrimaryCount := 0
        for _, selection := range tempSelections </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        selectedPrimaryCount++
                }</span>
        }

        // Создаем текст сообщения с динамическим количеством
        <span class="cov0" title="0">var messageText string
        if selectedPrimaryCount == 0 </span><span class="cov0" title="0">{
                messageText = h.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_dynamic")
                messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
        }</span> else<span class="cov0" title="0"> {
                remaining := recommendedPrimary - selectedPrimaryCount
                if remaining &gt; 0 </span><span class="cov0" title="0">{
                        messageText = h.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_remaining")
                        messageText = strings.ReplaceAll(messageText, "{remaining}", strconv.Itoa(remaining))
                        messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
                }</span> else<span class="cov0" title="0"> {
                        messageText = h.service.Localizer.Get(user.InterfaceLanguageCode, "max_primary_interests_reached")
                        if messageText == "max_primary_interests_reached" </span><span class="cov0" title="0">{
                                messageText = "✅ Максимальное количество основных интересов выбрано!"
                        }</span>
                }
        }

        // Обновляем сообщение
        <span class="cov0" title="0">editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.bot.Request(editMsg)

        return err</span>
}

// updateCategoryInterestsKeyboard обновляет клавиатуру интересов в категории.
func (h *ImprovedInterestHandler) updateCategoryInterestsKeyboard(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        // Получаем категории
        categories, err := h.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Находим категорию
        <span class="cov0" title="0">var selectedCategory *models.InterestCategory

        for _, category := range categories </span><span class="cov0" title="0">{
                if category.KeyName == categoryKey </span><span class="cov0" title="0">{
                        selectedCategory = &amp;category

                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedCategory == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Получаем интересы в категории
        <span class="cov0" title="0">interests, err := h.interestService.GetInterestsByCategory(selectedCategory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Получаем временные выборы
        <span class="cov0" title="0">tempSelections := h.tempStorage.GetSelections(user.ID)

        selectedMap := make(map[int]bool)
        for _, selection := range tempSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем клавиатуру
        <span class="cov0" title="0">keyboard := h.keyboardBuilder.CreateCategoryInterestsKeyboard(
                interests,
                selectedMap,
                categoryKey,
                user.InterfaceLanguageCode,
        )

        // Обновляем сообщение
        categoryName := h.service.Localizer.Get(user.InterfaceLanguageCode, "category_"+categoryKey)
        messageText := categoryName + " - " + h.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChooseInterests)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.bot.Request(editMsg)

        return err</span>
}

// updatePrimaryInterestsKeyboard обновляет клавиатуру выбора основных интересов.
func (h *ImprovedInterestHandler) updatePrimaryInterestsKeyboard(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем временные выборы
        tempSelections := h.tempStorage.GetSelections(user.ID)

        // Создаем клавиатуру
        keyboard := h.keyboardBuilder.CreatePrimaryInterestsKeyboard(tempSelections, user.InterfaceLanguageCode)

        // Получаем рекомендуемое количество основных интересов
        limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Получаем общее количество интересов в системе
        <span class="cov0" title="0">allInterests, err := h.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Вычисляем рекомендуемое количество основных интересов от общего количества интересов в системе
        <span class="cov0" title="0">totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(math.Ceil(float64(totalInterestsInSystem) * limits.PrimaryPercentage))

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MinPrimaryInterests
        }</span>

        <span class="cov0" title="0">if recommendedPrimary &gt; limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MaxPrimaryInterests
        }</span>

        // Подсчитываем уже выбранные основные интересы
        <span class="cov0" title="0">selectedPrimaryCount := 0
        for _, selection := range tempSelections </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        selectedPrimaryCount++
                }</span>
        }

        // Создаем текст сообщения с динамическим количеством
        <span class="cov0" title="0">var messageText string
        if selectedPrimaryCount == 0 </span><span class="cov0" title="0">{
                messageText = h.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_dynamic")
                messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
        }</span> else<span class="cov0" title="0"> {
                remaining := recommendedPrimary - selectedPrimaryCount
                if remaining &gt; 0 </span><span class="cov0" title="0">{
                        messageText = h.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_remaining")
                        messageText = strings.ReplaceAll(messageText, "{remaining}", strconv.Itoa(remaining))
                        messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
                }</span> else<span class="cov0" title="0"> {
                        messageText = h.service.Localizer.Get(user.InterfaceLanguageCode, "max_primary_interests_reached")
                        if messageText == "max_primary_interests_reached" </span><span class="cov0" title="0">{
                                messageText = "✅ Максимальное количество основных интересов выбрано!"
                        }</span>
                }
        }

        <span class="cov0" title="0">editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.bot.Request(editMsg)

        return err</span>
}

// completeProfileSetup завершает настройку профиля интересов пользователя.
//
//nolint:cyclop,funlen // функция содержит последовательную логику завершения профиля, длина оправдана
func (h *ImprovedInterestHandler) completeProfileSetup(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Improved interest handler implementation - Получаем сводку интересов пользователя из БД (после сохранения)
        summary, err := h.interestService.GetUserInterestSummary(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSummary")
        }</span>

        // Создаем текст с основными и дополнительными интересами
        <span class="cov0" title="0">var primaryText, additionalText strings.Builder

        if len(summary.PrimaryInterests) &gt; 0 </span><span class="cov0" title="0">{
                primaryText.WriteString(h.service.Localizer.Get(user.InterfaceLanguageCode, "primary_interests_label") + " ")

                for i, interest := range summary.PrimaryInterests </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                primaryText.WriteString(", ")
                        }</span>

                        <span class="cov0" title="0">interestName := h.service.Localizer.Get(user.InterfaceLanguageCode, "interest_"+interest.KeyName)
                        primaryText.WriteString(interestName)</span>
                }

                <span class="cov0" title="0">primaryText.WriteString("\n")</span>
        }

        <span class="cov0" title="0">if len(summary.AdditionalInterests) &gt; 0 </span><span class="cov0" title="0">{
                additionalText.WriteString(h.service.Localizer.Get(user.InterfaceLanguageCode, "additional_interests_label") + " ")

                for i, interest := range summary.AdditionalInterests </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                additionalText.WriteString(", ")
                        }</span>

                        <span class="cov0" title="0">interestName := h.service.Localizer.Get(user.InterfaceLanguageCode, "interest_"+interest.KeyName)
                        additionalText.WriteString(interestName)</span>
                }

                <span class="cov0" title="0">additionalText.WriteString("\n")</span>
        }

        // Создаем итоговое сообщение
        <span class="cov0" title="0">completionMsg := h.service.Localizer.Get(user.InterfaceLanguageCode, "interests_selection_complete")
        feedbackSuggestion := h.service.Localizer.Get(user.InterfaceLanguageCode, "interests_feedback_suggestion")

        fullMessage := completionMsg + "\n\n" + primaryText.String() + additionalText.String() + "\n" + feedbackSuggestion

        // Создаем клавиатуру
        keyboard := h.keyboardBuilder.CreateProfileCompletedKeyboard(user.InterfaceLanguageCode)

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                fullMessage,
                keyboard,
        )

        _, err = h.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Обновляем состояние пользователя
        <span class="cov0" title="0">err = h.service.DB.UpdateUserState(user.ID, models.StateActive)
        if err != nil </span><span class="cov0" title="0">{
                h.service.LoggingService.Database().ErrorWithContext(
                        "Error updating user state",
                        generateRequestID("completeProfileSetup"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "completeProfileSetup",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
        }</span>

        <span class="cov0" title="0">err = h.service.DB.UpdateUserStatus(user.ID, models.StatusActive)
        if err != nil </span><span class="cov0" title="0">{
                h.service.LoggingService.Database().ErrorWithContext(
                        "Error updating user status",
                        generateRequestID("completeProfileSetup"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "completeProfileSetup",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
        }</span>

        // Обновляем уровень завершения профиля
        <span class="cov0" title="0">err = h.updateProfileCompletionLevel(user.ID, localization.ProfileCompletionLevelComplete)
        if err != nil </span><span class="cov0" title="0">{
                h.service.LoggingService.Database().ErrorWithContext(
                        "Error updating profile completion level",
                        generateRequestID("completeProfileSetup"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "completeProfileSetup",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateProfileCompletionLevel обновляет уровень завершения профиля.
func (h *ImprovedInterestHandler) updateProfileCompletionLevel(userID int, completionLevel int) error <span class="cov0" title="0">{
        _, err := h.service.DB.GetConnection().Exec(`
                UPDATE users
                SET profile_completion_level = $1, updated_at = NOW()
                WHERE id = $2
        `, completionLevel, userID)

        return err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "context"
        "fmt"
        "strings"
        "time"

        "language-exchange-bot/internal/cache"
        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// IsolatedInterestEditor управляет изолированной системой редактирования интересов
type IsolatedInterestEditor struct {
        service         *core.BotService
        interestService *core.InterestService
        bot             *tgbotapi.BotAPI
        keyboardBuilder *KeyboardBuilder
        errorHandler    *errors.ErrorHandler
        cache           cache.ServiceInterface
}

// EditSession представляет сессию редактирования интересов
type EditSession struct {
        UserID             int
        OriginalSelections []models.InterestSelection
        CurrentSelections  []models.InterestSelection
        Changes            []InterestChange
        CurrentCategory    string
        SessionStart       time.Time
        LastActivity       time.Time
}

// InterestChange представляет изменение в интересах
type InterestChange struct {
        Action       string // "add", "remove", "set_primary", "unset_primary"
        InterestID   int
        InterestName string
        Category     string
        Timestamp    time.Time
}

// EditStats представляет статистику редактирования
type EditStats struct {
        TotalSelected  int
        PrimaryCount   int
        CategoryCounts map[string]int
        ChangesCount   int
        LastUpdated    time.Time
}

// NewIsolatedInterestEditor создает новый редактор изолированных интересов
func NewIsolatedInterestEditor(
        service *core.BotService,
        interestService *core.InterestService,
        bot *tgbotapi.BotAPI,
        keyboardBuilder *KeyboardBuilder,
        errorHandler *errors.ErrorHandler,
        cache cache.ServiceInterface,
) *IsolatedInterestEditor <span class="cov0" title="0">{
        return &amp;IsolatedInterestEditor{
                service:         service,
                interestService: interestService,
                bot:             bot,
                keyboardBuilder: keyboardBuilder,
                errorHandler:    errorHandler,
                cache:           cache,
        }
}</span>

// StartEditSession начинает новую сессию редактирования
func (e *IsolatedInterestEditor) StartEditSession(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        e.service.LoggingService.Telegram().InfoWithContext(
                "Starting isolated edit session",
                generateRequestID("StartEditSession"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "StartEditSession",
                map[string]interface{}{"userID": user.ID},
        )

        // Получаем оригинальные выборы пользователя
        originalSelections, err := e.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Создаем копию для редактирования
        <span class="cov0" title="0">currentSelections := make([]models.InterestSelection, len(originalSelections))
        copy(currentSelections, originalSelections)

        // Создаем сессию
        session := &amp;EditSession{
                UserID:             user.ID,
                OriginalSelections: originalSelections,
                CurrentSelections:  currentSelections,
                Changes:            []InterestChange{},
                SessionStart:       time.Now(),
                LastActivity:       time.Now(),
        }

        // Сохраняем сессию в кеше
        cacheKey := fmt.Sprintf("edit_session_%d", user.ID)
        e.service.LoggingService.Cache().InfoWithContext(
                "Saving session to cache",
                generateRequestID("StartEditSession"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "StartEditSession",
                map[string]interface{}{"userID": user.ID, "cacheKey": cacheKey},
        )
        err = e.cache.Set(context.Background(), cacheKey, session, 30*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                e.service.LoggingService.Cache().WarnWithContext(
                        "Failed to cache edit session",
                        generateRequestID("StartEditSession"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "StartEditSession",
                        map[string]interface{}{"userID": user.ID, "cacheKey": cacheKey, "error": err.Error()},
                )
        }</span> else<span class="cov0" title="0"> {
                e.service.LoggingService.Cache().InfoWithContext(
                        "Successfully cached session",
                        generateRequestID("StartEditSession"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "StartEditSession",
                        map[string]interface{}{"userID": user.ID, "cacheKey": cacheKey},
                )
        }</span>

        // Показываем главное меню редактирования
        <span class="cov0" title="0">return e.ShowEditMainMenu(callback, user, session)</span>
}

// showEditMainMenu показывает главное меню редактирования
func (e *IsolatedInterestEditor) ShowEditMainMenu(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        // Получаем статистику
        stats := e.calculateEditStats(session)

        // Создаем текст с хлебными крошками и статистикой
        breadcrumb := e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_breadcrumb")
        statsText := e.formatEditStats(stats, user.InterfaceLanguageCode)

        text := fmt.Sprintf("%s\n\n%s\n\n%s",
                breadcrumb,
                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_main_menu"),
                statsText)

        // Создаем клавиатуру главного меню
        keyboard := e.createEditMainMenuKeyboard(user.InterfaceLanguageCode, stats)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := e.bot.Request(editMsg)
        return err
}</span>

// showEditCategoriesMenu показывает меню категорий для редактирования
func (e *IsolatedInterestEditor) ShowEditCategoriesMenu(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        // Получаем категории с индикаторами прогресса
        categories, err := e.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategories")
        }</span>

        // Создаем текст с хлебными крошками
        <span class="cov0" title="0">breadcrumb := e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_breadcrumb_categories")
        text := fmt.Sprintf("%s\n\n%s",
                breadcrumb,
                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_choose_category"))

        // Создаем клавиатуру категорий с индикаторами
        keyboard := e.createEditCategoriesKeyboard(categories, session, user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = e.bot.Request(editMsg)
        return err</span>
}

// showEditCategoryInterests показывает интересы в категории для редактирования
func (e *IsolatedInterestEditor) ShowEditCategoryInterests(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession, categoryKey string) error <span class="cov0" title="0">{
        // Обновляем текущую категорию в сессии
        session.CurrentCategory = categoryKey
        e.updateSession(session)

        // Получаем интересы в категории
        interests, err := e.interestService.GetInterestsByCategoryKey(categoryKey)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategoryKey")
        }</span>

        // Создаем карту выбранных интересов
        <span class="cov0" title="0">selectedMap := make(map[int]bool)
        for _, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем текст с хлебными крошками
        <span class="cov0" title="0">categoryName := e.service.Localizer.Get(user.InterfaceLanguageCode, "category_"+categoryKey)
        breadcrumb := fmt.Sprintf("%s &gt; %s",
                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_breadcrumb_categories"),
                categoryName)

        text := fmt.Sprintf("%s\n\n%s",
                breadcrumb,
                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_in_category"))

        // Создаем клавиатуру интересов
        keyboard := e.createEditCategoryInterestsKeyboard(interests, selectedMap, categoryKey, user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = e.bot.Request(editMsg)
        return err</span>
}

// ShowEditPrimaryInterests показывает основные интересы для редактирования
func (e *IsolatedInterestEditor) ShowEditPrimaryInterests(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        e.service.LoggingService.Telegram().DebugWithContext(
                "ShowEditPrimaryInterests called",
                generateRequestID("ShowEditPrimaryInterests"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "ShowEditPrimaryInterests",
                map[string]interface{}{"userID": user.ID},
        )

        // Получаем текущие выборы пользователя
        selections, err := e.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                e.service.LoggingService.Database().DebugWithContext(
                        "ShowEditPrimaryInterests GetUserInterestSelections error",
                        generateRequestID("ShowEditPrimaryInterests"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "ShowEditPrimaryInterests",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        <span class="cov0" title="0">e.service.LoggingService.Database().DebugWithContext(
                "ShowEditPrimaryInterests found selections",
                generateRequestID("ShowEditPrimaryInterests"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "ShowEditPrimaryInterests",
                map[string]interface{}{"userID": user.ID, "selectionsCount": len(selections)},
        )

        // Получаем общее количество интересов в системе
        allInterests, err := e.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetAllInterests")
        }</span>

        // Вычисляем рекомендуемое количество основных интересов
        <span class="cov0" title="0">config := e.service.GetConfig()
        totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(float64(totalInterestsInSystem) * config.PrimaryPercentage)

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; config.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = config.MinPrimaryInterests
        }</span>
        <span class="cov0" title="0">if recommendedPrimary &gt; config.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = config.MaxPrimaryInterests
        }</span>

        // Подсчитываем уже выбранные основные интересы
        <span class="cov0" title="0">selectedPrimaryCount := 0
        for _, selection := range selections </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        selectedPrimaryCount++
                }</span>
        }

        // Создаем хлебные крошки
        <span class="cov0" title="0">breadcrumb := e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_breadcrumb_primary")

        // Создаем текст сообщения с счетчиком
        text := fmt.Sprintf("%s\n\n%s (%d из %d выбрано)",
                breadcrumb,
                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_primary_description"),
                selectedPrimaryCount,
                recommendedPrimary)

        // Создаем клавиатуру для основных интересов
        keyboard := e.createEditPrimaryInterestsKeyboard(selections, user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = e.bot.Request(editMsg)
        return err</span>
}

// toggleInterestSelection переключает выбор интереса
func (e *IsolatedInterestEditor) ToggleInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestID int) error <span class="cov0" title="0">{
        // Получаем сессию
        session, err := e.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        // Получаем информацию об интересе
        <span class="cov0" title="0">interest, err := e.interestService.GetInterestByID(interestID)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestByID")
        }</span>

        // Проверяем, выбран ли уже этот интерес
        <span class="cov0" title="0">isSelected := false

        for _, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        isSelected = true
                        break</span>
                }
        }

        // Переключаем выбор
        <span class="cov0" title="0">if isSelected </span><span class="cov0" title="0">{
                // Удаляем выбор
                e.removeSelectionFromSession(session, interestID)
                e.addChange(session, InterestChange{
                        Action:       "remove",
                        InterestID:   interestID,
                        InterestName: interest.KeyName,
                        Category:     interest.CategoryKey,
                        Timestamp:    time.Now(),
                })
        }</span> else<span class="cov0" title="0"> {
                // Добавляем выбор
                newSelection := models.InterestSelection{
                        UserID:     user.ID,
                        InterestID: interestID,
                        IsPrimary:  false,
                }
                session.CurrentSelections = append(session.CurrentSelections, newSelection)
                e.addChange(session, InterestChange{
                        Action:       "add",
                        InterestID:   interestID,
                        InterestName: interest.KeyName,
                        Category:     interest.CategoryKey,
                        Timestamp:    time.Now(),
                })
        }</span>

        // Обновляем сессию
        <span class="cov0" title="0">e.updateSession(session)

        // Обновляем клавиатуру
        return e.ShowEditCategoryInterests(callback, user, session, session.CurrentCategory)</span>
}

// showChangesPreview показывает предварительный просмотр изменений
func (e *IsolatedInterestEditor) ShowChangesPreview(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        // Создаем текст с изменениями
        text := e.formatChangesPreview(session, user.InterfaceLanguageCode)

        // Создаем клавиатуру для предварительного просмотра
        keyboard := e.createChangesPreviewKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := e.bot.Request(editMsg)
        return err
}</span>

// saveChanges сохраняет изменения
func (e *IsolatedInterestEditor) SaveChanges(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        e.service.LoggingService.Database().InfoWithContext(
                "Saving changes for user",
                generateRequestID("SaveChanges"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "SaveChanges",
                map[string]interface{}{
                        "userID":                 user.ID,
                        "currentSelectionsCount": len(session.CurrentSelections),
                        "changesCount":           len(session.Changes),
                },
        )

        // Валидируем выборы
        if err := e.validateSelections(session); err != nil </span><span class="cov0" title="0">{
                e.service.LoggingService.Database().ErrorWithContext(
                        "Validation failed",
                        generateRequestID("SaveChanges"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "SaveChanges",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ValidateSelections")
        }</span>

        // Сохраняем изменения в базу данных
        <span class="cov0" title="0">e.service.LoggingService.Database().InfoWithContext(
                "Calling BatchUpdateUserInterests",
                generateRequestID("SaveChanges"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "SaveChanges",
                map[string]interface{}{"userID": user.ID, "selectionsCount": len(session.CurrentSelections)},
        )
        err := e.interestService.BatchUpdateUserInterests(user.ID, session.CurrentSelections)
        if err != nil </span><span class="cov0" title="0">{
                e.service.LoggingService.Database().ErrorWithContext(
                        "BatchUpdateUserInterests failed",
                        generateRequestID("SaveChanges"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "SaveChanges",
                        map[string]interface{}{"userID": user.ID, "selectionsCount": len(session.CurrentSelections), "error": err.Error()},
                )
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "BatchUpdateUserInterests")
        }</span>

        // Очищаем сессию
        <span class="cov0" title="0">e.clearEditSession(user.ID)

        // Показываем уведомление об изменениях и возвращаемся к профилю
        changesCount := len(session.Changes)
        text := fmt.Sprintf("✅ Изменения успешно сохранены!\n\n📊 Внесено изменений: %d", changesCount)

        // Добавляем детальную информацию об изменениях
        if changesCount &gt; 0 </span><span class="cov0" title="0">{
                text += "\n\n📝 Детали изменений:"
                text += e.formatChangesSummary(session, user.InterfaceLanguageCode)
        }</span>

        // Создаем клавиатуру профиля
        <span class="cov0" title="0">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("👤 Показать профиль", "profile_show"),
                ),
        )

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = e.bot.Request(editMsg)
        return err</span>
}

// cancelEdit отменяет редактирование
func (e *IsolatedInterestEditor) CancelEdit(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        e.service.LoggingService.Telegram().InfoWithContext(
                "Canceling edit for user",
                generateRequestID("CancelEdit"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "CancelEdit",
                map[string]interface{}{"userID": user.ID},
        )

        // Получаем сессию для подсчета изменений
        session, err := e.GetEditSession(user.ID)
        changesCount := 0
        if err == nil </span><span class="cov0" title="0">{
                changesCount = len(session.Changes)
        }</span>

        // Очищаем сессию
        <span class="cov0" title="0">e.clearEditSession(user.ID)

        // Показываем уведомление об отмене и возвращаемся к профилю
        text := fmt.Sprintf("❌ Редактирование отменено!\n\n📊 Отменено изменений: %d", changesCount)

        // Добавляем детальную информацию об отмененных изменениях
        if err == nil &amp;&amp; changesCount &gt; 0 </span><span class="cov0" title="0">{
                text += "\n\n📝 Отмененные изменения:"
                text += e.formatChangesSummary(session, user.InterfaceLanguageCode)
        }</span>

        // Создаем клавиатуру профиля
        <span class="cov0" title="0">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("👤 Показать профиль", "profile_show"),
                ),
        )

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = e.bot.Request(editMsg)
        return err</span>
}

// Вспомогательные методы

func (e *IsolatedInterestEditor) GetEditSession(userID int) (*EditSession, error) <span class="cov0" title="0">{
        e.service.LoggingService.Cache().DebugWithContext(
                "Getting edit session for user",
                generateRequestID("GetEditSession"),
                int64(userID),
                0, // нет chatID в этой функции
                "GetEditSession",
                map[string]interface{}{"userID": userID},
        )
        var session EditSession
        cacheKey := fmt.Sprintf("edit_session_%d", userID)
        e.service.LoggingService.Cache().DebugWithContext(
                "Cache key generated",
                generateRequestID("GetEditSession"),
                int64(userID),
                0, // нет chatID в этой функции
                "GetEditSession",
                map[string]interface{}{"userID": userID, "cacheKey": cacheKey},
        )

        err := e.cache.Get(context.Background(), cacheKey, &amp;session)
        if err != nil </span><span class="cov0" title="0">{
                e.service.LoggingService.Cache().ErrorWithContext(
                        "Failed to get session from cache",
                        generateRequestID("GetEditSession"),
                        int64(userID),
                        0, // нет chatID в этой функции
                        "GetEditSession",
                        map[string]interface{}{"userID": userID, "cacheKey": cacheKey, "error": err.Error()},
                )
                return nil, fmt.Errorf("session not found: %w", err)
        }</span>

        <span class="cov0" title="0">e.service.LoggingService.Cache().DebugWithContext(
                "Successfully retrieved session",
                generateRequestID("GetEditSession"),
                int64(userID),
                0, // нет chatID в этой функции
                "GetEditSession",
                map[string]interface{}{"userID": userID, "selectionsCount": len(session.CurrentSelections)},
        )
        return &amp;session, nil</span>
}

func (e *IsolatedInterestEditor) updateSession(session *EditSession) <span class="cov0" title="0">{
        session.LastActivity = time.Now()
        _ = e.cache.Set(context.Background(), fmt.Sprintf("edit_session_%d", session.UserID), session, 30*time.Minute)
}</span>

func (e *IsolatedInterestEditor) clearEditSession(userID int) <span class="cov0" title="0">{
        _ = e.cache.Delete(context.Background(), fmt.Sprintf("edit_session_%d", userID))
}</span>

func (e *IsolatedInterestEditor) removeSelectionFromSession(session *EditSession, interestID int) <span class="cov0" title="0">{
        for i, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        session.CurrentSelections = append(session.CurrentSelections[:i], session.CurrentSelections[i+1:]...)
                        break</span>
                }
        }
}

func (e *IsolatedInterestEditor) addChange(session *EditSession, change InterestChange) <span class="cov0" title="0">{
        session.Changes = append(session.Changes, change)
}</span>

func (e *IsolatedInterestEditor) calculateEditStats(session *EditSession) EditStats <span class="cov8" title="1">{
        stats := EditStats{
                CategoryCounts: make(map[string]int),
                LastUpdated:    time.Now(),
        }

        for _, selection := range session.CurrentSelections </span><span class="cov8" title="1">{
                stats.TotalSelected++
                if selection.IsPrimary </span><span class="cov8" title="1">{
                        stats.PrimaryCount++
                }</span>
                // TODO: Добавить подсчет по категориям
        }

        <span class="cov8" title="1">stats.ChangesCount = len(session.Changes)
        return stats</span>
}

func (e *IsolatedInterestEditor) formatEditStats(stats EditStats, lang string) string <span class="cov0" title="0">{
        return fmt.Sprintf("📊 %s: %d | ⭐ %s: %d | 🔄 %s: %d",
                e.service.Localizer.Get(lang, "total_interests"),
                stats.TotalSelected,
                e.service.Localizer.Get(lang, "primary_interests_label"),
                stats.PrimaryCount,
                e.service.Localizer.Get(lang, "changes_count"),
                stats.ChangesCount)
}</span>

func (e *IsolatedInterestEditor) formatChangesPreview(session *EditSession, lang string) string <span class="cov0" title="0">{
        text := e.service.Localizer.Get(lang, "edit_interests_changes_preview") + "\n\n"

        if len(session.Changes) == 0 </span><span class="cov0" title="0">{
                text += e.service.Localizer.Get(lang, "no_changes_made")
                return text
        }</span>

        // Группируем изменения
        <span class="cov0" title="0">added := []InterestChange{}
        removed := []InterestChange{}

        for _, change := range session.Changes </span><span class="cov0" title="0">{
                switch change.Action </span>{
                case "add":<span class="cov0" title="0">
                        added = append(added, change)</span>
                case "remove":<span class="cov0" title="0">
                        removed = append(removed, change)</span>
                }
        }

        <span class="cov0" title="0">if len(added) &gt; 0 </span><span class="cov0" title="0">{
                text += "✅ " + e.service.Localizer.Get(lang, "added_interests") + ":\n"
                for _, change := range added </span><span class="cov0" title="0">{
                        text += fmt.Sprintf("• %s\n", change.InterestName)
                }</span>
                <span class="cov0" title="0">text += "\n"</span>
        }

        <span class="cov0" title="0">if len(removed) &gt; 0 </span><span class="cov0" title="0">{
                text += "❌ " + e.service.Localizer.Get(lang, "removed_interests") + ":\n"
                for _, change := range removed </span><span class="cov0" title="0">{
                        text += fmt.Sprintf("• %s\n", change.InterestName)
                }</span>
                <span class="cov0" title="0">text += "\n"</span>
        }

        <span class="cov0" title="0">return text</span>
}

func (e *IsolatedInterestEditor) validateSelections(session *EditSession) error <span class="cov8" title="1">{
        // Разрешаем сохранение даже если нет выбранных интересов
        // Это позволяет пользователю очистить все свои интересы

        // Логируем только если service инициализирован (для совместимости с тестами)
        if e.service != nil &amp;&amp; e.service.LoggingService != nil </span><span class="cov0" title="0">{
                e.service.LoggingService.Database().DebugWithContext(
                        "Validating selections",
                        generateRequestID("validateSelections"),
                        int64(session.UserID),
                        0, // нет chatID в этой функции
                        "validateSelections",
                        map[string]interface{}{"userID": session.UserID, "selectionsCount": len(session.CurrentSelections)},
                )
        }</span>

        // TODO: Добавить дополнительные проверки валидации
        <span class="cov8" title="1">return nil</span>
}

// formatChangesSummary форматирует краткое описание изменений
func (e *IsolatedInterestEditor) formatChangesSummary(session *EditSession, lang string) string <span class="cov0" title="0">{
        if len(session.Changes) == 0 </span><span class="cov0" title="0">{
                return "\n• Изменений не было"
        }</span>

        <span class="cov0" title="0">var addedInterests []string
        var removedInterests []string
        var primarySet []string
        var primaryUnset []string

        // Группируем изменения по типам
        for _, change := range session.Changes </span><span class="cov0" title="0">{
                interestName := e.service.Localizer.Get(lang, "interest_"+change.InterestName)

                switch change.Action </span>{
                case "add":<span class="cov0" title="0">
                        addedInterests = append(addedInterests, "• "+interestName)</span>
                case "remove":<span class="cov0" title="0">
                        removedInterests = append(removedInterests, "• "+interestName)</span>
                case "set_primary":<span class="cov0" title="0">
                        primarySet = append(primarySet, "• "+interestName)</span>
                case "unset_primary":<span class="cov0" title="0">
                        primaryUnset = append(primaryUnset, "• "+interestName)</span>
                }
        }

        <span class="cov0" title="0">var summary strings.Builder

        if len(addedInterests) &gt; 0 </span><span class="cov0" title="0">{
                summary.WriteString("\n\n➕ Добавлены:")
                for _, interest := range addedInterests </span><span class="cov0" title="0">{
                        summary.WriteString("\n" + interest)
                }</span>
        }

        <span class="cov0" title="0">if len(removedInterests) &gt; 0 </span><span class="cov0" title="0">{
                summary.WriteString("\n\n➖ Удалены:")
                for _, interest := range removedInterests </span><span class="cov0" title="0">{
                        summary.WriteString("\n" + interest)
                }</span>
        }

        <span class="cov0" title="0">if len(primarySet) &gt; 0 </span><span class="cov0" title="0">{
                summary.WriteString("\n\n⭐ Сделаны основными:")
                for _, interest := range primarySet </span><span class="cov0" title="0">{
                        summary.WriteString("\n" + interest)
                }</span>
        }

        <span class="cov0" title="0">if len(primaryUnset) &gt; 0 </span><span class="cov0" title="0">{
                summary.WriteString("\n\n☐ Убраны из основных:")
                for _, interest := range primaryUnset </span><span class="cov0" title="0">{
                        summary.WriteString("\n" + interest)
                }</span>
        }

        <span class="cov0" title="0">return summary.String()</span>
}

// togglePrimaryInterest переключает статус основного интереса
func (e *IsolatedInterestEditor) TogglePrimaryInterest(callback *tgbotapi.CallbackQuery, user *models.User, interestID int) error <span class="cov0" title="0">{
        session, err := e.GetEditSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetEditSession")
        }</span>

        // Находим интерес в текущих выборах
        <span class="cov0" title="0">for i, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        // Проверяем лимиты перед переключением
                        currentPrimaryCount := 0
                        for _, sel := range session.CurrentSelections </span><span class="cov0" title="0">{
                                if sel.IsPrimary </span><span class="cov0" title="0">{
                                        currentPrimaryCount++
                                }</span>
                        }

                        // Если пытаемся сделать основным, проверяем максимум
                        <span class="cov0" title="0">if !session.CurrentSelections[i].IsPrimary </span><span class="cov0" title="0">{
                                // Получаем общее количество интересов в системе
                                allInterests, err := e.interestService.GetAllInterests()
                                if err != nil </span><span class="cov0" title="0">{
                                        return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetAllInterests")
                                }</span>

                                // Вычисляем рекомендуемое количество основных интересов
                                <span class="cov0" title="0">config := e.service.GetConfig()
                                totalInterestsInSystem := len(allInterests)
                                recommendedPrimary := int(float64(totalInterestsInSystem) * config.PrimaryPercentage)

                                // Ограничиваем минимумом и максимумом
                                if recommendedPrimary &lt; config.MinPrimaryInterests </span><span class="cov0" title="0">{
                                        recommendedPrimary = config.MinPrimaryInterests
                                }</span>
                                <span class="cov0" title="0">if recommendedPrimary &gt; config.MaxPrimaryInterests </span><span class="cov0" title="0">{
                                        recommendedPrimary = config.MaxPrimaryInterests
                                }</span>

                                <span class="cov0" title="0">if currentPrimaryCount &gt;= recommendedPrimary </span><span class="cov0" title="0">{
                                        // Показываем предупреждение о достижении максимума
                                        text := fmt.Sprintf("❌ Максимальное количество основных интересов (%d) уже выбрано!\n\n%s (%d из %d выбрано)",
                                                recommendedPrimary,
                                                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_primary_description"),
                                                currentPrimaryCount,
                                                recommendedPrimary)

                                        keyboard := e.createEditPrimaryInterestsKeyboard(session.CurrentSelections, user.InterfaceLanguageCode)
                                        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                                                callback.Message.Chat.ID,
                                                callback.Message.MessageID,
                                                text,
                                                keyboard,
                                        )
                                        _, err = e.bot.Request(editMsg)
                                        return err
                                }</span>
                        }

                        // Переключаем статус основного
                        <span class="cov0" title="0">session.CurrentSelections[i].IsPrimary = !session.CurrentSelections[i].IsPrimary

                        // Добавляем изменение
                        action := "unset_primary"
                        if session.CurrentSelections[i].IsPrimary </span><span class="cov0" title="0">{
                                action = "set_primary"
                        }</span>

                        <span class="cov0" title="0">interest, err := e.interestService.GetInterestByID(interestID)
                        if err == nil </span><span class="cov0" title="0">{
                                e.addChange(session, InterestChange{
                                        Action:       action,
                                        InterestID:   interestID,
                                        InterestName: interest.KeyName,
                                        Category:     interest.CategoryKey,
                                        Timestamp:    time.Now(),
                                })
                        }</span>

                        <span class="cov0" title="0">break</span>
                }
        }

        // Обновляем сессию
        <span class="cov0" title="0">e.updateSession(session)

        // Показываем обновленную клавиатуру основных интересов
        return e.showEditPrimaryInterests(callback, user, session)</span>
}

// showEditPrimaryInterests показывает интерфейс редактирования основных интересов
func (e *IsolatedInterestEditor) showEditPrimaryInterests(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        // Создаем текст с хлебными крошками
        breadcrumb := e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_breadcrumb_primary")
        text := fmt.Sprintf("%s\n\n%s",
                breadcrumb,
                e.service.Localizer.Get(user.InterfaceLanguageCode, "edit_interests_primary_description"))

        // Создаем клавиатуру основных интересов
        keyboard := e.createEditPrimaryInterestsKeyboard(session.CurrentSelections, user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := e.bot.Request(editMsg)
        return err
}</span>

// massSelectCategory выбирает все интересы в категории
func (e *IsolatedInterestEditor) MassSelectCategory(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession, categoryKey string) error <span class="cov0" title="0">{
        // Получаем все интересы в категории
        interests, err := e.interestService.GetInterestsByCategoryKey(categoryKey)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategoryKey")
        }</span>

        // Добавляем все интересы, которых еще нет в выборах
        <span class="cov0" title="0">existingIDs := make(map[int]bool)
        for _, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                existingIDs[selection.InterestID] = true
        }</span>

        <span class="cov0" title="0">for _, interest := range interests </span><span class="cov0" title="0">{
                if !existingIDs[interest.ID] </span><span class="cov0" title="0">{
                        newSelection := models.InterestSelection{
                                UserID:     user.ID,
                                InterestID: interest.ID,
                                IsPrimary:  false,
                        }
                        session.CurrentSelections = append(session.CurrentSelections, newSelection)

                        // Добавляем изменение
                        e.addChange(session, InterestChange{
                                Action:       "add",
                                InterestID:   interest.ID,
                                InterestName: interest.KeyName,
                                Category:     categoryKey,
                                Timestamp:    time.Now(),
                        })
                }</span>
        }

        // Обновляем сессию
        <span class="cov0" title="0">e.updateSession(session)

        // Показываем обновленную клавиатуру
        return e.ShowEditCategoryInterests(callback, user, session, categoryKey)</span>
}

// massClearCategory очищает все интересы в категории
func (e *IsolatedInterestEditor) MassClearCategory(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession, categoryKey string) error <span class="cov0" title="0">{
        // Получаем все интересы в категории
        interests, err := e.interestService.GetInterestsByCategoryKey(categoryKey)
        if err != nil </span><span class="cov0" title="0">{
                return e.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategoryKey")
        }</span>

        // Создаем карту ID интересов в категории
        <span class="cov0" title="0">categoryInterestIDs := make(map[int]bool)
        for _, interest := range interests </span><span class="cov0" title="0">{
                categoryInterestIDs[interest.ID] = true
        }</span>

        // Удаляем все интересы из этой категории
        <span class="cov0" title="0">var newSelections []models.InterestSelection
        for _, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                if !categoryInterestIDs[selection.InterestID] </span><span class="cov0" title="0">{
                        newSelections = append(newSelections, selection)
                }</span> else<span class="cov0" title="0"> {
                        // Добавляем изменение удаления
                        interest, err := e.interestService.GetInterestByID(selection.InterestID)
                        if err == nil </span><span class="cov0" title="0">{
                                e.addChange(session, InterestChange{
                                        Action:       "remove",
                                        InterestID:   selection.InterestID,
                                        InterestName: interest.KeyName,
                                        Category:     categoryKey,
                                        Timestamp:    time.Now(),
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">session.CurrentSelections = newSelections

        // Обновляем сессию
        e.updateSession(session)

        // Показываем обновленную клавиатуру
        return e.ShowEditCategoryInterests(callback, user, session, categoryKey)</span>
}

// undoLastChange отменяет последнее изменение
func (e *IsolatedInterestEditor) UndoLastChange(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        if len(session.Changes) == 0 </span><span class="cov0" title="0">{
                // Нет изменений для отмены
                return e.ShowEditMainMenu(callback, user, session)
        }</span>

        // Получаем последнее изменение
        <span class="cov0" title="0">lastChange := session.Changes[len(session.Changes)-1]

        // Отменяем изменение
        switch lastChange.Action </span>{
        case "add":<span class="cov0" title="0">
                // Удаляем интерес
                e.removeSelectionFromSession(session, lastChange.InterestID)</span>
        case "remove":<span class="cov0" title="0">
                // Добавляем интерес обратно
                newSelection := models.InterestSelection{
                        UserID:     user.ID,
                        InterestID: lastChange.InterestID,
                        IsPrimary:  false,
                }
                session.CurrentSelections = append(session.CurrentSelections, newSelection)</span>
        case "set_primary":<span class="cov0" title="0">
                // Убираем статус основного
                for i, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                        if selection.InterestID == lastChange.InterestID </span><span class="cov0" title="0">{
                                session.CurrentSelections[i].IsPrimary = false
                                break</span>
                        }
                }
        case "unset_primary":<span class="cov0" title="0">
                // Устанавливаем статус основного
                for i, selection := range session.CurrentSelections </span><span class="cov0" title="0">{
                        if selection.InterestID == lastChange.InterestID </span><span class="cov0" title="0">{
                                session.CurrentSelections[i].IsPrimary = true
                                break</span>
                        }
                }
        }

        // Удаляем последнее изменение из истории
        <span class="cov0" title="0">session.Changes = session.Changes[:len(session.Changes)-1]

        // Обновляем сессию
        e.updateSession(session)

        // Показываем главное меню
        return e.ShowEditMainMenu(callback, user, session)</span>
}

// showEditStatistics показывает статистику редактирования
func (e *IsolatedInterestEditor) ShowEditStatistics(callback *tgbotapi.CallbackQuery, user *models.User, session *EditSession) error <span class="cov0" title="0">{
        stats := e.calculateEditStats(session)

        // Создаем детальную статистику
        text := e.formatDetailedStatistics(stats, session, user.InterfaceLanguageCode)

        // Создаем клавиатуру для статистики
        keyboard := e.createStatisticsKeyboard(user.InterfaceLanguageCode)

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err := e.bot.Request(editMsg)
        return err
}</span>

// formatDetailedStatistics форматирует детальную статистику
func (e *IsolatedInterestEditor) formatDetailedStatistics(stats EditStats, session *EditSession, lang string) string <span class="cov0" title="0">{
        text := e.service.Localizer.Get(lang, "edit_interests_detailed_statistics") + "\n\n"

        // Общая статистика
        text += fmt.Sprintf("📊 %s: %d\n", e.service.Localizer.Get(lang, "total_interests"), stats.TotalSelected)
        text += fmt.Sprintf("⭐ %s: %d\n", e.service.Localizer.Get(lang, "primary_interests_label"), stats.PrimaryCount)
        text += fmt.Sprintf("🔄 %s: %d\n", e.service.Localizer.Get(lang, "changes_count"), stats.ChangesCount)
        text += fmt.Sprintf("⏱️ %s: %s\n\n", e.service.Localizer.Get(lang, "session_duration"),
                time.Since(session.SessionStart).Round(time.Minute))

        // Статистика по категориям
        if len(stats.CategoryCounts) &gt; 0 </span><span class="cov0" title="0">{
                text += e.service.Localizer.Get(lang, "category_statistics") + ":\n"
                for category, count := range stats.CategoryCounts </span><span class="cov0" title="0">{
                        categoryName := e.service.Localizer.Get(lang, "category_"+category)
                        text += fmt.Sprintf("• %s: %d\n", categoryName, count)
                }</span>
        }

        <span class="cov0" title="0">return text</span>
}

// createStatisticsKeyboard создает клавиатуру для статистики
func (e *IsolatedInterestEditor) createStatisticsKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Навигация
        navRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "🏠 "+e.service.Localizer.Get(interfaceLang, "back_to_main_menu"),
                        "isolated_main_menu",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "👁️ "+e.service.Localizer.Get(interfaceLang, "preview_changes"),
                        "isolated_preview_changes",
                ),
        }
        buttonRows = append(buttonRows, navRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "fmt"
        "sort"
        "strconv"

        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// createEditMainMenuKeyboard создает клавиатуру главного меню редактирования
func (e *IsolatedInterestEditor) createEditMainMenuKeyboard(interfaceLang string, stats EditStats) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Основные действия
        mainRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "🎯 "+e.service.Localizer.Get(interfaceLang, "edit_interests_by_category"),
                        "isolated_edit_categories",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "⭐ "+e.service.Localizer.Get(interfaceLang, "edit_primary_interests"),
                        "isolated_edit_primary",
                ),
        }
        buttonRows = append(buttonRows, mainRow)

        // Управление
        controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "💾 "+e.service.Localizer.Get(interfaceLang, "save_changes"),
                        "isolated_save_changes",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "❌ "+e.service.Localizer.Get(interfaceLang, "cancel_edit"),
                        "isolated_cancel_edit",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)
}</span>

// createEditCategoriesKeyboard создает клавиатуру категорий для редактирования
func (e *IsolatedInterestEditor) createEditCategoriesKeyboard(categories []models.InterestCategory, session *EditSession, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Сортируем категории по display_order
        sort.Slice(categories, func(i, j int) bool </span><span class="cov0" title="0">{
                return categories[i].DisplayOrder &lt; categories[j].DisplayOrder
        }</span>)

        // Создаем кнопки категорий (по 2 в ряд)
        <span class="cov0" title="0">for i := 0; i &lt; len(categories); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                category1 := categories[i]
                categoryName1 := e.service.Localizer.Get(interfaceLang, "category_"+category1.KeyName)

                // Добавляем индикатор прогресса
                progress1 := e.getCategoryProgress(session, category1.KeyName)
                buttonText1 := fmt.Sprintf("%s %s", categoryName1, progress1)

                button1 := tgbotapi.NewInlineKeyboardButtonData(
                        buttonText1,
                        "isolated_edit_category_"+category1.KeyName,
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(categories) </span><span class="cov0" title="0">{
                        category2 := categories[i+1]
                        categoryName2 := e.service.Localizer.Get(interfaceLang, "category_"+category2.KeyName)

                        progress2 := e.getCategoryProgress(session, category2.KeyName)
                        buttonText2 := fmt.Sprintf("%s %s", categoryName2, progress2)

                        button2 := tgbotapi.NewInlineKeyboardButtonData(
                                buttonText2,
                                "isolated_edit_category_"+category2.KeyName,
                        )
                        row = append(row, button2)
                }</span>

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Навигация
        <span class="cov0" title="0">navRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "🏠 "+e.service.Localizer.Get(interfaceLang, "back_to_edit_menu"),
                        "isolated_main_menu",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "⭐ "+e.service.Localizer.Get(interfaceLang, "edit_primary_interests"),
                        "isolated_edit_primary",
                ),
        }
        buttonRows = append(buttonRows, navRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// createEditCategoryInterestsKeyboard создает клавиатуру интересов в категории для редактирования
func (e *IsolatedInterestEditor) createEditCategoryInterestsKeyboard(interests []models.Interest, selectedMap map[int]bool, categoryKey, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Сортируем интересы по display_order
        sort.Slice(interests, func(i, j int) bool </span><span class="cov0" title="0">{
                return interests[i].DisplayOrder &lt; interests[j].DisplayOrder
        }</span>)

        // Создаем кнопки интересов (по 2 в ряд)
        <span class="cov0" title="0">for i := 0; i &lt; len(interests); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                interest1 := interests[i]
                interestName1 := e.service.Localizer.Get(interfaceLang, "interest_"+interest1.KeyName)

                prefix1 := "☐ "
                if selectedMap[interest1.ID] </span><span class="cov0" title="0">{
                        prefix1 = "✅ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "isolated_toggle_interest_"+strconv.Itoa(interest1.ID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(interests) </span><span class="cov0" title="0">{
                        interest2 := interests[i+1]
                        interestName2 := e.service.Localizer.Get(interfaceLang, "interest_"+interest2.KeyName)

                        prefix2 := "☐ "
                        if selectedMap[interest2.ID] </span><span class="cov0" title="0">{
                                prefix2 = "✅ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "isolated_toggle_interest_"+strconv.Itoa(interest2.ID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Массовые операции
        <span class="cov0" title="0">if len(interests) &gt; 0 </span><span class="cov0" title="0">{
                massRow := []tgbotapi.InlineKeyboardButton{
                        tgbotapi.NewInlineKeyboardButtonData(
                                "✅ "+e.service.Localizer.Get(interfaceLang, "select_all_in_category"),
                                "isolated_select_all_"+categoryKey,
                        ),
                        tgbotapi.NewInlineKeyboardButtonData(
                                "❌ "+e.service.Localizer.Get(interfaceLang, "clear_all_in_category"),
                                "isolated_clear_all_"+categoryKey,
                        ),
                }
                buttonRows = append(buttonRows, massRow)
        }</span>

        // Навигация
        <span class="cov0" title="0">navRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "⬅️ "+e.service.Localizer.Get(interfaceLang, "back_to_categories"),
                        "isolated_edit_categories",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "🏠 "+e.service.Localizer.Get(interfaceLang, "back_to_edit_menu"),
                        "isolated_main_menu",
                ),
        }
        buttonRows = append(buttonRows, navRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// createChangesPreviewKeyboard создает клавиатуру для предварительного просмотра изменений
func (e *IsolatedInterestEditor) createChangesPreviewKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Основные действия
        mainRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "💾 "+e.service.Localizer.Get(interfaceLang, "save_changes"),
                        "isolated_save_changes",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "↩️ "+e.service.Localizer.Get(interfaceLang, "undo_last_change"),
                        "isolated_undo_last",
                ),
        }
        buttonRows = append(buttonRows, mainRow)

        // Навигация
        navRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "🏠 "+e.service.Localizer.Get(interfaceLang, "back_to_edit_menu"),
                        "isolated_main_menu",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "❌ "+e.service.Localizer.Get(interfaceLang, "cancel_edit"),
                        "isolated_cancel_edit",
                ),
        }
        buttonRows = append(buttonRows, navRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)
}</span>

// createEditPrimaryInterestsKeyboard создает клавиатуру для редактирования основных интересов
func (e *IsolatedInterestEditor) createEditPrimaryInterestsKeyboard(selections []models.InterestSelection, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Сортируем только по ID для стабильного порядка
        sort.Slice(selections, func(i, j int) bool </span><span class="cov0" title="0">{
                return selections[i].InterestID &lt; selections[j].InterestID
        }</span>)

        // Создаем кнопки для каждого выбранного интереса
        <span class="cov0" title="0">for i := 0; i &lt; len(selections); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                selection1 := selections[i]
                interest1, err := e.interestService.GetInterestByID(selection1.InterestID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">interestName1 := e.service.Localizer.Get(interfaceLang, "interest_"+interest1.KeyName)
                prefix1 := "☐ "
                if selection1.IsPrimary </span><span class="cov0" title="0">{
                        prefix1 = "⭐ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "isolated_toggle_primary_"+strconv.Itoa(selection1.InterestID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(selections) </span><span class="cov0" title="0">{
                        selection2 := selections[i+1]
                        interest2, err := e.interestService.GetInterestByID(selection2.InterestID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">interestName2 := e.service.Localizer.Get(interfaceLang, "interest_"+interest2.KeyName)
                        prefix2 := "☐ "
                        if selection2.IsPrimary </span><span class="cov0" title="0">{
                                prefix2 = "⭐ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "isolated_toggle_primary_"+strconv.Itoa(selection2.InterestID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Навигация
        <span class="cov0" title="0">navRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        "🏠 "+e.service.Localizer.Get(interfaceLang, "back_to_edit_menu"),
                        "isolated_main_menu",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        "🎯 "+e.service.Localizer.Get(interfaceLang, "edit_interests_by_category"),
                        "isolated_edit_categories",
                ),
        }
        buttonRows = append(buttonRows, navRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// Вспомогательные методы

func (e *IsolatedInterestEditor) getCategoryProgress(session *EditSession, categoryKey string) string <span class="cov0" title="0">{
        // Подсчитываем количество выбранных интересов в категории
        count := 0
        for range session.CurrentSelections </span><span class="cov0" title="0">{
                // TODO: Добавить проверку категории интереса
                count++
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return "☐"
        }</span> else<span class="cov0" title="0"> if count &lt; 3 </span><span class="cov0" title="0">{
                return "◐"
        }</span> else<span class="cov0" title="0"> {
                return "◉"
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "fmt"
        "sort"
        "strconv"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для символов.
const (
        SymbolUnchecked = "☐ "
)

// Константы для callback команд.
const (
        CallbackBackToMainMenu     = "back_to_main_menu"
        CallbackBackToPreviousStep = "back_to_previous_step"
)

// TemporaryInterestSelection представляет временный выбор интереса пользователем.
type TemporaryInterestSelection struct {
        InterestID     int
        IsPrimary      bool
        SelectionOrder int
}

// KeyboardBuilder создает различные типы клавиатур для Telegram.
type KeyboardBuilder struct {
        service *core.BotService
}

// NewKeyboardBuilder создает новый экземпляр KeyboardBuilder.
func NewKeyboardBuilder(service *core.BotService) *KeyboardBuilder <span class="cov0" title="0">{
        return &amp;KeyboardBuilder{
                service: service,
        }
}</span>

// CreateLanguageKeyboard создает клавиатуру выбора языка.
func (kb *KeyboardBuilder) CreateLanguageKeyboard(
        interfaceLang,
        keyboardType string,
        excludeLang string,
        showBackButton bool,
) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        // Получаем языки из кэша или БД
        languages, err := kb.service.GetCachedLanguages(interfaceLang)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback на хардкод если кэш не работает
                languages = []*models.Language{
                        {ID: localization.LanguageIDEnglish, Code: "en", NameNative: "English", NameEn: "English"},
                        {ID: localization.LanguageIDRussian, Code: "ru", NameNative: "Русский", NameEn: "Russian"},
                        {ID: localization.LanguageIDSpanish, Code: "es", NameNative: "Español", NameEn: "Spanish"},
                        {ID: localization.LanguageIDChinese, Code: "zh", NameNative: "中文", NameEn: "Chinese"},
                }
        }</span>

        // Используем Map для автоматического удаления дубликатов
        <span class="cov0" title="0">uniqueButtons := make(map[string]tgbotapi.InlineKeyboardButton)

        for _, lang := range languages </span><span class="cov0" title="0">{
                // Исключаем указанный язык из списка
                if lang.Code == excludeLang </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Получаем флаг для языка
                <span class="cov0" title="0">flag := getLanguageFlag(lang.Code)
                name := kb.service.Localizer.GetLanguageName(lang.Code, interfaceLang)
                label := fmt.Sprintf("%s %s", flag, name)
                callbackData := fmt.Sprintf("lang_%s_%s", keyboardType, lang.Code)

                // Избегаем дубликатов по callback data (на случай если название языка совпадает)
                if _, exists := uniqueButtons[callbackData]; !exists </span><span class="cov0" title="0">{
                        button := tgbotapi.NewInlineKeyboardButtonData(label, callbackData)
                        uniqueButtons[callbackData] = button
                }</span>
        }

        // Преобразуем map в массив кнопок
        <span class="cov0" title="0">buttons := make([][]tgbotapi.InlineKeyboardButton, 0, len(uniqueButtons))
        for _, button := range uniqueButtons </span><span class="cov0" title="0">{
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{button})
        }</span>

        // Добавляем кнопку "Назад", если это необходимо
        <span class="cov0" title="0">if showBackButton </span><span class="cov0" title="0">{
                var backCallback string
                if keyboardType == "interface" || keyboardType == "native" </span><span class="cov0" title="0">{
                        backCallback = CallbackBackToMainMenu
                }</span> else<span class="cov0" title="0"> {
                        backCallback = CallbackBackToPreviousStep
                }</span>

                <span class="cov0" title="0">backButton := tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        backCallback,
                )
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{backButton})</span>
        }

        <span class="cov0" title="0">return tgbotapi.NewInlineKeyboardMarkup(buttons...)</span>
}

// CreateInterestsKeyboard создает клавиатуру для выбора интересов.
func (kb *KeyboardBuilder) CreateInterestsKeyboard(
        interests map[int]string,
        selectedInterests []int,
        interfaceLang string,
) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        // Создаем карту для быстрого поиска выбранных интересов
        selectedMap := make(map[int]bool)
        for _, id := range selectedInterests </span><span class="cov0" title="0">{
                selectedMap[id] = true
        }</span>

        // Сортируем интересы по ID для стабильного порядка
        <span class="cov0" title="0">type interestPair struct {
                id   int
                name string
        }

        sortedInterests := make([]interestPair, 0, len(interests))
        for id, name := range interests </span><span class="cov0" title="0">{
                sortedInterests = append(sortedInterests, interestPair{id, name})
        }</span>

        <span class="cov0" title="0">sort.Slice(sortedInterests, func(i, j int) bool </span><span class="cov0" title="0">{
                return sortedInterests[i].id &lt; sortedInterests[j].id
        }</span>)

        <span class="cov0" title="0">buttons := make([][]tgbotapi.InlineKeyboardButton, 0, len(sortedInterests))

        for _, interest := range sortedInterests </span><span class="cov0" title="0">{
                label := interest.name
                if selectedMap[interest.id] </span><span class="cov0" title="0">{
                        label = "✅ " + label
                }</span>

                <span class="cov0" title="0">button := tgbotapi.NewInlineKeyboardButtonData(
                        label,
                        fmt.Sprintf("interest_%d", interest.id),
                )
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{button})</span>
        }

        // Добавляем кнопку "Продолжить"
        <span class="cov0" title="0">continueButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "interests_continue"),
                "interests_continue",
        )
        buttons = append(buttons, []tgbotapi.InlineKeyboardButton{continueButton})

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)</span>
}

// CreateMainMenuKeyboard создает главное меню.
func (kb *KeyboardBuilder) CreateMainMenuKeyboard(interfaceLang string, hasProfile bool) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        changeLang := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "main_menu_change_lang"),
                "main_change_language",
        )
        feedback := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "main_menu_feedback"),
                "main_feedback",
        )

        var buttons [][]tgbotapi.InlineKeyboardButton

        if hasProfile </span><span class="cov0" title="0">{
                // У пользователя есть профиль - показываем обычные кнопки
                viewProfile := tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "main_menu_view_profile"),
                        "main_view_profile",
                )
                editProfile := tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "main_menu_edit_profile"),
                        "main_edit_profile",
                )
                buttons = [][]tgbotapi.InlineKeyboardButton{
                        {viewProfile, editProfile},
                        {changeLang, feedback},
                }
        }</span> else<span class="cov0" title="0"> {
                // У пользователя нет профиля - показываем большую кнопку "Создать профиль"
                createProfile := tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "main_menu_create_profile"),
                        "start_profile_setup",
                )
                buttons = [][]tgbotapi.InlineKeyboardButton{
                        {createProfile},
                        {changeLang, feedback},
                }
        }</span>

        <span class="cov0" title="0">return tgbotapi.NewInlineKeyboardMarkup(buttons...)</span>
}

// CreateProfileMenuKeyboard создает меню профиля.
func (kb *KeyboardBuilder) CreateProfileMenuKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        // Кнопки для управления профилем
        editInterestsIsolated := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_edit_interests_isolated"),
                "isolated_edit_start",
        )
        editLanguages := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_edit_languages"),
                "edit_languages",
        )
        changeInterfaceLang := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "main_menu_change_lang"),
                "main_change_language",
        )
        editAvailability := tgbotapi.NewInlineKeyboardButtonData(
                "⏰ "+kb.service.Localizer.Get(interfaceLang, "edit_availability"),
                "edit_availability",
        )
        reconfig := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_reconfigure"),
                "profile_reset_ask",
        )
        backToMain := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "back_to_main"),
                "back_to_main_menu",
        )

        // Шесть рядов: интересы, доступность, языки, язык интерфейса, сброс, главное меню
        buttons := [][]tgbotapi.InlineKeyboardButton{
                {editInterestsIsolated},
                {editAvailability},
                {editLanguages},
                {changeInterfaceLang},
                {reconfig},
                {backToMain},
        }

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)
}</span>

// CreateResetConfirmKeyboard создает клавиатуру подтверждения сброса.
func (kb *KeyboardBuilder) CreateResetConfirmKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        yes := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_reset_yes"),
                "profile_reset_yes",
        )
        no := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_reset_no"),
                "profile_reset_no",
        )

        return tgbotapi.NewInlineKeyboardMarkup([][]tgbotapi.InlineKeyboardButton{{yes}, {no}}...)
}</span>

// CreateLanguageLevelKeyboardWithPrefix создает клавиатуру уровня языка с кастомным префиксом.
func (kb *KeyboardBuilder) CreateLanguageLevelKeyboardWithPrefix(interfaceLang, targetLanguage, prefix string, showBackButton bool) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        levels := []string{"beginner", "elementary", "intermediate", "upper_intermediate"}

        buttons := make([][]tgbotapi.InlineKeyboardButton, 0, len(levels))

        for _, level := range levels </span><span class="cov0" title="0">{
                text := kb.service.Localizer.Get(interfaceLang, "choose_level_"+level)
                callback := prefix + level
                button := tgbotapi.NewInlineKeyboardButtonData(text, callback)
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{button})
        }</span>

        <span class="cov0" title="0">if showBackButton </span><span class="cov0" title="0">{
                backButton := tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        CallbackBackToPreviousStep,
                )
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{backButton})
        }</span>

        <span class="cov0" title="0">return tgbotapi.NewInlineKeyboardMarkup(buttons...)</span>
}

// CreateProfileCompletedKeyboard создает клавиатуру для завершенного профиля.
func (kb *KeyboardBuilder) CreateProfileCompletedKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        viewProfileButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_completed_view"),
                "profile_show",
        )
        mainMenuButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_completed_main"),
                "back_to_main_menu",
        )

        buttons := [][]tgbotapi.InlineKeyboardButton{
                {viewProfileButton, mainMenuButton},
        }

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)
}</span>

// CreateAvailabilitySetupKeyboard создает клавиатуру для перехода к настройке доступности
func (kb *KeyboardBuilder) CreateAvailabilitySetupKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        setupAvailabilityButton := tgbotapi.NewInlineKeyboardButtonData(
                "⏰ "+kb.service.Localizer.Get(interfaceLang, "setup_availability_button"),
                "setup_availability",
        )

        viewProfileButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_show"),
                "profile_show",
        )

        mainMenuButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_completed_main"),
                "back_to_main_menu",
        )

        buttons := [][]tgbotapi.InlineKeyboardButton{
                {setupAvailabilityButton},
                {viewProfileButton, mainMenuButton},
        }

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)
}</span>

// CreateEditLanguagesKeyboard создает клавиатуру для редактирования языков.
func (kb *KeyboardBuilder) CreateEditLanguagesKeyboard(interfaceLang, nativeLang, targetLang, level string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttons [][]tgbotapi.InlineKeyboardButton

        // Родной язык
        nativeName := kb.service.Localizer.GetLanguageName(nativeLang, interfaceLang)
        nativeButton := tgbotapi.NewInlineKeyboardButtonData(
                fmt.Sprintf("🏠 %s: %s", kb.service.Localizer.Get(interfaceLang, "profile_field_native"), nativeName),
                "edit_native_lang",
        )
        buttons = append(buttons, []tgbotapi.InlineKeyboardButton{nativeButton})

        // Изучаемый язык (только если родной язык - русский)
        if nativeLang == "ru" </span><span class="cov0" title="0">{
                targetName := kb.service.Localizer.GetLanguageName(targetLang, interfaceLang)
                targetButton := tgbotapi.NewInlineKeyboardButtonData(
                        fmt.Sprintf("📚 %s: %s", kb.service.Localizer.Get(interfaceLang, "profile_field_target"), targetName),
                        "edit_target_lang",
                )
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{targetButton})
        }</span>

        // Уровень владения языком
        <span class="cov0" title="0">if level != "" </span><span class="cov0" title="0">{
                levelName := kb.service.Localizer.Get(interfaceLang, "choose_level_"+level)
                levelButton := tgbotapi.NewInlineKeyboardButtonData(
                        fmt.Sprintf("🎯 %s: %s", kb.service.Localizer.Get(interfaceLang, "level_label"), levelName),
                        "edit_level",
                )
                buttons = append(buttons, []tgbotapi.InlineKeyboardButton{levelButton})
        }</span>

        // Кнопки сохранить/отменить
        <span class="cov0" title="0">saveButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "save_button"),
                "save_edits",
        )
        cancelButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "cancel_button"),
                "cancel_edits",
        )

        buttons = append(buttons, []tgbotapi.InlineKeyboardButton{saveButton, cancelButton})

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)</span>
}

// CreateSaveEditsKeyboard создает клавиатуру для сохранения/отмены изменений.
func (kb *KeyboardBuilder) CreateSaveEditsKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        saveButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "save_button"),
                "save_edits",
        )
        cancelButton := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "cancel_button"),
                "cancel_edits",
        )

        return tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{saveButton, cancelButton})
}</span>

// CreateFeedbackAdminKeyboard создает клавиатуру для управления отзывами (временная заглушка).
func (kb *KeyboardBuilder) CreateFeedbackAdminKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        // Временная реализация, которая будет обновлена при переносе статистики
        buttons := [][]tgbotapi.InlineKeyboardButton{
                {tgbotapi.NewInlineKeyboardButtonData("🆕 Активные", "show_active_feedbacks")},
                {tgbotapi.NewInlineKeyboardButtonData("📚 Архив", "show_archive_feedbacks")},
                {tgbotapi.NewInlineKeyboardButtonData("📋 Все", "show_all_feedbacks")},
        }

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)
}</span>

// getLanguageFlag возвращает флаг для языка.
func getLanguageFlag(langCode string) string <span class="cov0" title="0">{
        switch langCode </span>{
        case "ru":<span class="cov0" title="0">
                return "🇷🇺"</span>
        case "en":<span class="cov0" title="0">
                return "🇺🇸"</span>
        case "es":<span class="cov0" title="0">
                return "🇪🇸"</span>
        case "zh":<span class="cov0" title="0">
                return "🇨🇳"</span>
        default:<span class="cov0" title="0">
                return "🌍"</span>
        }
}

// CreateInterestCategoriesKeyboard создает клавиатуру для выбора категорий интересов.
func (kb *KeyboardBuilder) CreateInterestCategoriesKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        categories := []struct {
                key  string
                icon string
        }{
                {"entertainment", "🎬"},
                {"education", "📚"},
                {"active", "⚽"},
                {"creative", "🎨"},
                {"social", "👥"},
        }

        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Создаем кнопки категорий (по 2 в ряд)
        for i := 0; i &lt; len(categories); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                categoryName := kb.service.Localizer.Get(interfaceLang, "category_"+categories[i].key)
                button1 := tgbotapi.NewInlineKeyboardButtonData(
                        categoryName,
                        "interest_category_"+categories[i].key,
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(categories) </span><span class="cov0" title="0">{
                        categoryName2 := kb.service.Localizer.Get(interfaceLang, "category_"+categories[i+1].key)
                        button2 := tgbotapi.NewInlineKeyboardButtonData(
                                categoryName2,
                                "interest_category_"+categories[i+1].key,
                        )
                        row = append(row, button2)
                }</span>

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "continue_button"),
                        "interests_continue",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        "back_to_language_level",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreateCategoryInterestsKeyboard создает клавиатуру для выбора интересов в категории.
func (kb *KeyboardBuilder) CreateCategoryInterestsKeyboard(interests []models.Interest, selectedMap map[int]bool, categoryKey, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Сортируем интересы по display_order
        sort.Slice(interests, func(i, j int) bool </span><span class="cov0" title="0">{
                return interests[i].DisplayOrder &lt; interests[j].DisplayOrder
        }</span>)

        // Создаем кнопки интересов (по 2 в ряд)
        <span class="cov0" title="0">for i := 0; i &lt; len(interests); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                interest1 := interests[i]
                interestName1 := kb.service.Localizer.Get(interfaceLang, "interest_"+interest1.KeyName)

                prefix1 := SymbolUnchecked
                if selectedMap[interest1.ID] </span><span class="cov0" title="0">{
                        prefix1 = "✅ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "edit_interest_select_"+strconv.Itoa(interest1.ID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(interests) </span><span class="cov0" title="0">{
                        interest2 := interests[i+1]
                        interestName2 := kb.service.Localizer.Get(interfaceLang, "interest_"+interest2.KeyName)

                        prefix2 := SymbolUnchecked
                        if selectedMap[interest2.ID] </span><span class="cov0" title="0">{
                                prefix2 = "✅ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "edit_interest_select_"+strconv.Itoa(interest2.ID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопку "К категориям" для возврата к редактированию интересов
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "to_categories_button"),
                        "back_to_categories",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreatePrimaryInterestsKeyboard создает клавиатуру для выбора основных интересов.
//
//nolint:funlen
func (kb *KeyboardBuilder) CreatePrimaryInterestsKeyboard(selections interface{}, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Получаем локализованные названия интересов
        localizedInterests, err := kb.service.GetCachedInterests(interfaceLang)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback - создаем пустую карту
                localizedInterests = make(map[int]string)
        }</span>

        // Приводим к правильному типу
        <span class="cov0" title="0">var tempSelections []TemporaryInterestSelection
        if tempSelectionsInterface, ok := selections.([]TemporaryInterestSelection); ok </span><span class="cov0" title="0">{
                tempSelections = tempSelectionsInterface
        }</span> else<span class="cov0" title="0"> if modelsSelections, ok := selections.([]models.InterestSelection); ok </span><span class="cov0" title="0">{
                // Конвертируем из models.InterestSelection в TemporaryInterestSelection
                for _, sel := range modelsSelections </span><span class="cov0" title="0">{
                        tempSelections = append(tempSelections, TemporaryInterestSelection{
                                InterestID:     sel.InterestID,
                                IsPrimary:      sel.IsPrimary,
                                SelectionOrder: sel.SelectionOrder,
                        })
                }</span>
        }

        // Сортируем выборы по порядку выбора
        <span class="cov0" title="0">sort.Slice(tempSelections, func(i, j int) bool </span><span class="cov0" title="0">{
                return tempSelections[i].SelectionOrder &lt; tempSelections[j].SelectionOrder
        }</span>)

        // Создаем кнопки для каждого выбранного интереса
        <span class="cov0" title="0">for i := 0; i &lt; len(tempSelections); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                selection1 := tempSelections[i]
                // Получаем локализованное название интереса
                interestName1, exists := localizedInterests[selection1.InterestID]
                if !exists </span><span class="cov0" title="0">{
                        // Fallback: пытаемся получить через getInterestName
                        var err error
                        interestName1, err = kb.getInterestName(selection1.InterestID, interfaceLang)
                        if err != nil </span><span class="cov0" title="0">{
                                interestName1 = fmt.Sprintf("Интерес %d", selection1.InterestID)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Проверяем, что это не просто key_name (английское название)
                        // Если название совпадает с key_name, пытаемся найти перевод
                        interest, err := kb.service.DB.GetInterestByID(selection1.InterestID)
                        if err == nil </span><span class="cov0" title="0">{
                                // Всегда пытаемся найти перевод в JSON файлах
                                translatedName := kb.service.Localizer.Get(interfaceLang, "interest_"+interest.KeyName)
                                if translatedName != "interest_"+interest.KeyName </span><span class="cov0" title="0">{
                                        interestName1 = translatedName
                                }</span>
                        }
                }

                <span class="cov0" title="0">prefix1 := SymbolUnchecked
                if selection1.IsPrimary </span><span class="cov0" title="0">{
                        prefix1 = "⭐ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "primary_interest_"+strconv.Itoa(selection1.InterestID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(tempSelections) </span><span class="cov0" title="0">{
                        selection2 := tempSelections[i+1]

                        // Получаем локализованное название интереса
                        interestName2, exists := localizedInterests[selection2.InterestID]
                        if !exists </span><span class="cov0" title="0">{
                                // Fallback: пытаемся получить через getInterestName
                                var err error
                                interestName2, err = kb.getInterestName(selection2.InterestID, interfaceLang)
                                if err != nil </span><span class="cov0" title="0">{
                                        interestName2 = fmt.Sprintf("Интерес %d", selection2.InterestID)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Проверяем, что это не просто key_name (английское название)
                                // Если название совпадает с key_name, пытаемся найти перевод
                                interest, err := kb.service.DB.GetInterestByID(selection2.InterestID)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Всегда пытаемся найти перевод в JSON файлах
                                        translatedName := kb.service.Localizer.Get(interfaceLang, "interest_"+interest.KeyName)
                                        if translatedName != "interest_"+interest.KeyName </span><span class="cov0" title="0">{
                                                interestName2 = translatedName
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">prefix2 := SymbolUnchecked
                        if selection2.IsPrimary </span><span class="cov0" title="0">{
                                prefix2 = "⭐ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "primary_interest_"+strconv.Itoa(selection2.InterestID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "continue_button"),
                        "primary_interests_continue",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        "back_to_interests",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreateEditInterestCategoriesKeyboard создает клавиатуру для выбора категорий в режиме редактирования.
func (kb *KeyboardBuilder) CreateEditInterestCategoriesKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        categories := []struct {
                key  string
                icon string
        }{
                {"entertainment", "🎬"},
                {"education", "📚"},
                {"active", "⚽"},
                {"creative", "🎨"},
                {"social", "👥"},
        }

        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Создаем кнопки категорий (по 2 в ряд)
        for i := 0; i &lt; len(categories); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                categoryName := kb.service.Localizer.Get(interfaceLang, "category_"+categories[i].key)
                button1 := tgbotapi.NewInlineKeyboardButtonData(
                        categoryName,
                        "edit_interest_category_"+categories[i].key,
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(categories) </span><span class="cov0" title="0">{
                        categoryName2 := kb.service.Localizer.Get(interfaceLang, "category_"+categories[i+1].key)
                        button2 := tgbotapi.NewInlineKeyboardButtonData(
                                categoryName2,
                                "edit_interest_category_"+categories[i+1].key,
                        )
                        row = append(row, button2)
                }</span>

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления для режима редактирования
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "continue_button"),
                        "interests_continue",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "cancel_button"),
                        "back_to_profile",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreateEditPrimaryInterestsKeyboard создает клавиатуру для выбора основных интересов в режиме редактирования.
func (kb *KeyboardBuilder) CreateEditPrimaryInterestsKeyboard(selections interface{}, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Получаем локализованные названия интересов
        localizedInterests, err := kb.service.GetCachedInterests(interfaceLang)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback - создаем пустую карту
                localizedInterests = make(map[int]string)
        }</span>

        // Конвертируем selections в нужный формат
        <span class="cov0" title="0">var tempSelections []struct {
                InterestID int
                IsPrimary  bool
        }

        switch s := selections.(type) </span>{
        case []models.InterestSelection:<span class="cov0" title="0">
                for _, selection := range s </span><span class="cov0" title="0">{
                        tempSelections = append(tempSelections, struct {
                                InterestID int
                                IsPrimary  bool
                        }{
                                InterestID: selection.InterestID,
                                IsPrimary:  selection.IsPrimary,
                        })
                }</span>
        }

        // Сортируем: сначала основные, потом дополнительные
        <span class="cov0" title="0">sort.Slice(tempSelections, func(i, j int) bool </span><span class="cov0" title="0">{
                if tempSelections[i].IsPrimary != tempSelections[j].IsPrimary </span><span class="cov0" title="0">{
                        return tempSelections[i].IsPrimary
                }</span>
                <span class="cov0" title="0">return tempSelections[i].InterestID &lt; tempSelections[j].InterestID</span>
        })

        // Создаем кнопки для каждого выбранного интереса
        <span class="cov0" title="0">for i := 0; i &lt; len(tempSelections); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                selection1 := tempSelections[i]
                // Получаем локализованное название интереса
                interestName1, exists := localizedInterests[selection1.InterestID]
                if !exists </span><span class="cov0" title="0">{
                        // Fallback: пытаемся получить через getInterestName
                        var err error
                        interestName1, err = kb.getInterestName(selection1.InterestID, interfaceLang)
                        if err != nil </span><span class="cov0" title="0">{
                                interestName1 = fmt.Sprintf("Интерес %d", selection1.InterestID)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Проверяем, что это не просто key_name (английское название)
                        // Если название совпадает с key_name, пытаемся найти перевод
                        interest, err := kb.service.DB.GetInterestByID(selection1.InterestID)
                        if err == nil </span><span class="cov0" title="0">{
                                // Всегда пытаемся найти перевод в JSON файлах
                                translatedName := kb.service.Localizer.Get(interfaceLang, "interest_"+interest.KeyName)
                                if translatedName != "interest_"+interest.KeyName </span><span class="cov0" title="0">{
                                        interestName1 = translatedName
                                }</span>
                        }
                }

                <span class="cov0" title="0">prefix1 := SymbolUnchecked
                if selection1.IsPrimary </span><span class="cov0" title="0">{
                        prefix1 = "⭐ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "edit_primary_interest_"+strconv.Itoa(selection1.InterestID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(tempSelections) </span><span class="cov0" title="0">{
                        selection2 := tempSelections[i+1]

                        // Получаем локализованное название интереса
                        interestName2, exists := localizedInterests[selection2.InterestID]
                        if !exists </span><span class="cov0" title="0">{
                                // Fallback: пытаемся получить через getInterestName
                                var err error
                                interestName2, err = kb.getInterestName(selection2.InterestID, interfaceLang)
                                if err != nil </span><span class="cov0" title="0">{
                                        interestName2 = fmt.Sprintf("Интерес %d", selection2.InterestID)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Проверяем, что это не просто key_name (английское название)
                                // Если название совпадает с key_name, пытаемся найти перевод
                                interest, err := kb.service.DB.GetInterestByID(selection2.InterestID)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Всегда пытаемся найти перевод в JSON файлах
                                        translatedName := kb.service.Localizer.Get(interfaceLang, "interest_"+interest.KeyName)
                                        if translatedName != "interest_"+interest.KeyName </span><span class="cov0" title="0">{
                                                interestName2 = translatedName
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">prefix2 := SymbolUnchecked
                        if selection2.IsPrimary </span><span class="cov0" title="0">{
                                prefix2 = "⭐ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "edit_primary_interest_"+strconv.Itoa(selection2.InterestID),
                        )
                        row = append(row, button2)</span>
                }
                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления для режима редактирования
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "to_categories_button"),
                        "back_to_categories",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "cancel_button"),
                        "back_to_profile",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "save_button"),
                        "save_interest_edits",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreateEditCategoryInterestsKeyboard создает клавиатуру для редактирования интересов в категории.
func (kb *KeyboardBuilder) CreateEditCategoryInterestsKeyboard(interests []models.Interest, selectedMap map[int]bool, categoryKey, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Сортируем интересы по display_order
        sort.Slice(interests, func(i, j int) bool </span><span class="cov0" title="0">{
                return interests[i].DisplayOrder &lt; interests[j].DisplayOrder
        }</span>)

        // Создаем кнопки интересов (по 2 в ряд)
        <span class="cov0" title="0">for i := 0; i &lt; len(interests); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                interest1 := interests[i]
                interestName1 := kb.service.Localizer.Get(interfaceLang, "interest_"+interest1.KeyName)

                prefix1 := SymbolUnchecked
                if selectedMap[interest1.ID] </span><span class="cov0" title="0">{
                        prefix1 = "✅ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "edit_interest_select_"+strconv.Itoa(interest1.ID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(interests) </span><span class="cov0" title="0">{
                        interest2 := interests[i+1]
                        interestName2 := kb.service.Localizer.Get(interfaceLang, "interest_"+interest2.KeyName)

                        prefix2 := SymbolUnchecked
                        if selectedMap[interest2.ID] </span><span class="cov0" title="0">{
                                prefix2 = "✅ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "edit_interest_select_"+strconv.Itoa(interest2.ID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем только кнопку "Назад" для возврата к редактированию интересов
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        "back_to_edit_categories",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// getInterestName получает название интереса из базы данных.
func (kb *KeyboardBuilder) getInterestName(interestID int, interfaceLang string) (string, error) <span class="cov0" title="0">{
        // Получаем все интересы из кэша
        interests, err := kb.service.GetCachedInterests(interfaceLang)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Ищем интерес по ID
        <span class="cov0" title="0">if name, exists := interests[interestID]; exists </span><span class="cov0" title="0">{
                return name, nil
        }</span>

        // Fallback: пытаемся получить из базы данных напрямую
        <span class="cov0" title="0">interest, err := kb.service.DB.GetInterestByID(interestID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Интерес %d", interestID), nil
        }</span>

        // Пытаемся получить локализованное название через ключ
        <span class="cov0" title="0">interestName := kb.service.Localizer.Get(interfaceLang, "interest_"+interest.KeyName)
        if interestName != "interest_"+interest.KeyName </span><span class="cov0" title="0">{
                return interestName, nil
        }</span>

        // Последний fallback - используем key_name из базы данных
        <span class="cov0" title="0">return interest.KeyName, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "fmt"
        "log"

        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// LanguageHandler интерфейс для обработки language операций.
type LanguageHandler interface {
        HandleLanguagesContinueFilling(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleLanguagesReselect(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleLanguageLevelSelection(callback *tgbotapi.CallbackQuery, user *models.User, levelCode string) error
        HandleBackToLanguageLevel(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleNativeLanguageCallback(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleTargetLanguageCallback(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleInterfaceLanguageSelection(callback *tgbotapi.CallbackQuery, user *models.User, langCode string) error
}

// LanguageHandlerImpl реализация обработчика language операций.
type LanguageHandlerImpl struct {
        base *BaseHandler
}

// NewLanguageHandler создает новый обработчик language операций.
func NewLanguageHandler(base *BaseHandler) *LanguageHandlerImpl <span class="cov0" title="0">{
        return &amp;LanguageHandlerImpl{
                base: base,
        }
}</span>

// HandleLanguagesContinueFilling продолжает заполнение профиля после выбора языков.
func (lh *LanguageHandlerImpl) HandleLanguagesContinueFilling(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Очищаем старые интересы при переходе к выбору интересов
        err := lh.base.service.DB.ClearUserInterests(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                lh.base.service.LoggingService.Database().WarnWithContext(
                        "Could not clear user interests",
                        generateRequestID("HandleLanguagesContinueFilling"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleLanguagesContinueFilling",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
        }</span>

        // Предлагаем выбрать уровень владения языком
        <span class="cov0" title="0">langName := lh.base.service.Localizer.GetLanguageName(user.TargetLanguageCode, user.InterfaceLanguageCode)
        title := lh.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "choose_level_title", map[string]string{
                "language": langName,
        })

        keyboard := lh.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, user.TargetLanguageCode, "level_", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                title,
                keyboard,
        )
        _, err = lh.base.bot.Request(editMsg)

        return err</span>
}

// HandleLanguagesReselect обрабатывает повторный выбор языков.
func (lh *LanguageHandlerImpl) HandleLanguagesReselect(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Сбрасываем выбор языков
        user.NativeLanguageCode = ""
        user.TargetLanguageCode = ""
        user.TargetLanguageLevel = ""

        // Обновляем статус пользователя
        if err := lh.base.service.DB.UpdateUserNativeLanguage(user.ID, ""); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to reset native language for user %d: %v", user.ID, err)
        }</span>
        <span class="cov0" title="0">if err := lh.base.service.DB.UpdateUserTargetLanguage(user.ID, ""); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to reset target language for user %d: %v", user.ID, err)
        }</span>
        <span class="cov0" title="0">if err := lh.base.service.DB.UpdateUserTargetLanguageLevel(user.ID, ""); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to reset target language level for user %d: %v", user.ID, err)
        }</span>

        // Предлагаем выбрать родной язык снова
        <span class="cov0" title="0">text := lh.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_native_language")
        keyboard := lh.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "native", "", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )
        _, err := lh.base.bot.Request(editMsg)

        return err</span>
}

// HandleLanguageLevelSelection обрабатывает выбор уровня владения языком.
func (lh *LanguageHandlerImpl) HandleLanguageLevelSelection(callback *tgbotapi.CallbackQuery, user *models.User, levelCode string) error <span class="cov0" title="0">{
        // Сохраняем уровень владения языком
        err := lh.base.service.DB.UpdateUserTargetLanguageLevel(user.ID, levelCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.TargetLanguageLevel = levelCode

        // Переходим к новой системе интересов
        levelName := lh.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_level_"+levelCode)
        confirmMsg := "🎯 " + levelName + "\n\n" + lh.base.service.Localizer.Get(user.InterfaceLanguageCode, "interests_new_system")

        // Очищаем предыдущие выборы интересов пользователя
        err = lh.base.service.DB.ClearUserInterests(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                lh.base.service.LoggingService.Database().WarnWithContext(
                        "Could not clear user interests",
                        generateRequestID("HandleLanguageLevelSelection"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleLanguageLevelSelection",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
        }</span>

        // Используем новую систему интересов
        <span class="cov0" title="0">keyboard := lh.base.keyboardBuilder.CreateInterestCategoriesKeyboard(user.InterfaceLanguageCode)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                confirmMsg,
                keyboard,
        )
        _, err = lh.base.bot.Request(editMsg)

        return err</span>
}

// HandleNativeLanguageCallback обрабатывает выбор родного языка.
func (lh *LanguageHandlerImpl) HandleNativeLanguageCallback(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        langCode := callback.Data[len("lang_native_"):]

        // Сохраняем родной язык
        err := lh.base.service.DB.UpdateUserNativeLanguage(user.ID, langCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.NativeLanguageCode = langCode

        // Обновляем статус пользователя
        err = lh.base.service.DB.UpdateUserState(user.ID, models.StateWaitingLanguage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Переход к следующему шагу онбординга
        <span class="cov0" title="0">return lh.proceedToNextOnboardingStep(callback, user, langCode)</span>
}

// proceedToNextOnboardingStep переходит к следующему шагу онбординга.
func (lh *LanguageHandlerImpl) proceedToNextOnboardingStep(callback *tgbotapi.CallbackQuery, user *models.User, nativeLangCode string) error <span class="cov0" title="0">{
        if nativeLangCode == "ru" </span><span class="cov0" title="0">{
                return lh.handleRussianNativeLanguage(callback, user)
        }</span>

        <span class="cov0" title="0">return lh.handleNonRussianNativeLanguage(callback, user, nativeLangCode)</span>
}

// handleRussianNativeLanguage обрабатывает случай, когда русский выбран как родной язык.
func (lh *LanguageHandlerImpl) handleRussianNativeLanguage(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Если выбран русский как родной, предлагаем выбрать изучаемый язык
        text := lh.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_target_language")

        // Исключаем русский из списка изучаемых языков
        keyboard := lh.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "target", "ru", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(callback.Message.Chat.ID, callback.Message.MessageID, text, keyboard)

        _, err := lh.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Обновляем статус для ожидания выбора изучаемого языка
        <span class="cov0" title="0">err = lh.base.service.DB.UpdateUserState(user.ID, models.StateWaitingTargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleNonRussianNativeLanguage обрабатывает случай, когда выбран не русский язык как родной.
func (lh *LanguageHandlerImpl) handleNonRussianNativeLanguage(callback *tgbotapi.CallbackQuery, user *models.User, nativeLangCode string) error <span class="cov0" title="0">{
        // Для всех других языков как родных автоматически устанавливаем русский как изучаемый
        err := lh.base.service.DB.UpdateUserTargetLanguage(user.ID, "ru")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.TargetLanguageCode = "ru"

        // Получаем название выбранного языка для сообщения
        nativeLangName := lh.base.service.Localizer.GetLanguageName(nativeLangCode, user.InterfaceLanguageCode)

        // Показываем сообщение о том, что русский язык установлен автоматически
        targetExplanation := lh.base.service.Localizer.GetWithParams(
                user.InterfaceLanguageCode,
                "target_language_explanation",
                map[string]string{
                        "native_lang": nativeLangName,
                },
        )

        // Предлагаем выбрать уровень владения русским языком
        langName := lh.base.service.Localizer.GetLanguageName(user.TargetLanguageCode, user.InterfaceLanguageCode)
        levelTitle := targetExplanation + "\n\n" + lh.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "choose_level_title", map[string]string{
                "language": langName,
        })

        keyboard := lh.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, user.TargetLanguageCode, "level_", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                levelTitle,
                keyboard,
        )

        _, err = lh.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Обновляем статус для ожидания выбора уровня
        <span class="cov0" title="0">err = lh.base.service.DB.UpdateUserState(user.ID, models.StateWaitingLanguageLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleTargetLanguageCallback обрабатывает выбор изучаемого языка.
func (lh *LanguageHandlerImpl) HandleTargetLanguageCallback(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        langCode := callback.Data[len("lang_target_"):]

        err := lh.base.service.DB.UpdateUserTargetLanguage(user.ID, langCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // ✅ ОЧИЩАЕМ СТАРЫЕ ИНТЕРЕСЫ при переходе к выбору интересов
        <span class="cov0" title="0">err = lh.base.service.DB.ClearUserInterests(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                lh.base.service.LoggingService.Database().WarnWithContext(
                        "Could not clear user interests",
                        generateRequestID("HandleTargetLanguageCallback"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleTargetLanguageCallback",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
        }</span>

        <span class="cov0" title="0">user.TargetLanguageCode = langCode
        langName := lh.base.service.Localizer.GetLanguageName(langCode, user.InterfaceLanguageCode)

        // Предлагаем выбрать уровень владения языком
        title := lh.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "choose_level_title", map[string]string{
                "language": langName,
        })

        keyboard := lh.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, langCode, "level_", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                title,
                keyboard,
        )
        _, err = lh.base.bot.Request(editMsg)

        return err</span>
}

// HandleInterfaceLanguageSelection обрабатывает выбор языка интерфейса.
func (lh *LanguageHandlerImpl) HandleInterfaceLanguageSelection(callback *tgbotapi.CallbackQuery, user *models.User, langCode string) error <span class="cov0" title="0">{
        if err := lh.base.service.DB.UpdateUserInterfaceLanguage(user.ID, langCode); err != nil </span><span class="cov0" title="0">{
                lh.base.service.LoggingService.Database().ErrorWithContext(
                        "Error updating interface language",
                        generateRequestID("HandleInterfaceLanguageSelection"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleInterfaceLanguageSelection",
                        map[string]interface{}{"userID": user.ID, "langCode": langCode, "error": err.Error()},
                )

                return err
        }</span>

        // Обновляем язык интерфейса пользователя и получаем новое сообщение
        <span class="cov0" title="0">user.InterfaceLanguageCode = langCode
        langName := lh.base.service.Localizer.GetLanguageName(langCode, langCode)
        text := fmt.Sprintf("%s\n\n%s: %s",
                lh.base.service.Localizer.Get(langCode, "choose_interface_language"),
                lh.base.service.Localizer.Get(langCode, "language_updated"),
                langName,
        )

        // Создаем клавиатуру с языками интерфейса (остальные кнопки остаются)
        keyboard := lh.base.keyboardBuilder.CreateLanguageKeyboard(langCode, "interface", "", true)

        // Редактируем сообщение, сохраняя клавиатуру
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )
        _, err := lh.base.bot.Request(editMsg)

        return err</span>
}

// HandleBackToLanguageLevel возвращает к выбору уровня языка.
func (lh *LanguageHandlerImpl) HandleBackToLanguageLevel(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Предлагаем выбрать уровень владения языком
        langName := lh.base.service.Localizer.GetLanguageName(user.TargetLanguageCode, user.InterfaceLanguageCode)
        title := lh.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "choose_level_title", map[string]string{
                "language": langName,
        })

        keyboard := lh.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, user.TargetLanguageCode, "level_", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                title,
                keyboard,
        )
        _, err := lh.base.bot.Request(editMsg)

        return err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "fmt"
        "log"

        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// MenuHandler обрабатывает команды и действия главного меню.
type MenuHandler struct {
        base *BaseHandler
}

// NewMenuHandler создает новый экземпляр MenuHandler.
func NewMenuHandler(base *BaseHandler) *MenuHandler <span class="cov0" title="0">{
        return &amp;MenuHandler{
                base: base,
        }
}</span>

// HandleStartCommand обрабатывает команду /start.
func (mh *MenuHandler) HandleStartCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        // Всегда показываем главное меню, независимо от состояния профиля
        welcomeText := mh.base.service.GetWelcomeMessage(user)
        menuText := welcomeText + "\n\n" + mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleMainMenuTitle)

        hasProfile := user.ProfileCompletionLevel &gt; 0
        keyboard := mh.base.keyboardBuilder.CreateMainMenuKeyboard(user.InterfaceLanguageCode, hasProfile)

        // Используем MessageFactory для отправки сообщения
        return mh.base.messageFactory.SendWithKeyboard(message.Chat.ID, menuText, keyboard)
}</span>

// HandleStatusCommand обрабатывает команду /status.
func (mh *MenuHandler) HandleStatusCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        statusText := fmt.Sprintf(
                "📊 %s:\n\n"+
                        "🆔 ID: %d\n"+
                        "📝 %s: %s\n"+
                        "🔄 %s: %s\n"+
                        "📈 %s: %d%%\n"+
                        "🌐 %s: %s",
                mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleYourStatus),
                user.ID,
                mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleStatus),
                user.Status,
                mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleState),
                user.State,
                mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleProfileCompletion),
                user.ProfileCompletionLevel,
                mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleInterfaceLanguage),
                user.InterfaceLanguageCode,
        )

        return mh.base.messageFactory.SendText(message.Chat.ID, statusText)
}</span>

// HandleResetCommand обрабатывает команду /reset.
func (mh *MenuHandler) HandleResetCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        return mh.base.messageFactory.SendText(message.Chat.ID, mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleProfileReset))
}</span>

// HandleLanguageCommand обрабатывает команду /language.
func (mh *MenuHandler) HandleLanguageCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        text := mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChooseInterfaceLanguage)
        keyboard := mh.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "interface", "", true)

        // Используем MessageFactory для отправки сообщения
        return mh.base.messageFactory.SendWithKeyboard(message.Chat.ID, text, keyboard)
}</span>

// HandleBackToMainMenu возвращает пользователя в главное меню.
func (mh *MenuHandler) HandleBackToMainMenu(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        welcomeText := mh.base.service.GetWelcomeMessage(user)
        menuText := welcomeText + "\n\n" + mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleMainMenuTitle)

        hasProfile := user.ProfileCompletionLevel &gt; 0
        keyboard := mh.base.keyboardBuilder.CreateMainMenuKeyboard(user.InterfaceLanguageCode, hasProfile)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                menuText,
                keyboard,
        )
        _, err := mh.base.bot.Request(editMsg)

        return err
}</span>

// HandleMainChangeLanguage обрабатывает смену языка интерфейса.
func (mh *MenuHandler) HandleMainChangeLanguage(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChooseInterfaceLanguage)
        keyboard := mh.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "interface", "", true)
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )
        _, err := mh.base.bot.Request(editMsg)

        return err
}</span>

// HandleMainViewProfile обрабатывает просмотр профиля.
func (mh *MenuHandler) HandleMainViewProfile(callback *tgbotapi.CallbackQuery, user *models.User, profileHandler *ProfileHandlerImpl) error <span class="cov0" title="0">{
        // Проверяем, заполнен ли профиль по уровню завершения профиля
        if user.ProfileCompletionLevel == 0 </span><span class="cov0" title="0">{
                // Профиль не заполнен - показываем информационное сообщение и кнопку настройки
                text := mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleEmptyProfileMessage)

                // Создаем клавиатуру с кнопками настройки профиля
                setupButton := tgbotapi.NewInlineKeyboardButtonData(
                        mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleSetupProfileButton),
                        "show_profile_setup_features",
                )

                keyboard := tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{setupButton})

                // Редактируем существующее сообщение вместо создания нового
                editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        text,
                        keyboard,
                )
                _, err := mh.base.bot.Request(editMsg)

                return err
        }</span>

        // Профиль заполнен - показываем его
        <span class="cov0" title="0">return profileHandler.HandleProfileShow(callback, user)</span>
}

// HandleMainEditProfile обрабатывает редактирование профиля.
func (mh *MenuHandler) HandleMainEditProfile(callback *tgbotapi.CallbackQuery, user *models.User, profileHandler *ProfileHandlerImpl) error <span class="cov0" title="0">{
        return profileHandler.HandleProfileResetAsk(callback, user)
}</span>

// HandleMainFeedback обрабатывает переход к отзывам.
func (mh *MenuHandler) HandleMainFeedback(callback *tgbotapi.CallbackQuery, user *models.User, feedbackHandler FeedbackHandler) error <span class="cov0" title="0">{
        // Переводим пользователя в состояние ожидания отзыва
        if err := mh.base.service.DB.UpdateUserState(user.ID, models.StateWaitingFeedback); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update user state to waiting feedback for user %d: %v", user.ID, err)
        }</span>

        // Получаем текст обратной связи
        <span class="cov0" title="0">text := mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleFeedbackText)

        // Создаем клавиатуру для обратной связи
        keyboard := mh.createFeedbackKeyboard(user.InterfaceLanguageCode)

        // Редактируем сообщение вместо отправки нового
        return mh.editMessageTextAndMarkup(callback.Message.Chat.ID, callback.Message.MessageID, text, &amp;keyboard)</span>
}

// HandleFeedbackHelp обрабатывает помощь по обратной связи.
func (mh *MenuHandler) HandleFeedbackHelp(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        helpTitle := mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleFeedbackHelpTitle)
        helpContent := mh.base.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleFeedbackHelpContent)
        helpText := helpTitle + "\n\n" + helpContent

        keyboard := mh.createFeedbackKeyboard(user.InterfaceLanguageCode)

        // Редактируем сообщение с помощью
        return mh.editMessageTextAndMarkup(callback.Message.Chat.ID, callback.Message.MessageID, helpText, &amp;keyboard)
}</span>

// createFeedbackKeyboard создает клавиатуру для обратной связи.
func (mh *MenuHandler) createFeedbackKeyboard(lang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        keyboard := [][]tgbotapi.InlineKeyboardButton{
                {
                        tgbotapi.NewInlineKeyboardButtonData(mh.base.service.Localizer.Get(lang, localization.LocaleFeedbackBackToMain), "back_to_main_menu"),
                },
                {
                        tgbotapi.NewInlineKeyboardButtonData(mh.base.service.Localizer.Get(lang, localization.LocaleFeedbackHelp), "feedback_help"),
                },
        }

        return tgbotapi.NewInlineKeyboardMarkup(keyboard...)
}</span>

// editMessageTextAndMarkup редактирует сообщение с клавиатурой.
func (mh *MenuHandler) editMessageTextAndMarkup(chatID int64, messageID int, text string, keyboard *tgbotapi.InlineKeyboardMarkup) error <span class="cov0" title="0">{
        // Используем MessageFactory для редактирования сообщения
        if keyboard != nil </span><span class="cov0" title="0">{
                return mh.base.messageFactory.EditWithKeyboard(chatID, messageID, text, keyboard)
        }</span>
        <span class="cov0" title="0">return mh.base.messageFactory.EditText(chatID, messageID, text)</span>
}

// ProfileHandler интерфейс для работы с профилем.
type ProfileHandler interface {
        HandleProfileShow(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleProfileResetAsk(callback *tgbotapi.CallbackQuery, user *models.User) error
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "time"

        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// MessageFactory предоставляет гибридный API для отправки Telegram сообщений.
// Поддерживает как простые методы для частых случаев, так и Builder паттерн для сложных сценариев.
type MessageFactory struct {
        bot          *tgbotapi.BotAPI
        errorHandler *errors.ErrorHandler
        logger       *logging.LoggingService
}

// MessageBuilder предоставляет Builder API для создания новых сообщений.
type MessageBuilder struct {
        factory   *MessageFactory
        config    tgbotapi.MessageConfig
        chatID    int64
        userID    int64
        operation string
}

// EditMessageBuilder предоставляет Builder API для редактирования сообщений.
type EditMessageBuilder struct {
        factory   *MessageFactory
        config    tgbotapi.EditMessageTextConfig
        chatID    int64
        messageID int
        userID    int64
        operation string
}

// NewMessageFactory создает новый экземпляр MessageFactory.
func NewMessageFactory(
        bot *tgbotapi.BotAPI,
        errorHandler *errors.ErrorHandler,
        logger *logging.LoggingService,
) *MessageFactory <span class="cov8" title="1">{
        return &amp;MessageFactory{
                bot:          bot,
                errorHandler: errorHandler,
                logger:       logger,
        }
}</span>

// =============================================================================
// ПРОСТЫЕ МЕТОДЫ (Quick API) - для 80% случаев использования
// =============================================================================

// SendText отправляет простое текстовое сообщение.
func (f *MessageFactory) SendText(chatID int64, text string) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, text)
        return f.sendWithLogging(msg, chatID, 0, "SendText", "text")
}</span>

// SendWithKeyboard отправляет сообщение с клавиатурой.
func (f *MessageFactory) SendWithKeyboard(chatID int64, text string, keyboard interface{}) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, text)
        msg.ReplyMarkup = keyboard
        return f.sendWithLogging(msg, chatID, 0, "SendWithKeyboard", "text_with_keyboard")
}</span>

// SendHTML отправляет HTML-форматированное сообщение.
func (f *MessageFactory) SendHTML(chatID int64, htmlText string) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, htmlText)
        msg.ParseMode = "HTML"
        return f.sendWithLogging(msg, chatID, 0, "SendHTML", "html")
}</span>

// SendHTMLWithKeyboard отправляет HTML-форматированное сообщение с клавиатурой.
func (f *MessageFactory) SendHTMLWithKeyboard(chatID int64, htmlText string, keyboard interface{}) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, htmlText)
        msg.ParseMode = "HTML"
        msg.ReplyMarkup = keyboard
        return f.sendWithLogging(msg, chatID, 0, "SendHTMLWithKeyboard", "html_with_keyboard")
}</span>

// EditText редактирует текстовое сообщение.
func (f *MessageFactory) EditText(chatID int64, messageID int, text string) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
        return f.sendWithLogging(edit, chatID, 0, "EditText", "edit_text")
}</span>

// EditWithKeyboard редактирует сообщение с клавиатурой.
func (f *MessageFactory) EditWithKeyboard(chatID int64, messageID int, text string, keyboard *tgbotapi.InlineKeyboardMarkup) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
        edit.ReplyMarkup = keyboard
        return f.sendWithLogging(edit, chatID, 0, "EditWithKeyboard", "edit_with_keyboard")
}</span>

// EditHTML редактирует HTML-форматированное сообщение.
func (f *MessageFactory) EditHTML(chatID int64, messageID int, htmlText string) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, htmlText)
        edit.ParseMode = "HTML"
        return f.sendWithLogging(edit, chatID, 0, "EditHTML", "edit_html")
}</span>

// EditHTMLWithKeyboard редактирует HTML-форматированное сообщение с клавиатурой.
func (f *MessageFactory) EditHTMLWithKeyboard(chatID int64, messageID int, htmlText string, keyboard *tgbotapi.InlineKeyboardMarkup) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, htmlText)
        edit.ParseMode = "HTML"
        edit.ReplyMarkup = keyboard
        return f.sendWithLogging(edit, chatID, 0, "EditHTMLWithKeyboard", "edit_html_with_keyboard")
}</span>

// =============================================================================
// BUILDER API - для сложных случаев (20% использования)
// =============================================================================

// NewMessage создает новый MessageBuilder для отправки сообщения.
func (f *MessageFactory) NewMessage(chatID int64) *MessageBuilder <span class="cov8" title="1">{
        return &amp;MessageBuilder{
                factory:   f,
                config:    tgbotapi.MessageConfig{},
                chatID:    chatID,
                userID:    0,
                operation: "NewMessage",
        }
}</span>

// NewEditMessage создает новый EditMessageBuilder для редактирования сообщения.
func (f *MessageFactory) NewEditMessage(chatID int64, messageID int) *EditMessageBuilder <span class="cov8" title="1">{
        return &amp;EditMessageBuilder{
                factory:   f,
                config:    tgbotapi.EditMessageTextConfig{},
                chatID:    chatID,
                messageID: messageID,
                userID:    0,
                operation: "NewEditMessage",
        }
}</span>

// =============================================================================
// MESSAGE BUILDER METHODS
// =============================================================================

// WithText устанавливает текст сообщения.
func (b *MessageBuilder) WithText(text string) *MessageBuilder <span class="cov8" title="1">{
        b.config = tgbotapi.NewMessage(b.chatID, text)
        return b
}</span>

// WithKeyboard устанавливает клавиатуру.
func (b *MessageBuilder) WithKeyboard(keyboard interface{}) *MessageBuilder <span class="cov0" title="0">{
        b.config.ReplyMarkup = keyboard
        return b
}</span>

// WithParseMode устанавливает режим парсинга (HTML, Markdown, MarkdownV2).
func (b *MessageBuilder) WithParseMode(mode string) *MessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = mode
        return b
}</span>

// WithHTML устанавливает HTML режим парсинга.
func (b *MessageBuilder) WithHTML() *MessageBuilder <span class="cov8" title="1">{
        b.config.ParseMode = "HTML"
        return b
}</span>

// WithMarkdown устанавливает Markdown режим парсинга.
func (b *MessageBuilder) WithMarkdown() *MessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "Markdown"
        return b
}</span>

// DisableWebPagePreview отключает превью веб-страниц.
func (b *MessageBuilder) DisableWebPagePreview() *MessageBuilder <span class="cov0" title="0">{
        b.config.DisableWebPagePreview = true
        return b
}</span>

// DisableNotification отправляет сообщение без уведомления.
func (b *MessageBuilder) DisableNotification() *MessageBuilder <span class="cov0" title="0">{
        b.config.DisableNotification = true
        return b
}</span>

// ReplyTo устанавливает сообщение для ответа.
func (b *MessageBuilder) ReplyTo(messageID int) *MessageBuilder <span class="cov0" title="0">{
        b.config.ReplyToMessageID = messageID
        return b
}</span>

// WithUserID устанавливает ID пользователя для логирования.
func (b *MessageBuilder) WithUserID(userID int64) *MessageBuilder <span class="cov0" title="0">{
        b.userID = userID
        return b
}</span>

// WithOperation устанавливает название операции для логирования.
func (b *MessageBuilder) WithOperation(operation string) *MessageBuilder <span class="cov0" title="0">{
        b.operation = operation
        return b
}</span>

// Send отправляет сообщение.
func (b *MessageBuilder) Send() error <span class="cov0" title="0">{
        return b.factory.sendWithLogging(b.config, b.chatID, b.userID, b.operation, "builder_message")
}</span>

// =============================================================================
// EDIT MESSAGE BUILDER METHODS
// =============================================================================

// WithText устанавливает новый текст для редактирования.
func (b *EditMessageBuilder) WithText(text string) *EditMessageBuilder <span class="cov8" title="1">{
        b.config = tgbotapi.NewEditMessageText(b.chatID, b.messageID, text)
        return b
}</span>

// WithKeyboard устанавливает клавиатуру для редактирования.
func (b *EditMessageBuilder) WithKeyboard(keyboard *tgbotapi.InlineKeyboardMarkup) *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ReplyMarkup = keyboard
        return b
}</span>

// WithParseMode устанавливает режим парсинга для редактирования.
func (b *EditMessageBuilder) WithParseMode(mode string) *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = mode
        return b
}</span>

// WithHTML устанавливает HTML режим парсинга для редактирования.
func (b *EditMessageBuilder) WithHTML() *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "HTML"
        return b
}</span>

// WithMarkdown устанавливает Markdown режим парсинга для редактирования.
func (b *EditMessageBuilder) WithMarkdown() *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "Markdown"
        return b
}</span>

// WithUserID устанавливает ID пользователя для логирования.
func (b *EditMessageBuilder) WithUserID(userID int64) *EditMessageBuilder <span class="cov0" title="0">{
        b.userID = userID
        return b
}</span>

// WithOperation устанавливает название операции для логирования.
func (b *EditMessageBuilder) WithOperation(operation string) *EditMessageBuilder <span class="cov0" title="0">{
        b.operation = operation
        return b
}</span>

// Send отправляет редактирование сообщения.
func (b *EditMessageBuilder) Send() error <span class="cov0" title="0">{
        return b.factory.sendWithLogging(b.config, b.chatID, b.userID, b.operation, "builder_edit")
}</span>

// =============================================================================
// ВНУТРЕННЯЯ ЛОГИКА
// =============================================================================

// sendWithLogging отправляет сообщение с логированием и обработкой ошибок.
func (f *MessageFactory) sendWithLogging(
        msg tgbotapi.Chattable,
        chatID int64,
        userID int64,
        operation string,
        messageType string,
) error <span class="cov0" title="0">{
        // Логирование перед отправкой
        f.logOutgoingMessage(chatID, userID, operation, messageType)

        // Отправка
        _, err := f.bot.Send(msg)

        // Обработка ошибки
        if err != nil </span><span class="cov0" title="0">{
                return f.errorHandler.HandleTelegramError(err, chatID, userID, operation)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logOutgoingMessage логирует исходящее сообщение.
func (f *MessageFactory) logOutgoingMessage(chatID int64, userID int64, operation string, messageType string) <span class="cov0" title="0">{
        requestID := "out_" + time.Now().Format("20060102150405") + "_" + operation

        f.logger.Telegram().InfoWithContext(
                "Outgoing message",
                requestID,
                userID,
                chatID,
                operation,
                map[string]interface{}{
                        "message_type": messageType,
                        "chat_id":      chatID,
                        "user_id":      userID,
                },
        )
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "errors"
        "math"
        "strconv"
        "strings"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для работы с профилем.

// NewInterestHandler интерфейс для новой системы интересов.
type NewInterestHandler interface {
        HandleInterestCategorySelection(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error
        HandleInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error
        HandlePrimaryInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error
        HandleBackToCategories(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandlePrimaryInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error
        HandleBackToInterests(callback *tgbotapi.CallbackQuery, user *models.User) error
}

// NewInterestHandlerImpl реализация нового обработчика интересов.
type NewInterestHandlerImpl struct {
        base            *BaseHandler
        interestService *core.InterestService
}

// NewNewInterestHandler создает новый обработчик интересов.
func NewNewInterestHandler(
        base *BaseHandler,
        interestService *core.InterestService,
) *NewInterestHandlerImpl <span class="cov0" title="0">{
        return &amp;NewInterestHandlerImpl{
                base:            base,
                interestService: interestService,
        }
}</span>

// HandleInterestCategorySelection обрабатывает выбор категории интересов.
func (h *NewInterestHandlerImpl) HandleInterestCategorySelection(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        // Получаем категории
        categories, err := h.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategories")
        }</span>

        // Находим выбранную категорию
        <span class="cov0" title="0">var selectedCategory *models.InterestCategory

        for _, category := range categories </span><span class="cov0" title="0">{
                if category.KeyName == categoryKey </span><span class="cov0" title="0">{
                        selectedCategory = &amp;category

                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedCategory == nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "CategoryNotFound")
        }</span>

        // Получаем интересы в категории
        <span class="cov0" title="0">interests, err := h.interestService.GetInterestsByCategory(selectedCategory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategory")
        }</span>

        // Получаем уже выбранные интересы пользователя
        <span class="cov0" title="0">userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Создаем карту выбранных интересов
        <span class="cov0" title="0">selectedMap := make(map[int]bool)
        for _, selection := range userSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем клавиатуру для интересов в категории
        <span class="cov0" title="0">keyboard := h.base.keyboardBuilder.CreateCategoryInterestsKeyboard(
                interests,
                selectedMap,
                selectedCategory.KeyName,
                user.InterfaceLanguageCode,
        )

        // Создаем текст сообщения
        categoryName := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "category_"+categoryKey)
        messageText := categoryName + " - " + h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_interests")

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "EditMessage")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleInterestSelection обрабатывает выбор интереса в категории.
func (h *NewInterestHandlerImpl) HandleInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        // Получаем текущие выборы пользователя
        <span class="cov0" title="0">userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Проверяем, выбран ли уже этот интерес
        <span class="cov0" title="0">isSelected := false

        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        isSelected = true

                        break</span>
                }
        }

        // Переключаем выбор
        <span class="cov0" title="0">if isSelected </span><span class="cov0" title="0">{
                // Удаляем выбор
                err = h.interestService.RemoveUserInterestSelection(user.ID, interestID)
        }</span> else<span class="cov0" title="0"> {
                // Добавляем выбор
                err = h.interestService.AddUserInterestSelection(user.ID, interestID, false)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ToggleInterestSelection")
        }</span>

        // Получаем интерес и его категорию для обновления клавиатуры
        <span class="cov0" title="0">interest, err := h.interestService.GetInterestByID(interestID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestByID")
        }</span>

        // Получаем категорию по ID
        <span class="cov0" title="0">category, err := h.interestService.GetInterestCategoryByID(interest.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategoryByID")
        }</span>

        // Обновляем клавиатуру
        <span class="cov0" title="0">return h.updateCategoryInterestsKeyboard(callback, user, category.KeyName)</span>
}

// HandlePrimaryInterestSelection обрабатывает выбор основного интереса.
func (h *NewInterestHandlerImpl) HandlePrimaryInterestSelection(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        // Получаем текущие выборы пользователя
        <span class="cov0" title="0">userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Находим выбор для этого интереса
        <span class="cov0" title="0">var currentSelection *models.InterestSelection

        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        currentSelection = &amp;selection

                        break</span>
                }
        }

        <span class="cov0" title="0">if currentSelection == nil </span><span class="cov0" title="0">{
                // Интерес не выбран, сначала добавляем его
                err = h.interestService.AddUserInterestSelection(user.ID, interestID, true)
        }</span> else<span class="cov0" title="0"> {
                // Переключаем статус основного
                err = h.interestService.SetPrimaryInterest(user.ID, interestID, !currentSelection.IsPrimary)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "TogglePrimaryInterest")
        }</span>

        // Обновляем клавиатуру выбора основных интересов
        <span class="cov0" title="0">return h.updatePrimaryInterestsKeyboard(callback, user)</span>
}

// HandleInterestsContinue обрабатывает продолжение после выбора интересов.
func (h *NewInterestHandlerImpl) HandleInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем выбранные интересы
        userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Проверяем, выбраны ли интересы
        <span class="cov0" title="0">if len(userSelections) == 0 </span><span class="cov0" title="0">{
                warningMsg := "❗ " + h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_at_least_one_interest")
                if warningMsg == "choose_at_least_one_interest" </span><span class="cov0" title="0">{
                        warningMsg = "❗ Пожалуйста, выберите хотя бы один интерес"
                }</span>

                // Показываем предупреждение и возвращаем к категориям
                <span class="cov0" title="0">keyboard := h.base.keyboardBuilder.CreateInterestCategoriesKeyboard(user.InterfaceLanguageCode)
                editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        warningMsg+"\n\n"+h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_interests"),
                        keyboard,
                )
                _, err = h.base.bot.Request(editMsg)

                return err</span>
        }

        // Получаем конфигурацию лимитов
        <span class="cov0" title="0">limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestLimitsConfig")
        }</span>

        // Получаем общее количество интересов в системе
        <span class="cov0" title="0">allInterests, err := h.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetAllInterests")
        }</span>

        // Вычисляем рекомендуемое количество основных интересов
        <span class="cov0" title="0">totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(math.Ceil(float64(totalInterestsInSystem) * limits.PrimaryPercentage))

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MinPrimaryInterests
        }</span>

        <span class="cov0" title="0">if recommendedPrimary &gt; limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MaxPrimaryInterests
        }</span>

        // Если выбранных интересов меньше или равно максимальному количеству основных,
        // то сразу делаем их все основными
        <span class="cov0" title="0">if len(userSelections) &lt;= recommendedPrimary </span><span class="cov0" title="0">{
                // Делаем все выбранные интересы основными
                for _, selection := range userSelections </span><span class="cov0" title="0">{
                        if !selection.IsPrimary </span><span class="cov0" title="0">{
                                err = h.interestService.SetPrimaryInterest(user.ID, selection.InterestID, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "SetPrimaryInterest")
                                }</span>
                        }
                }

                // Завершаем настройку профиля
                <span class="cov0" title="0">return h.completeProfileSetup(callback, user)</span>
        }

        // Переходим к выбору основных интересов
        <span class="cov0" title="0">return h.showPrimaryInterestsSelection(callback, user)</span>
}

// HandlePrimaryInterestsContinue обрабатывает завершение выбора основных интересов.
func (h *NewInterestHandlerImpl) HandlePrimaryInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем выборы пользователя
        userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Подсчитываем основные интересы
        <span class="cov0" title="0">primaryCount := 0

        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        primaryCount++
                }</span>
        }

        // Получаем конфигурацию лимитов
        <span class="cov0" title="0">limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestLimitsConfig")
        }</span>

        // Проверяем минимальное количество основных интересов
        <span class="cov0" title="0">if primaryCount &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                warningMsg := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_at_least_primary_interests")
                if warningMsg == "choose_at_least_primary_interests" </span><span class="cov0" title="0">{
                        warningMsg = "❗ Пожалуйста, выберите минимум " + strconv.Itoa(limits.MinPrimaryInterests) + " основных интереса"
                }</span>

                // Показываем предупреждение
                <span class="cov0" title="0">editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        warningMsg+"\n\n"+h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests"),
                        h.base.keyboardBuilder.CreatePrimaryInterestsKeyboard(userSelections, user.InterfaceLanguageCode),
                )
                _, err = h.base.bot.Request(editMsg)

                return err</span>
        }

        // Завершаем настройку профиля
        <span class="cov0" title="0">return h.completeProfileSetup(callback, user)</span>
}

// HandleBackToCategories возвращает к выбору категорий.
func (h *NewInterestHandlerImpl) HandleBackToCategories(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        keyboard := h.base.keyboardBuilder.CreateInterestCategoriesKeyboard(user.InterfaceLanguageCode)
        messageText := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_interests")

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err := h.base.bot.Request(editMsg)

        return err
}</span>

// HandleBackToInterests возвращает к выбору интересов.
func (h *NewInterestHandlerImpl) HandleBackToInterests(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Возвращаемся к выбору интересов (категории)
        return h.HandleBackToCategories(callback, user)
}</span>

// showPrimaryInterestsSelection показывает интерфейс выбора основных интересов.
func (h *NewInterestHandlerImpl) showPrimaryInterestsSelection(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем выборы пользователя
        userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Создаем клавиатуру для выбора основных интересов
        <span class="cov0" title="0">keyboard := h.base.keyboardBuilder.CreatePrimaryInterestsKeyboard(userSelections, user.InterfaceLanguageCode)

        // Получаем рекомендуемое количество основных интересов
        limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestLimitsConfig")
        }</span>

        // Получаем общее количество интересов в системе
        <span class="cov0" title="0">allInterests, err := h.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetAllInterests")
        }</span>

        // Вычисляем рекомендуемое количество основных интересов от общего количества интересов в системе
        <span class="cov0" title="0">totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(math.Ceil(float64(totalInterestsInSystem) * limits.PrimaryPercentage))

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MinPrimaryInterests
        }</span>

        <span class="cov0" title="0">if recommendedPrimary &gt; limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MaxPrimaryInterests
        }</span>

        // Подсчитываем уже выбранные основные интересы
        <span class="cov0" title="0">selectedPrimaryCount := 0
        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        selectedPrimaryCount++
                }</span>
        }

        // Создаем текст сообщения с динамическим количеством
        <span class="cov0" title="0">var messageText string
        if selectedPrimaryCount == 0 </span><span class="cov0" title="0">{
                messageText = h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_dynamic")
                messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
        }</span> else<span class="cov0" title="0"> {
                remaining := recommendedPrimary - selectedPrimaryCount
                if remaining &gt; 0 </span><span class="cov0" title="0">{
                        messageText = h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_remaining")
                        messageText = strings.ReplaceAll(messageText, "{remaining}", strconv.Itoa(remaining))
                        messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
                }</span> else<span class="cov0" title="0"> {
                        messageText = h.base.service.Localizer.Get(user.InterfaceLanguageCode, "max_primary_interests_reached")
                        if messageText == "max_primary_interests_reached" </span><span class="cov0" title="0">{
                                messageText = "✅ Максимальное количество основных интересов выбрано!"
                        }</span>
                }
        }

        // Обновляем сообщение
        <span class="cov0" title="0">editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.base.bot.Request(editMsg)

        return err</span>
}

// updateCategoryInterestsKeyboard обновляет клавиатуру интересов в категории.
func (h *NewInterestHandlerImpl) updateCategoryInterestsKeyboard(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        // Получаем категории
        categories, err := h.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Находим категорию
        <span class="cov0" title="0">var selectedCategory *models.InterestCategory

        for _, category := range categories </span><span class="cov0" title="0">{
                if category.KeyName == categoryKey </span><span class="cov0" title="0">{
                        selectedCategory = &amp;category

                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedCategory == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Получаем интересы в категории
        <span class="cov0" title="0">interests, err := h.interestService.GetInterestsByCategory(selectedCategory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Получаем выборы пользователя
        <span class="cov0" title="0">userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Создаем карту выбранных интересов
        <span class="cov0" title="0">selectedMap := make(map[int]bool)
        for _, selection := range userSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем клавиатуру
        <span class="cov0" title="0">keyboard := h.base.keyboardBuilder.CreateCategoryInterestsKeyboard(interests, selectedMap, categoryKey, user.InterfaceLanguageCode)

        // Обновляем сообщение
        categoryName := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "category_"+categoryKey)
        messageText := categoryName + " - " + h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_interests")

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.base.bot.Request(editMsg)

        return err</span>
}

// updatePrimaryInterestsKeyboard обновляет клавиатуру выбора основных интересов.
func (h *NewInterestHandlerImpl) updatePrimaryInterestsKeyboard(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем выборы пользователя
        userSelections, err := h.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Создаем клавиатуру
        <span class="cov0" title="0">keyboard := h.base.keyboardBuilder.CreatePrimaryInterestsKeyboard(userSelections, user.InterfaceLanguageCode)

        // Получаем рекомендуемое количество основных интересов
        limits, err := h.interestService.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Получаем общее количество интересов в системе
        <span class="cov0" title="0">allInterests, err := h.interestService.GetAllInterests()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Вычисляем рекомендуемое количество основных интересов от общего количества интересов в системе
        <span class="cov0" title="0">totalInterestsInSystem := len(allInterests)
        recommendedPrimary := int(math.Ceil(float64(totalInterestsInSystem) * limits.PrimaryPercentage))

        // Ограничиваем минимумом и максимумом
        if recommendedPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MinPrimaryInterests
        }</span>

        <span class="cov0" title="0">if recommendedPrimary &gt; limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                recommendedPrimary = limits.MaxPrimaryInterests
        }</span>

        // Подсчитываем уже выбранные основные интересы
        <span class="cov0" title="0">selectedPrimaryCount := 0
        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        selectedPrimaryCount++
                }</span>
        }

        // Создаем текст сообщения с динамическим количеством
        <span class="cov0" title="0">var messageText string
        if selectedPrimaryCount == 0 </span><span class="cov0" title="0">{
                messageText = h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_dynamic")
                messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
        }</span> else<span class="cov0" title="0"> {
                remaining := recommendedPrimary - selectedPrimaryCount
                if remaining &gt; 0 </span><span class="cov0" title="0">{
                        messageText = h.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_primary_interests_remaining")
                        messageText = strings.ReplaceAll(messageText, "{remaining}", strconv.Itoa(remaining))
                        messageText = strings.ReplaceAll(messageText, "{max}", strconv.Itoa(recommendedPrimary))
                }</span> else<span class="cov0" title="0"> {
                        messageText = h.base.service.Localizer.Get(user.InterfaceLanguageCode, "max_primary_interests_reached")
                        if messageText == "max_primary_interests_reached" </span><span class="cov0" title="0">{
                                messageText = "✅ Максимальное количество основных интересов выбрано!"
                        }</span>
                }
        }

        <span class="cov0" title="0">editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                messageText,
                keyboard,
        )

        _, err = h.base.bot.Request(editMsg)

        return err</span>
}

// completeProfileSetup завершает настройку профиля.
//
//nolint:cyclop,funlen // функция содержит последовательную логику завершения профиля, длина оправдана
func (h *NewInterestHandlerImpl) completeProfileSetup(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // New interest handler implementation
        // Legacy implementation for backward compatibility
        // Additional check for new handler
        if user == nil </span><span class="cov0" title="0">{
                return errors.New("user cannot be nil")
        }</span>
        // Получаем сводку интересов пользователя
        <span class="cov0" title="0">summary, err := h.interestService.GetUserInterestSummary(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.base.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSummary")
        }</span>

        // Создаем текст с основными и дополнительными интересами
        <span class="cov0" title="0">var primaryText, additionalText strings.Builder

        if len(summary.PrimaryInterests) &gt; 0 </span><span class="cov0" title="0">{
                primaryText.WriteString(h.base.service.Localizer.Get(user.InterfaceLanguageCode, "primary_interests_label") + " ")

                for i, interest := range summary.PrimaryInterests </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                primaryText.WriteString(", ")
                        }</span>

                        <span class="cov0" title="0">interestName := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "interest_"+interest.KeyName)
                        primaryText.WriteString(interestName)</span>
                }

                <span class="cov0" title="0">primaryText.WriteString("\n")</span>
        }

        <span class="cov0" title="0">if len(summary.AdditionalInterests) &gt; 0 </span><span class="cov0" title="0">{
                additionalText.WriteString(h.base.service.Localizer.Get(user.InterfaceLanguageCode, "additional_interests_label") + " ")

                for i, interest := range summary.AdditionalInterests </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                additionalText.WriteString(", ")
                        }</span>

                        <span class="cov0" title="0">interestName := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "interest_"+interest.KeyName)
                        additionalText.WriteString(interestName)</span>
                }

                <span class="cov0" title="0">additionalText.WriteString("\n")</span>
        }

        // Создаем итоговое сообщение
        <span class="cov0" title="0">completionMsg := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "interests_selection_complete")
        feedbackSuggestion := h.base.service.Localizer.Get(user.InterfaceLanguageCode, "interests_feedback_suggestion")

        fullMessage := completionMsg + "\n\n" + primaryText.String() + additionalText.String() + "\n" + feedbackSuggestion

        // Показываем сообщение о завершении интересов
        completionKeyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData(
                                "✅ "+h.base.service.Localizer.Get(user.InterfaceLanguageCode, "continue_button"),
                                "continue_to_availability",
                        ),
                ),
        )

        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                fullMessage,
                completionKeyboard,
        )

        _, err = h.base.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Не переводим пользователя в активное состояние сразу,
        // ждем нажатия кнопки "Продолжить"
        <span class="cov0" title="0">return nil</span>
}

// updateProfileCompletionLevel обновляет уровень завершения профиля.
// nolint:unused
func (h *NewInterestHandlerImpl) updateProfileCompletionLevel(userID int, completionLevel int) error <span class="cov0" title="0">{
        _, err := h.base.service.DB.GetConnection().Exec(`
                UPDATE users
                SET profile_completion_level = $1, updated_at = NOW()
                WHERE id = $2
        `, completionLevel, userID)

        return err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "fmt"

        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для работы с профилем.

// ProfileHandlerImpl обрабатывает все операции с профилем пользователя.
type ProfileHandlerImpl struct {
        base *BaseHandler
}

// NewProfileHandler создает новый экземпляр ProfileHandler.
func NewProfileHandler(base *BaseHandler) *ProfileHandlerImpl <span class="cov0" title="0">{
        return &amp;ProfileHandlerImpl{
                base: base,
        }
}</span>

// HandleProfileCommand обрабатывает команду /profile.
func (ph *ProfileHandlerImpl) HandleProfileCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        summary, err := ph.base.service.BuildProfileSummary(user)
        if err != nil </span><span class="cov0" title="0">{
                // Используем MessageFactory для отправки сообщения об ошибке
                return ph.base.messageFactory.SendText(message.Chat.ID, ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "unknown_command"))
        }</span>

        <span class="cov0" title="0">text := summary + "\n\n" + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_actions")
        keyboard := ph.base.keyboardBuilder.CreateProfileMenuKeyboard(user.InterfaceLanguageCode)

        // Используем MessageFactory для отправки сообщения с клавиатурой
        return ph.base.messageFactory.SendWithKeyboard(message.Chat.ID, text, keyboard)</span>
}

// HandleProfileShow показывает профиль пользователя.
func (ph *ProfileHandlerImpl) HandleProfileShow(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        summary, err := ph.base.service.BuildProfileSummary(user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">text := summary + "\n\n" + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_actions")
        keyboard := ph.base.keyboardBuilder.CreateProfileMenuKeyboard(user.InterfaceLanguageCode)
        err = ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )

        return err</span>
}

// HandleProfileResetAsk запрашивает подтверждение сброса профиля.
func (ph *ProfileHandlerImpl) HandleProfileResetAsk(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        title := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_reset_title")
        warn := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_reset_warning")
        text := fmt.Sprintf("%s\n\n%s", title, warn)
        keyboard := ph.base.keyboardBuilder.CreateResetConfirmKeyboard(user.InterfaceLanguageCode)
        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )

        return err
}</span>

// HandleProfileResetYes выполняет сброс профиля.
func (ph *ProfileHandlerImpl) HandleProfileResetYes(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        err := ph.base.service.DB.ResetUserProfile(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Обновляем в памяти базовые поля
        <span class="cov0" title="0">user.NativeLanguageCode = ""
        user.TargetLanguageCode = ""
        user.State = models.StateWaitingLanguage
        user.Status = models.StatusFilling
        user.ProfileCompletionLevel = 0

        done := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_reset_done")
        // Предложим сразу начать с выбора родного языка
        next := ph.base.service.GetLanguagePrompt(user, "native")
        text := done + "\n\n" + next

        keyboard := ph.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "native", "", true)
        err = ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )

        return err</span>
}

// StartProfileSetup начинает настройку профиля с выбора родного языка.
func (ph *ProfileHandlerImpl) StartProfileSetup(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_native_language")
        keyboard := ph.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "native", "", true)

        // Редактируем существующее сообщение вместо создания нового
        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )
        return err
}</span>

// HandleInterestsContinue обрабатывает продолжение после выбора интересов.
//
//nolint:funlen
func (ph *ProfileHandlerImpl) HandleInterestsContinue(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        ph.base.service.LoggingService.Telegram().InfoWithContext(
                "HandleInterestsContinue called",
                generateRequestID("HandleInterestsContinue"),
                user.TelegramID,
                callback.Message.Chat.ID,
                "HandleInterestsContinue",
                map[string]interface{}{"userID": user.ID, "telegramID": user.TelegramID},
        )

        // Проверяем, выбраны ли интересы
        selectedInterests, err := ph.base.service.DB.GetUserSelectedInterests(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                ph.base.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get selected interests",
                        generateRequestID("HandleInterestsContinue"),
                        user.TelegramID,
                        callback.Message.Chat.ID,
                        "HandleInterestsContinue",
                        map[string]interface{}{"error": err.Error()},
                )

                return err
        }</span>

        <span class="cov0" title="0">ph.base.service.LoggingService.Telegram().InfoWithContext(
                "User has selected interests",
                generateRequestID("HandleInterestsContinue"),
                user.TelegramID,
                callback.Message.Chat.ID,
                "HandleInterestsContinue",
                map[string]interface{}{"userID": user.ID, "interestCount": len(selectedInterests), "interests": selectedInterests},
        )

        // Если не выбрано ни одного интереса, сообщаем пользователю и оставляем клавиатуру
        if len(selectedInterests) == 0 </span><span class="cov0" title="0">{
                warningMsg := "❗ " + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_at_least_one_interest")
                if warningMsg == "choose_at_least_one_interest" </span><span class="cov0" title="0">{ // fallback if key doesn't exist
                        warningMsg = "⚠️ Пожалуйста, выберите хотя бы один интерес"
                }</span>

                // Добавляем оригинальный текст с предупреждением
                <span class="cov0" title="0">chooseInterestsText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_interests")
                fullText := warningMsg + "\n\n" + chooseInterestsText

                // Получаем интересы и оставляем клавиатуру с интересами видимой, обновляя только текст
                interests, _ := ph.base.service.GetCachedInterests(user.InterfaceLanguageCode)
                keyboard := ph.base.keyboardBuilder.CreateInterestsKeyboard(interests, []int{}, user.InterfaceLanguageCode)
                err = ph.base.messageFactory.EditWithKeyboard(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        fullText,
                        &amp;keyboard,
                )
                return err</span>
        }

        // Если интересы выбраны, завершаем профиль
        <span class="cov0" title="0">completedMsg := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_completed")
        keyboard := ph.base.keyboardBuilder.CreateProfileCompletedKeyboard(user.InterfaceLanguageCode)
        err = ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                completedMsg,
                &amp;keyboard,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Обновляем статус пользователя
        <span class="cov0" title="0">ph.base.service.LoggingService.Database().InfoWithContext(
                "Updating user state to active",
                generateRequestID("HandleInterestsContinue"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleInterestsContinue",
                map[string]interface{}{"userID": user.ID, "state": "active"},
        )

        err = ph.base.service.DB.UpdateUserState(user.ID, models.StateActive)
        if err != nil </span><span class="cov0" title="0">{
                ph.base.service.LoggingService.Database().ErrorWithContext(
                        "Error updating user state",
                        generateRequestID("HandleInterestsContinue"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleInterestsContinue",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )

                return err
        }</span>

        <span class="cov0" title="0">ph.base.service.LoggingService.Database().InfoWithContext(
                "Updating user status to active",
                generateRequestID("HandleInterestsContinue"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleInterestsContinue",
                map[string]interface{}{"userID": user.ID, "status": "active"},
        )

        err = ph.base.service.DB.UpdateUserStatus(user.ID, models.StatusActive)
        if err != nil </span><span class="cov0" title="0">{
                ph.base.service.LoggingService.Database().ErrorWithContext(
                        "Error updating user status",
                        generateRequestID("HandleInterestsContinue"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleInterestsContinue",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )

                return err
        }</span>

        // Увеличиваем уровень завершения профиля до 100%
        <span class="cov0" title="0">ph.base.service.LoggingService.Database().InfoWithContext(
                "Updating user profile completion level to 100%",
                generateRequestID("HandleInterestsContinue"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleInterestsContinue",
                map[string]interface{}{"userID": user.ID, "completionLevel": 100},
        )

        err = ph.updateProfileCompletionLevel(user.ID, localization.ProfileCompletionLevelComplete)
        if err != nil </span><span class="cov0" title="0">{
                ph.base.service.LoggingService.Database().ErrorWithContext(
                        "Error updating profile completion level",
                        generateRequestID("HandleInterestsContinue"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleInterestsContinue",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )

                return err
        }</span>

        <span class="cov0" title="0">ph.base.service.LoggingService.Telegram().InfoWithContext(
                "Successfully completed profile",
                generateRequestID("HandleInterestsContinue"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleInterestsContinue",
                map[string]interface{}{"userID": user.ID, "result": "profile_completed"},
        )

        return nil</span>
}

// updateProfileCompletionLevel обновляет уровень завершения профиля от 0 до 100.
func (ph *ProfileHandlerImpl) updateProfileCompletionLevel(userID int, completionLevel int) error <span class="cov0" title="0">{
        ph.base.service.LoggingService.Database().InfoWithContext(
                "Executing updateProfileCompletionLevel",
                generateRequestID("updateProfileCompletionLevel"),
                int64(userID),
                0, // нет chatID в этой функции
                "updateProfileCompletionLevel",
                map[string]interface{}{"userID": userID, "completionLevel": completionLevel},
        )

        result, err := ph.base.service.DB.GetConnection().Exec(`
                UPDATE users
                SET profile_completion_level = $1, updated_at = NOW()
                WHERE id = $2
        `, completionLevel, userID)
        if err != nil </span><span class="cov0" title="0">{
                ph.base.service.LoggingService.Database().ErrorWithContext(
                        "Error in updateProfileCompletionLevel",
                        generateRequestID("updateProfileCompletionLevel"),
                        int64(userID),
                        0, // нет chatID в этой функции
                        "updateProfileCompletionLevel",
                        map[string]interface{}{"userID": userID, "completionLevel": completionLevel, "error": err.Error()},
                )

                return err
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        ph.base.service.LoggingService.Database().InfoWithContext(
                "updateProfileCompletionLevel completed",
                generateRequestID("updateProfileCompletionLevel"),
                int64(userID),
                0, // нет chatID в этой функции
                "updateProfileCompletionLevel",
                map[string]interface{}{"userID": userID, "rowsAffected": rowsAffected},
        )

        return nil</span>
}

// HandleEditLanguages позволяет редактировать языки пользователя.
func (ph *ProfileHandlerImpl) HandleEditLanguages(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Показываем текущие настройки языков с кнопками редактирования
        text := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_edit_languages") +
                "\n\n" + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "save_button") +
                " или " + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "cancel_button")

        keyboard := ph.base.keyboardBuilder.CreateEditLanguagesKeyboard(
                user.InterfaceLanguageCode,
                user.NativeLanguageCode,
                user.TargetLanguageCode,
                user.TargetLanguageLevel,
        )

        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )
        return err
}</span>

// HandleEditNativeLang редактирует родной язык пользователя.
func (ph *ProfileHandlerImpl) HandleEditNativeLang(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        text := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_native_language")
        // Показываем клавиатуру с сохранением/отменой вместо обычного выбора
        keyboard := ph.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "edit_native", "", false)

        // Добавляем кнопки сохранить/отменить
        saveRow := ph.base.keyboardBuilder.CreateSaveEditsKeyboard(user.InterfaceLanguageCode).InlineKeyboard[0]
        keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{saveRow[0], saveRow[1]})

        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )
        return err
}</span>

// HandleEditTargetLang редактирует изучаемый язык пользователя (только если родной - русский).
func (ph *ProfileHandlerImpl) HandleEditTargetLang(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Проверяем, что родной язык русский - только в этом случае можно редактировать изучаемый язык
        if user.NativeLanguageCode != "ru" </span><span class="cov0" title="0">{
                // Не должно происходить по логике, но на всякий случай
                // Используем MessageFactory для отправки сообщения об ошибке
                return ph.base.messageFactory.SendText(callback.Message.Chat.ID, "Редактирование изучаемого языка недоступно при вашем родном языке.")
        }</span>

        <span class="cov0" title="0">text := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "choose_target_language")
        // Исключаем родной язык из списка изучаемых
        keyboard := ph.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "edit_target", user.NativeLanguageCode, false)

        // Добавляем кнопки сохранить/отменить
        saveRow := ph.base.keyboardBuilder.CreateSaveEditsKeyboard(user.InterfaceLanguageCode).InlineKeyboard[0]
        keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{saveRow[0], saveRow[1]})

        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )
        return err</span>
}

// HandleEditNativeLanguage сохраняет выбор родного языка с учетом первоначальной логики.
func (ph *ProfileHandlerImpl) HandleEditNativeLanguage(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        langCode := callback.Data[len("lang_edit_native_"):]

        // Сохраняем новый родной язык
        err := ph.base.service.DB.UpdateUserNativeLanguage(user.ID, langCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.NativeLanguageCode = langCode

        // Применяем изначальную логику выбора языков
        if langCode == "ru" </span><span class="cov0" title="0">{
                // Если выбран русский как родной, предлагаем выбрать изучаемый из оставшихся 3
                // Но не меняем существующий изучаемый язык, если он есть
                text := "Выберите изучаемый язык:"
                keyboard := ph.base.keyboardBuilder.CreateLanguageKeyboard(user.InterfaceLanguageCode, "edit_target", "ru", false)

                // Добавляем кнопки сохранить/отменить
                saveRow := ph.base.keyboardBuilder.CreateSaveEditsKeyboard(user.InterfaceLanguageCode).InlineKeyboard[0]
                keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{saveRow[0], saveRow[1]})

                err = ph.base.messageFactory.EditWithKeyboard(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        text,
                        &amp;keyboard,
                )
                return err
        }</span> else<span class="cov0" title="0"> {
                // Если выбран не русский, автоматически устанавливаем русский как изучаемый
                err := ph.base.service.DB.UpdateUserTargetLanguage(user.ID, "ru")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">user.TargetLanguageCode = "ru"

                // Показываем подтверждение и предлагаем выбрать уровень
                nativeLangName := ph.base.service.Localizer.GetLanguageName(langCode, user.InterfaceLanguageCode)
                text := fmt.Sprintf("Родной язык: %s\nИзучаемый язык: Русский\n\nВыберите уровень владения русским языком:",
                        nativeLangName)

                keyboard := ph.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, "ru", "edit_level", false)

                // Добавляем кнопки сохранить/отменить
                saveRow := ph.base.keyboardBuilder.CreateSaveEditsKeyboard(user.InterfaceLanguageCode).InlineKeyboard[0]
                keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{saveRow[0], saveRow[1]})

                err = ph.base.messageFactory.EditWithKeyboard(
                        callback.Message.Chat.ID,
                        callback.Message.MessageID,
                        text,
                        &amp;keyboard,
                )

                return err</span>
        }
}

// HandleEditTargetLanguage сохраняет выбор изучаемого языка.
func (ph *ProfileHandlerImpl) HandleEditTargetLanguage(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        langCode := callback.Data[len("lang_edit_target_"):]

        err := ph.base.service.DB.UpdateUserTargetLanguage(user.ID, langCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.TargetLanguageCode = langCode
        langName := ph.base.service.Localizer.GetLanguageName(langCode, user.InterfaceLanguageCode)

        // Предлагаем выбрать уровень владения языком
        title := ph.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "choose_level_title", map[string]string{
                "language": langName,
        })

        keyboard := ph.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, langCode, "edit_level_", false)
        // Добавляем save/cancel
        saveRow := ph.base.keyboardBuilder.CreateSaveEditsKeyboard(user.InterfaceLanguageCode).InlineKeyboard[0]
        keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{saveRow[0], saveRow[1]})

        err = ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                title,
                &amp;keyboard,
        )
        return err</span>
}

// HandleEditLevelSelection обрабатывает выбор уровня владения языком при редактировании.
func (ph *ProfileHandlerImpl) HandleEditLevelSelection(callback *tgbotapi.CallbackQuery, user *models.User, levelCode string) error <span class="cov0" title="0">{
        // Сохраняем уровень владения языком
        err := ph.base.service.DB.UpdateUserTargetLanguageLevel(user.ID, levelCode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.TargetLanguageLevel = levelCode

        // Переходим к меню редактирования языков с обновленными данными
        text := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_edit_languages") +
                "\n\n" + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "save_button") +
                " или " + ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "cancel_button")

        keyboard := ph.base.keyboardBuilder.CreateEditLanguagesKeyboard(
                user.InterfaceLanguageCode,
                user.NativeLanguageCode,
                user.TargetLanguageCode,
                user.TargetLanguageLevel,
        )

        err = ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                &amp;keyboard,
        )
        return err</span>
}

// HandleEditLevelLang редактирует уровень владения языком.
func (ph *ProfileHandlerImpl) HandleEditLevelLang(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        langName := ph.base.service.Localizer.GetLanguageName(user.TargetLanguageCode, user.InterfaceLanguageCode)
        title := ph.base.service.Localizer.GetWithParams(user.InterfaceLanguageCode, "choose_level_title", map[string]string{
                "language": langName,
        })

        keyboard := ph.base.keyboardBuilder.CreateLanguageLevelKeyboardWithPrefix(user.InterfaceLanguageCode, user.TargetLanguageCode, "edit_level_", false)
        // Добавляем save/cancel
        saveRow := ph.base.keyboardBuilder.CreateSaveEditsKeyboard(user.InterfaceLanguageCode).InlineKeyboard[0]
        keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{saveRow[0], saveRow[1]})

        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                title,
                &amp;keyboard,
        )
        return err
}</span>

// ShowProfileSetupFeatures показывает новые возможности заполнения профиля.
func (ph *ProfileHandlerImpl) ShowProfileSetupFeatures(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Создаем сообщение с новыми возможностями
        featuresText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_features")
        isolatedText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_isolated_editing")
        detailedText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_detailed_changes")
        safeText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_safe_editing")
        massText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_mass_operations")
        undoText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_undo")
        navText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_enhanced_navigation")
        realtimeText := ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "profile_setup_real_time_updates")

        fullText := fmt.Sprintf("%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s",
                featuresText,
                isolatedText,
                detailedText,
                safeText,
                massText,
                undoText,
                navText,
                realtimeText,
        )

        // Создаем клавиатуру с кнопкой "Продолжить"
        continueButton := tgbotapi.NewInlineKeyboardButtonData(
                ph.base.service.Localizer.Get(user.InterfaceLanguageCode, "continue_button"),
                "profile_setup_continue",
        )
        keyboard := tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{continueButton})

        // Обновляем сообщение
        err := ph.base.messageFactory.EditWithKeyboard(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                fullText,
                &amp;keyboard,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "fmt"
        "strconv"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для работы с callback data.
const (
        MinPartsForInterestCallback = 4 // Минимальное количество частей в callback data для интересов
)

// ProfileInterestHandler обрабатывает редактирование интересов из профиля.
type ProfileInterestHandler struct {
        service         *core.BotService
        interestService *core.InterestService
        bot             *tgbotapi.BotAPI
        keyboardBuilder *KeyboardBuilder
        errorHandler    *errors.ErrorHandler
}

// NewProfileInterestHandler создает новый обработчик интересов для профиля.
func NewProfileInterestHandler(
        service *core.BotService,
        interestService *core.InterestService,
        bot *tgbotapi.BotAPI,
        keyboardBuilder *KeyboardBuilder,
        errorHandler *errors.ErrorHandler,
) *ProfileInterestHandler <span class="cov0" title="0">{
        return &amp;ProfileInterestHandler{
                service:         service,
                interestService: interestService,
                bot:             bot,
                keyboardBuilder: keyboardBuilder,
                errorHandler:    errorHandler,
        }
}</span>

// HandleEditInterestsFromProfile обрабатывает редактирование интересов из профиля.
func (pih *ProfileInterestHandler) HandleEditInterestsFromProfile(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        pih.service.LoggingService.Telegram().DebugWithContext(
                "HandleEditInterestsFromProfile called",
                generateRequestID("HandleEditInterestsFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestsFromProfile",
                map[string]interface{}{"userID": user.ID},
        )

        // Получаем категории интересов через кэш
        categories, err := pih.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                pih.service.LoggingService.Database().ErrorWithContext(
                        "Failed to get interest categories",
                        generateRequestID("HandleEditInterestsFromProfile"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleEditInterestsFromProfile",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategories")
        }</span>

        // Логируем получение категорий
        <span class="cov0" title="0">pih.service.LoggingService.Database().DebugWithContext(
                "Retrieved interest categories",
                generateRequestID("HandleEditInterestsFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestsFromProfile",
                map[string]interface{}{"userID": user.ID, "categoriesCount": len(categories)},
        )

        // Создаем клавиатуру с категориями для редактирования
        keyboard := pih.keyboardBuilder.CreateEditInterestCategoriesKeyboard(user.InterfaceLanguageCode)
        pih.service.LoggingService.Telegram().DebugWithContext(
                "Created keyboard for editing interests",
                generateRequestID("HandleEditInterestsFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestsFromProfile",
                map[string]interface{}{"userID": user.ID, "keyboardType": "edit_interest_categories"},
        )

        // Создаем текст с инструкциями
        text := pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleEditInterestsFromProfile) + "\n\n" +
                pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChooseInterestCategory)
        pih.service.LoggingService.Telegram().DebugWithContext(
                "Created text for editing interests",
                generateRequestID("HandleEditInterestsFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestsFromProfile",
                map[string]interface{}{"userID": user.ID, "textLength": len(text)},
        )

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = pih.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                pih.service.LoggingService.Telegram().ErrorWithContext(
                        "Failed to send edit message",
                        generateRequestID("HandleEditInterestsFromProfile"),
                        int64(user.ID),
                        callback.Message.Chat.ID,
                        "HandleEditInterestsFromProfile",
                        map[string]interface{}{"userID": user.ID, "error": err.Error()},
                )
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "EditMessage")
        }</span>

        <span class="cov0" title="0">pih.service.LoggingService.Telegram().DebugWithContext(
                "Successfully sent edit message",
                generateRequestID("HandleEditInterestsFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestsFromProfile",
                map[string]interface{}{"userID": user.ID, "result": "message_sent"},
        )
        return nil</span>
}

// HandleEditInterestCategoryFromProfile обрабатывает выбор категории для редактирования.
func (pih *ProfileInterestHandler) HandleEditInterestCategoryFromProfile(callback *tgbotapi.CallbackQuery, user *models.User, categoryKey string) error <span class="cov0" title="0">{
        pih.service.LoggingService.Telegram().InfoWithContext(
                "User selected category for editing",
                generateRequestID("HandleEditInterestCategoryFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestCategoryFromProfile",
                map[string]interface{}{"userID": user.ID, "categoryKey": categoryKey},
        )

        // Получаем категории
        categories, err := pih.interestService.GetInterestCategories()
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategories")
        }</span>

        // Находим выбранную категорию
        <span class="cov0" title="0">var selectedCategory *models.InterestCategory

        for _, category := range categories </span><span class="cov0" title="0">{
                if category.KeyName == categoryKey </span><span class="cov0" title="0">{
                        selectedCategory = &amp;category

                        break</span>
                }
        }

        <span class="cov0" title="0">if selectedCategory == nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "CategoryNotFound")
        }</span>

        // Получаем интересы в категории
        <span class="cov0" title="0">interests, err := pih.interestService.GetInterestsByCategory(selectedCategory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategory")
        }</span>

        // Получаем текущие выборы пользователя
        <span class="cov0" title="0">userSelections, err := pih.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(
                        err,
                        callback.Message.Chat.ID,
                        int64(user.ID),
                        "GetUserInterestSelections",
                )
        }</span>

        // Создаем карту выбранных интересов
        <span class="cov0" title="0">selectedMap := make(map[int]bool)
        for _, selection := range userSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем клавиатуру с интересами для редактирования
        <span class="cov0" title="0">keyboard := pih.keyboardBuilder.CreateEditCategoryInterestsKeyboard(interests, selectedMap, categoryKey, user.InterfaceLanguageCode)

        // Создаем текст
        categoryName := pih.service.Localizer.Get(user.InterfaceLanguageCode, "category_"+categoryKey)
        text := pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleEditInterestsInCategory) + " " + categoryName

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = pih.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "EditMessage")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleEditInterestSelectionFromProfile обрабатывает выбор/отмену интереса при редактировании из профиля.
func (pih *ProfileInterestHandler) HandleEditInterestSelectionFromProfile(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        <span class="cov0" title="0">pih.service.LoggingService.Telegram().InfoWithContext(
                "User toggling interest",
                generateRequestID("HandleEditInterestSelectionFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleEditInterestSelectionFromProfile",
                map[string]interface{}{"userID": user.ID, "interestID": interestID},
        )

        // Получаем текущие выборы пользователя
        userSelections, err := pih.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Проверяем, выбран ли уже этот интерес
        <span class="cov0" title="0">isSelected := false

        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        isSelected = true

                        break</span>
                }
        }

        // Переключаем выбор
        <span class="cov0" title="0">if isSelected </span><span class="cov0" title="0">{
                // Удаляем выбор
                err = pih.interestService.RemoveUserInterestSelection(user.ID, interestID)
        }</span> else<span class="cov0" title="0"> {
                // Добавляем выбор
                err = pih.interestService.AddUserInterestSelection(user.ID, interestID, false)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ToggleInterestSelection")
        }</span>

        // Обновляем клавиатуру
        <span class="cov0" title="0">return pih.updateCategoryInterestsKeyboardFromProfile(callback, user, interestIDStr)</span>
}

// HandleEditPrimaryInterestsFromProfile обрабатывает редактирование основных интересов из профиля.
func (pih *ProfileInterestHandler) HandleEditPrimaryInterestsFromProfile(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем текущие выборы пользователя
        userSelections, err := pih.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Создаем клавиатуру для выбора основных интересов в режиме редактирования
        <span class="cov0" title="0">keyboard := pih.keyboardBuilder.CreateEditPrimaryInterestsKeyboard(userSelections, user.InterfaceLanguageCode)

        // Создаем текст
        text := pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleEditPrimaryInterests) + "\n\n" +
                pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleChoosePrimaryInterests)

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = pih.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "EditMessage")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleEditPrimaryInterestSelectionFromProfile обрабатывает выбор/отмену основного интереса.
func (pih *ProfileInterestHandler) HandleEditPrimaryInterestSelectionFromProfile(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(
                        err,
                        callback.Message.Chat.ID,
                        int64(user.ID),
                        "ParseInterestID",
                )
        }</span>

        // Получаем текущие выборы пользователя
        <span class="cov0" title="0">userSelections, err := pih.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Находим текущий выбор
        <span class="cov0" title="0">var currentSelection *models.InterestSelection

        for _, selection := range userSelections </span><span class="cov0" title="0">{
                if selection.InterestID == interestID </span><span class="cov0" title="0">{
                        currentSelection = &amp;selection

                        break</span>
                }
        }

        <span class="cov0" title="0">if currentSelection == nil </span><span class="cov0" title="0">{
                // Интерес не выбран, ничего не делаем
                return nil
        }</span>

        // Переключаем статус основного
        <span class="cov0" title="0">err = pih.interestService.SetPrimaryInterest(
                user.ID,
                interestID,
                !currentSelection.IsPrimary,
        )
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "TogglePrimaryInterest")
        }</span>

        // Обновляем клавиатуру
        <span class="cov0" title="0">return pih.updatePrimaryInterestsKeyboardFromProfile(callback, user)</span>
}

// HandleSaveInterestEditsFromProfile сохраняет изменения интересов и возвращается к профилю.
func (pih *ProfileInterestHandler) HandleSaveInterestEditsFromProfile(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        pih.service.LoggingService.Telegram().InfoWithContext(
                "User saving interest edits",
                generateRequestID("HandleSaveInterestEditsFromProfile"),
                int64(user.ID),
                callback.Message.Chat.ID,
                "HandleSaveInterestEditsFromProfile",
                map[string]interface{}{"userID": user.ID},
        )

        // Получаем сводку интересов пользователя
        summary, err := pih.interestService.GetUserInterestSummary(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSummary")
        }</span>

        // Создаем текст с обновленными интересами
        <span class="cov0" title="0">text := pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleInterestsUpdatedSuccessfully) + "\n\n" +
                fmt.Sprintf("%s: %d\n%s: %d\n%s: %d",
                        pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleTotalInterests),
                        summary.TotalInterests,
                        pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocalePrimaryInterestsLabel),
                        len(summary.PrimaryInterests),
                        pih.service.Localizer.Get(user.InterfaceLanguageCode, localization.LocaleAdditionalInterestsLabel),
                        len(summary.AdditionalInterests))

        // Создаем клавиатуру для возврата к профилю
        keyboard := pih.keyboardBuilder.CreateProfileMenuKeyboard(user.InterfaceLanguageCode)

        // Обновляем сообщение
        editMsg := tgbotapi.NewEditMessageTextAndMarkup(
                callback.Message.Chat.ID,
                callback.Message.MessageID,
                text,
                keyboard,
        )

        _, err = pih.bot.Request(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "EditMessage")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateCategoryInterestsKeyboardFromProfile обновляет клавиатуру интересов в категории.
func (pih *ProfileInterestHandler) updateCategoryInterestsKeyboardFromProfile(callback *tgbotapi.CallbackQuery, user *models.User, interestIDStr string) error <span class="cov0" title="0">{
        // Получаем ID интереса
        interestID, err := strconv.Atoi(interestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "ParseInterestID")
        }</span>

        // Получаем интерес по ID
        <span class="cov0" title="0">interest, err := pih.interestService.GetInterestByID(interestID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestByID")
        }</span>

        // Получаем категорию по ID
        <span class="cov0" title="0">category, err := pih.interestService.GetInterestCategoryByID(interest.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestCategoryByID")
        }</span>

        <span class="cov0" title="0">selectedCategory := category

        // Получаем интересы в категории
        interests, err := pih.interestService.GetInterestsByCategory(selectedCategory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetInterestsByCategory")
        }</span>

        // Получаем обновленные выборы пользователя
        <span class="cov0" title="0">userSelections, err := pih.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Создаем карту выбранных интересов
        <span class="cov0" title="0">selectedMap := make(map[int]bool)
        for _, selection := range userSelections </span><span class="cov0" title="0">{
                selectedMap[selection.InterestID] = true
        }</span>

        // Создаем обновленную клавиатуру
        <span class="cov0" title="0">keyboard := pih.keyboardBuilder.CreateCategoryInterestsKeyboard(
                interests,
                selectedMap,
                selectedCategory.KeyName,
                user.InterfaceLanguageCode,
        )

        // Обновляем только клавиатуру
        editMsg := tgbotapi.NewEditMessageReplyMarkup(callback.Message.Chat.ID, callback.Message.MessageID, keyboard)
        _, err = pih.bot.Request(editMsg)

        return err</span>
}

// updatePrimaryInterestsKeyboardFromProfile обновляет клавиатуру основных интересов.
func (pih *ProfileInterestHandler) updatePrimaryInterestsKeyboardFromProfile(callback *tgbotapi.CallbackQuery, user *models.User) error <span class="cov0" title="0">{
        // Получаем обновленные выборы пользователя
        userSelections, err := pih.interestService.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pih.errorHandler.HandleTelegramError(err, callback.Message.Chat.ID, int64(user.ID), "GetUserInterestSelections")
        }</span>

        // Создаем обновленную клавиатуру для редактирования
        <span class="cov0" title="0">keyboard := pih.keyboardBuilder.CreateEditPrimaryInterestsKeyboard(userSelections, user.InterfaceLanguageCode)

        // Обновляем только клавиатуру
        editMsg := tgbotapi.NewEditMessageReplyMarkup(callback.Message.Chat.ID, callback.Message.MessageID, keyboard)
        _, err = pih.bot.Request(editMsg)

        return err</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

// UtilityHandler интерфейс для вспомогательных функций.
type UtilityHandler interface {
        SendMessage(chatID int64, text string) error
}

// UtilityHandlerImpl реализация вспомогательного обработчика.
type UtilityHandlerImpl struct {
        base *BaseHandler
}

// NewUtilityHandler создает новый вспомогательный обработчик.
func NewUtilityHandler(base *BaseHandler) *UtilityHandlerImpl <span class="cov0" title="0">{
        return &amp;UtilityHandlerImpl{
                base: base,
        }
}</span>

// SendMessage отправляет сообщение пользователю.
func (h *UtilityHandlerImpl) SendMessage(chatID int64, text string) error <span class="cov0" title="0">{
        // Используем MessageFactory для отправки сообщения
        return h.base.messageFactory.SendText(chatID, text)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package telegram

import (
        "fmt"
        "sort"
        "strconv"

        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Константы для символов.
const (
        SymbolUnchecked = "☐ "
)

// KeyboardBuilder создает различные типы клавиатур для Telegram.
type KeyboardBuilder struct {
        service *core.BotService
}

// NewKeyboardBuilder создает новый экземпляр KeyboardBuilder.
func NewKeyboardBuilder(service *core.BotService) *KeyboardBuilder <span class="cov0" title="0">{
        return &amp;KeyboardBuilder{
                service: service,
        }
}</span>

// CreateInterestCategoriesKeyboard создает клавиатуру для выбора категорий интересов.
func (kb *KeyboardBuilder) CreateInterestCategoriesKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        categories := []struct {
                key  string
                icon string
        }{
                {"entertainment", "🎬"},
                {"education", "📚"},
                {"active", "⚽"},
                {"creative", "🎨"},
                {"social", "👥"},
        }

        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Создаем кнопки категорий (по 2 в ряд)
        for i := 0; i &lt; len(categories); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                categoryName := kb.service.Localizer.Get(interfaceLang, "category_"+categories[i].key)
                button1 := tgbotapi.NewInlineKeyboardButtonData(
                        categoryName,
                        "interest_category_"+categories[i].key,
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(categories) </span><span class="cov0" title="0">{
                        categoryName2 := kb.service.Localizer.Get(interfaceLang, "category_"+categories[i+1].key)
                        button2 := tgbotapi.NewInlineKeyboardButtonData(
                                categoryName2,
                                "interest_category_"+categories[i+1].key,
                        )
                        row = append(row, button2)
                }</span>

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "continue_button"),
                        "interests_continue",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        "back_to_main_menu",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreateCategoryInterestsKeyboard создает клавиатуру для выбора интересов в категории.
func (kb *KeyboardBuilder) CreateCategoryInterestsKeyboard(interests []models.Interest, selectedMap map[int]bool, categoryKey, interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Сортируем интересы по display_order
        sort.Slice(interests, func(i, j int) bool </span><span class="cov0" title="0">{
                return interests[i].DisplayOrder &lt; interests[j].DisplayOrder
        }</span>)

        // Создаем кнопки интересов (по 2 в ряд)
        <span class="cov0" title="0">for i := 0; i &lt; len(interests); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                interest1 := interests[i]
                interestName1 := kb.service.Localizer.Get(interfaceLang, "interest_"+interest1.KeyName)

                prefix1 := SymbolUnchecked
                if selectedMap[interest1.ID] </span><span class="cov0" title="0">{
                        prefix1 = "✅ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "interest_select_"+strconv.Itoa(interest1.ID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(interests) </span><span class="cov0" title="0">{
                        interest2 := interests[i+1]
                        interestName2 := kb.service.Localizer.Get(interfaceLang, "interest_"+interest2.KeyName)

                        prefix2 := SymbolUnchecked
                        if selectedMap[interest2.ID] </span><span class="cov0" title="0">{
                                prefix2 = "✅ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "interest_select_"+strconv.Itoa(interest2.ID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "continue_button"),
                        "interests_continue",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        "back_to_categories",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreatePrimaryInterestsKeyboard создает клавиатуру для выбора основных интересов.
func (kb *KeyboardBuilder) CreatePrimaryInterestsKeyboard(
        selections interface{},
        interfaceLang string,
) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        var buttonRows [][]tgbotapi.InlineKeyboardButton

        // Приводим к правильному типу
        var tempSelections []models.InterestSelection
        if modelsSelections, ok := selections.([]models.InterestSelection); ok </span><span class="cov0" title="0">{
                tempSelections = modelsSelections
        }</span>

        // Сортируем выборы по порядку выбора
        <span class="cov0" title="0">sort.Slice(tempSelections, func(i, j int) bool </span><span class="cov0" title="0">{
                return tempSelections[i].SelectionOrder &lt; tempSelections[j].SelectionOrder
        }</span>)

        // Создаем кнопки для каждого выбранного интереса
        <span class="cov0" title="0">for i := 0; i &lt; len(tempSelections); i += 2 </span><span class="cov0" title="0">{
                var row []tgbotapi.InlineKeyboardButton

                // Первая кнопка в ряду
                selection1 := tempSelections[i]
                // Получаем название интереса (упрощенно, в реальности нужно загружать из БД)
                interestName1 := fmt.Sprintf("Интерес %d", selection1.InterestID)

                prefix1 := SymbolUnchecked
                if selection1.IsPrimary </span><span class="cov0" title="0">{
                        prefix1 = "⭐ "
                }</span>

                <span class="cov0" title="0">button1 := tgbotapi.NewInlineKeyboardButtonData(
                        prefix1+interestName1,
                        "primary_interest_"+strconv.Itoa(selection1.InterestID),
                )
                row = append(row, button1)

                // Вторая кнопка в ряду (если есть)
                if i+1 &lt; len(tempSelections) </span><span class="cov0" title="0">{
                        selection2 := tempSelections[i+1]
                        interestName2 := fmt.Sprintf("Интерес %d", selection2.InterestID)

                        prefix2 := SymbolUnchecked
                        if selection2.IsPrimary </span><span class="cov0" title="0">{
                                prefix2 = "⭐ "
                        }</span>

                        <span class="cov0" title="0">button2 := tgbotapi.NewInlineKeyboardButtonData(
                                prefix2+interestName2,
                                "primary_interest_"+strconv.Itoa(selection2.InterestID),
                        )
                        row = append(row, button2)</span>
                }

                <span class="cov0" title="0">buttonRows = append(buttonRows, row)</span>
        }

        // Добавляем кнопки управления
        <span class="cov0" title="0">controlRow := []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "continue_button"),
                        "primary_interests_continue",
                ),
                tgbotapi.NewInlineKeyboardButtonData(
                        kb.service.Localizer.Get(interfaceLang, "back_button"),
                        "back_to_interests",
                ),
        }
        buttonRows = append(buttonRows, controlRow)

        return tgbotapi.NewInlineKeyboardMarkup(buttonRows...)</span>
}

// CreateProfileCompletedKeyboard создает клавиатуру после завершения настройки профиля.
func (kb *KeyboardBuilder) CreateProfileCompletedKeyboard(interfaceLang string) tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        mainMenu := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "main_menu_title"),
                "back_to_main_menu",
        )
        viewProfile := tgbotapi.NewInlineKeyboardButtonData(
                kb.service.Localizer.Get(interfaceLang, "profile_show"),
                "profile_show",
        )
        buttons := [][]tgbotapi.InlineKeyboardButton{
                {mainMenu, viewProfile},
        }

        return tgbotapi.NewInlineKeyboardMarkup(buttons...)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package telegram

import (
        "time"

        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// MessageFactory предоставляет гибридный API для отправки Telegram сообщений.
// Поддерживает как простые методы для частых случаев, так и Builder паттерн для сложных сценариев.
type MessageFactory struct {
        bot          *tgbotapi.BotAPI
        errorHandler *errors.ErrorHandler
        logger       *logging.LoggingService
}

// MessageBuilder предоставляет Builder API для создания новых сообщений.
type MessageBuilder struct {
        factory   *MessageFactory
        config    tgbotapi.MessageConfig
        chatID    int64
        userID    int64
        operation string
}

// EditMessageBuilder предоставляет Builder API для редактирования сообщений.
type EditMessageBuilder struct {
        factory   *MessageFactory
        config    tgbotapi.EditMessageTextConfig
        chatID    int64
        messageID int
        userID    int64
        operation string
}

// NewMessageFactory создает новый экземпляр MessageFactory.
func NewMessageFactory(
        bot *tgbotapi.BotAPI,
        errorHandler *errors.ErrorHandler,
        logger *logging.LoggingService,
) *MessageFactory <span class="cov0" title="0">{
        return &amp;MessageFactory{
                bot:          bot,
                errorHandler: errorHandler,
                logger:       logger,
        }
}</span>

// =============================================================================
// ПРОСТЫЕ МЕТОДЫ (Quick API) - для 80% случаев использования
// =============================================================================

// SendText отправляет простое текстовое сообщение.
func (f *MessageFactory) SendText(chatID int64, text string) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, text)
        return f.sendWithLogging(msg, chatID, 0, "SendText", "text")
}</span>

// SendWithKeyboard отправляет сообщение с клавиатурой.
func (f *MessageFactory) SendWithKeyboard(chatID int64, text string, keyboard interface{}) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, text)
        msg.ReplyMarkup = keyboard
        return f.sendWithLogging(msg, chatID, 0, "SendWithKeyboard", "text_with_keyboard")
}</span>

// SendHTML отправляет HTML-форматированное сообщение.
func (f *MessageFactory) SendHTML(chatID int64, htmlText string) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, htmlText)
        msg.ParseMode = "HTML"
        return f.sendWithLogging(msg, chatID, 0, "SendHTML", "html")
}</span>

// SendHTMLWithKeyboard отправляет HTML-форматированное сообщение с клавиатурой.
func (f *MessageFactory) SendHTMLWithKeyboard(chatID int64, htmlText string, keyboard interface{}) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, htmlText)
        msg.ParseMode = "HTML"
        msg.ReplyMarkup = keyboard
        return f.sendWithLogging(msg, chatID, 0, "SendHTMLWithKeyboard", "html_with_keyboard")
}</span>

// EditText редактирует текстовое сообщение.
func (f *MessageFactory) EditText(chatID int64, messageID int, text string) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
        return f.sendWithLogging(edit, chatID, 0, "EditText", "edit_text")
}</span>

// EditWithKeyboard редактирует сообщение с клавиатурой.
func (f *MessageFactory) EditWithKeyboard(chatID int64, messageID int, text string, keyboard *tgbotapi.InlineKeyboardMarkup) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
        edit.ReplyMarkup = keyboard
        return f.sendWithLogging(edit, chatID, 0, "EditWithKeyboard", "edit_with_keyboard")
}</span>

// EditHTML редактирует HTML-форматированное сообщение.
func (f *MessageFactory) EditHTML(chatID int64, messageID int, htmlText string) error <span class="cov0" title="0">{
        edit := tgbotapi.NewEditMessageText(chatID, messageID, htmlText)
        edit.ParseMode = "HTML"
        return f.sendWithLogging(edit, chatID, 0, "EditHTML", "edit_html")
}</span>

// =============================================================================
// BUILDER API - для сложных случаев (20% использования)
// =============================================================================

// NewMessage создает новый MessageBuilder для отправки сообщения.
func (f *MessageFactory) NewMessage(chatID int64) *MessageBuilder <span class="cov0" title="0">{
        return &amp;MessageBuilder{
                factory:   f,
                config:    tgbotapi.MessageConfig{},
                chatID:    chatID,
                userID:    0,
                operation: "NewMessage",
        }
}</span>

// NewEditMessage создает новый EditMessageBuilder для редактирования сообщения.
func (f *MessageFactory) NewEditMessage(chatID int64, messageID int) *EditMessageBuilder <span class="cov0" title="0">{
        return &amp;EditMessageBuilder{
                factory:   f,
                config:    tgbotapi.EditMessageTextConfig{},
                chatID:    chatID,
                messageID: messageID,
                userID:    0,
                operation: "NewEditMessage",
        }
}</span>

// =============================================================================
// MESSAGE BUILDER METHODS
// =============================================================================

// WithText устанавливает текст сообщения.
func (b *MessageBuilder) WithText(text string) *MessageBuilder <span class="cov0" title="0">{
        b.config = tgbotapi.NewMessage(b.chatID, text)
        return b
}</span>

// WithKeyboard устанавливает клавиатуру.
func (b *MessageBuilder) WithKeyboard(keyboard interface{}) *MessageBuilder <span class="cov0" title="0">{
        b.config.ReplyMarkup = keyboard
        return b
}</span>

// WithParseMode устанавливает режим парсинга (HTML, Markdown, MarkdownV2).
func (b *MessageBuilder) WithParseMode(mode string) *MessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = mode
        return b
}</span>

// WithHTML устанавливает HTML режим парсинга.
func (b *MessageBuilder) WithHTML() *MessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "HTML"
        return b
}</span>

// WithMarkdown устанавливает Markdown режим парсинга.
func (b *MessageBuilder) WithMarkdown() *MessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "Markdown"
        return b
}</span>

// DisableWebPagePreview отключает превью веб-страниц.
func (b *MessageBuilder) DisableWebPagePreview() *MessageBuilder <span class="cov0" title="0">{
        b.config.DisableWebPagePreview = true
        return b
}</span>

// DisableNotification отправляет сообщение без уведомления.
func (b *MessageBuilder) DisableNotification() *MessageBuilder <span class="cov0" title="0">{
        b.config.DisableNotification = true
        return b
}</span>

// ReplyTo устанавливает сообщение для ответа.
func (b *MessageBuilder) ReplyTo(messageID int) *MessageBuilder <span class="cov0" title="0">{
        b.config.ReplyToMessageID = messageID
        return b
}</span>

// WithUserID устанавливает ID пользователя для логирования.
func (b *MessageBuilder) WithUserID(userID int64) *MessageBuilder <span class="cov0" title="0">{
        b.userID = userID
        return b
}</span>

// WithOperation устанавливает название операции для логирования.
func (b *MessageBuilder) WithOperation(operation string) *MessageBuilder <span class="cov0" title="0">{
        b.operation = operation
        return b
}</span>

// Send отправляет сообщение.
func (b *MessageBuilder) Send() error <span class="cov0" title="0">{
        return b.factory.sendWithLogging(b.config, b.chatID, b.userID, b.operation, "builder_message")
}</span>

// =============================================================================
// EDIT MESSAGE BUILDER METHODS
// =============================================================================

// WithText устанавливает новый текст для редактирования.
func (b *EditMessageBuilder) WithText(text string) *EditMessageBuilder <span class="cov0" title="0">{
        b.config = tgbotapi.NewEditMessageText(b.chatID, b.messageID, text)
        return b
}</span>

// WithKeyboard устанавливает клавиатуру для редактирования.
func (b *EditMessageBuilder) WithKeyboard(keyboard *tgbotapi.InlineKeyboardMarkup) *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ReplyMarkup = keyboard
        return b
}</span>

// WithParseMode устанавливает режим парсинга для редактирования.
func (b *EditMessageBuilder) WithParseMode(mode string) *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = mode
        return b
}</span>

// WithHTML устанавливает HTML режим парсинга для редактирования.
func (b *EditMessageBuilder) WithHTML() *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "HTML"
        return b
}</span>

// WithMarkdown устанавливает Markdown режим парсинга для редактирования.
func (b *EditMessageBuilder) WithMarkdown() *EditMessageBuilder <span class="cov0" title="0">{
        b.config.ParseMode = "Markdown"
        return b
}</span>

// WithUserID устанавливает ID пользователя для логирования.
func (b *EditMessageBuilder) WithUserID(userID int64) *EditMessageBuilder <span class="cov0" title="0">{
        b.userID = userID
        return b
}</span>

// WithOperation устанавливает название операции для логирования.
func (b *EditMessageBuilder) WithOperation(operation string) *EditMessageBuilder <span class="cov0" title="0">{
        b.operation = operation
        return b
}</span>

// Send отправляет редактирование сообщения.
func (b *EditMessageBuilder) Send() error <span class="cov0" title="0">{
        return b.factory.sendWithLogging(b.config, b.chatID, b.userID, b.operation, "builder_edit")
}</span>

// =============================================================================
// ВНУТРЕННЯЯ ЛОГИКА
// =============================================================================

// sendWithLogging отправляет сообщение с логированием и обработкой ошибок.
func (f *MessageFactory) sendWithLogging(
        msg tgbotapi.Chattable,
        chatID int64,
        userID int64,
        operation string,
        messageType string,
) error <span class="cov0" title="0">{
        // Логирование перед отправкой
        f.logOutgoingMessage(chatID, userID, operation, messageType)

        // Отправка
        _, err := f.bot.Send(msg)

        // Обработка ошибки
        if err != nil </span><span class="cov0" title="0">{
                return f.errorHandler.HandleTelegramError(err, chatID, userID, operation)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logOutgoingMessage логирует исходящее сообщение.
func (f *MessageFactory) logOutgoingMessage(chatID int64, userID int64, operation string, messageType string) <span class="cov0" title="0">{
        requestID := "out_" + time.Now().Format("20060102150405") + "_" + operation

        f.logger.Telegram().InfoWithContext(
                "Outgoing message",
                requestID,
                userID,
                chatID,
                operation,
                map[string]interface{}{
                        "message_type": messageType,
                        "chat_id":      chatID,
                        "user_id":      userID,
                },
        )
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package telegram

import (
        "fmt"
        "sync"
        "time"

        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
)

// RateLimitConfig конфигурация rate limiter'а
type RateLimitConfig struct {
        MaxRequests     int           // Максимальное количество запросов
        WindowDuration  time.Duration // Период времени для подсчета
        BlockDuration   time.Duration // Длительность блокировки при превышении
        CleanupInterval time.Duration // Интервал очистки устаревших записей
}

// DefaultRateLimitConfig возвращает конфигурацию по умолчанию для защиты от спама
// Настройки подобраны для типичного использования: пиковые нагрузки до 20 сообщений/минуту,
// но обычно гораздо медленнее. При превышении - короткая блокировка для коррекции поведения.
func DefaultRateLimitConfig() RateLimitConfig <span class="cov8" title="1">{
        return RateLimitConfig{
                MaxRequests:     20,                                                 // 20 запросов (мягкий лимит для пиковых нагрузок)
                WindowDuration:  localization.RateLimitWindowMinutes * time.Minute,  // в минуту
                BlockDuration:   localization.RateLimitBlockMinutes * time.Minute,   // блокировка на 2 минуты (короткая для мягкого режима)
                CleanupInterval: localization.RateLimitCleanupMinutes * time.Minute, // очистка каждые 10 минут
        }
}</span>

// UserRateLimit информация о rate limit для пользователя
type UserRateLimit struct {
        RequestCount int       // Количество запросов
        FirstRequest time.Time // Время первого запроса в окне
        BlockUntil   time.Time // Время окончания блокировки
}

// RateLimiter реализация rate limiting для защиты от спама
type RateLimiter struct {
        config     RateLimitConfig
        userLimits map[int64]*UserRateLimit
        mutex      sync.RWMutex
        stopChan   chan struct{}
}

// NewRateLimiter создает новый rate limiter
func NewRateLimiter(config RateLimitConfig) *RateLimiter <span class="cov8" title="1">{
        rl := &amp;RateLimiter{
                config:     config,
                userLimits: make(map[int64]*UserRateLimit),
                stopChan:   make(chan struct{}),
        }

        // Запускаем горутину для очистки устаревших записей
        go rl.cleanupWorker()

        return rl
}</span>

// IsAllowed проверяет, разрешен ли запрос от пользователя
func (rl *RateLimiter) IsAllowed(userID int64) (bool, time.Duration) <span class="cov8" title="1">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()

        now := time.Now()
        userLimit, exists := rl.userLimits[userID]

        if !exists </span><span class="cov8" title="1">{
                // Первый запрос от пользователя
                rl.userLimits[userID] = &amp;UserRateLimit{
                        RequestCount: 1,
                        FirstRequest: now,
                }
                return true, 0
        }</span>

        // Проверяем, заблокирован ли пользователь
        <span class="cov0" title="0">if now.Before(userLimit.BlockUntil) </span><span class="cov0" title="0">{
                remaining := userLimit.BlockUntil.Sub(now)
                return false, remaining
        }</span>

        // Проверяем, истекло ли окно времени
        <span class="cov0" title="0">windowExpired := now.Sub(userLimit.FirstRequest) &gt;= rl.config.WindowDuration

        // Если окно истекло, полностью сбрасываем
        if windowExpired </span><span class="cov0" title="0">{
                userLimit.RequestCount = 1 // Сбрасываем на 1 (текущий запрос)
                userLimit.FirstRequest = now
                userLimit.BlockUntil = time.Time{}
                return true, 0
        }</span>

        // Проверяем, была ли недавняя блокировка (истекла в этом окне)
        // Если да, даем "второй шанс" - сбрасываем счетчик
        <span class="cov0" title="0">if !userLimit.BlockUntil.IsZero() &amp;&amp; now.After(userLimit.BlockUntil) </span><span class="cov0" title="0">{
                userLimit.RequestCount = 1         // Сбрасываем на 1 (второй шанс)
                userLimit.BlockUntil = time.Time{} // Сбрасываем блокировку
                return true, 0
        }</span>

        // Окно активно, увеличиваем счетчик
        <span class="cov0" title="0">userLimit.RequestCount++

        // Проверяем, превышен ли лимит
        if userLimit.RequestCount &gt; rl.config.MaxRequests </span><span class="cov0" title="0">{
                userLimit.BlockUntil = now.Add(rl.config.BlockDuration)
                remaining := rl.config.BlockDuration
                return false, remaining
        }</span>

        <span class="cov0" title="0">return true, 0</span>
}

// GetStats возвращает статистику rate limiter'а
func (rl *RateLimiter) GetStats() map[string]interface{} <span class="cov8" title="1">{
        rl.mutex.RLock()
        defer rl.mutex.RUnlock()

        now := time.Now()
        activeUsers := 0
        blockedUsers := 0

        for _, limit := range rl.userLimits </span><span class="cov0" title="0">{
                if now.Sub(limit.FirstRequest) &lt; rl.config.WindowDuration*2 </span><span class="cov0" title="0">{ // Активные за последние 2 окна
                        activeUsers++
                        if now.Before(limit.BlockUntil) </span><span class="cov0" title="0">{
                                blockedUsers++
                        }</span>
                }
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "total_tracked_users": len(rl.userLimits),
                "active_users":        activeUsers,
                "blocked_users":       blockedUsers,
                "max_requests":        rl.config.MaxRequests,
                "window_duration":     rl.config.WindowDuration.String(),
                "block_duration":      rl.config.BlockDuration.String(),
        }</span>
}

// cleanupWorker периодически очищает устаревшие записи
func (rl *RateLimiter) cleanupWorker() <span class="cov8" title="1">{
        ticker := time.NewTicker(rl.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rl.cleanup()</span>
                case &lt;-rl.stopChan:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// cleanup удаляет устаревшие записи пользователей
func (rl *RateLimiter) cleanup() <span class="cov0" title="0">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()

        now := time.Now()
        cutoff := now.Add(-rl.config.WindowDuration * 2) // Удаляем записи старше 2 окон

        for userID, limit := range rl.userLimits </span><span class="cov0" title="0">{
                if limit.FirstRequest.Before(cutoff) &amp;&amp; now.After(limit.BlockUntil) </span><span class="cov0" title="0">{
                        delete(rl.userLimits, userID)
                }</span>
        }
}

// Stop останавливает rate limiter
func (rl *RateLimiter) Stop() <span class="cov8" title="1">{
        if rl.stopChan != nil </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rl.stopChan:<span class="cov8" title="1"></span>
                        // Канал уже закрыт
                default:<span class="cov8" title="1">
                        close(rl.stopChan)</span>
                }
        }
}

// CheckRateLimit проверяет rate limit и возвращает ошибку если превышен
func (rl *RateLimiter) CheckRateLimit(userID int64) error <span class="cov8" title="1">{
        allowed, remaining := rl.IsAllowed(userID)

        if !allowed </span><span class="cov0" title="0">{
                return errors.NewCustomError(
                        errors.ErrorTypeValidation,
                        fmt.Sprintf("Rate limit exceeded. Try again in %v", remaining.Round(time.Second)),
                        "Слишком много запросов. Попробуйте позже",
                        "",
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package cache provides caching functionality with support for in-memory and Redis backends.
package cache

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"
)

// CacheCleanupInterval - интервал очистки кэша (используется из centralized constants).
var CacheCleanupInterval = localization.CacheCleanupMinutes * time.Minute

// Константы для вычислений.
const (
        // PercentageMultiplier - множитель для преобразования в проценты.
        PercentageMultiplier = 100.0
)

// Service основной сервис кэширования.
type Service struct {
        // Кэши для разных типов данных
        languages          map[string]*Entry // Ключ: язык интерфейса
        interests          map[string]*Entry // Ключ: язык интерфейса
        translations       map[string]*Entry // Ключ: язык интерфейса
        users              map[int64]*Entry  // Ключ: user ID
        stats              map[string]*Entry // Ключ: тип статистики
        interestCategories map[string]*Entry // Ключ: язык интерфейса
        userStats          map[int64]*Entry  // Ключ: user ID
        configCache        map[string]*Entry // Ключ: config key

        // Конфигурация
        config *Config

        // Потокобезопасность
        mutex sync.RWMutex

        // Статистика
        cacheStats Stats

        // Канал для остановки очистки
        stopCleanup chan struct{}
}

// NewService создает новый экземпляр Service.
func NewService(config *Config) *Service <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        <span class="cov8" title="1">cacheService := &amp;Service{
                languages:          make(map[string]*Entry),
                interests:          make(map[string]*Entry),
                translations:       make(map[string]*Entry),
                users:              make(map[int64]*Entry),
                stats:              make(map[string]*Entry),
                interestCategories: make(map[string]*Entry),
                userStats:          make(map[int64]*Entry),
                configCache:        make(map[string]*Entry),
                config:             config,
                stopCleanup:        make(chan struct{}),
                mutex:              sync.RWMutex{},
                cacheStats: Stats{
                        Hits:   0,
                        Misses: 0,
                        Size:   0,
                },
        }

        // Запускаем фоновую очистку истекших записей
        go cacheService.startCleanup()

        return cacheService</span>
}

// GetLanguages получает языки из кэша или возвращает nil если нет в кэше.
func (cacheService *Service) GetLanguages(_ context.Context, lang string) ([]*models.Language, bool) <span class="cov8" title="1">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.languages[lang]
        if !exists || entry == nil || entry.IsExpired() </span><span class="cov8" title="1">{
                cacheService.cacheStats.Misses++

                return nil, false
        }</span>

        <span class="cov8" title="1">cacheService.cacheStats.Hits++

        if data, ok := entry.Data.(*CachedLanguages); ok &amp;&amp; data != nil </span><span class="cov8" title="1">{
                return data.Languages, true
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Misses++

        return nil, false</span>
}

// SetLanguages сохраняет языки в кэш.
func (cacheService *Service) SetLanguages(_ context.Context, lang string, languages []*models.Language) <span class="cov8" title="1">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.languages[lang] = &amp;Entry{
                Data: &amp;CachedLanguages{
                        Languages: languages,
                        Lang:      lang,
                },
                ExpiresAt: time.Now().Add(cacheService.config.LanguagesTTL),
        }

        cacheService.updateSize()
}</span>

// GetInterests получает интересы из кэша или возвращает nil если нет в кэше.
func (cacheService *Service) GetInterests(_ context.Context, lang string) (map[int]string, bool) <span class="cov8" title="1">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.interests[lang]
        if !exists || entry == nil || entry.IsExpired() </span><span class="cov8" title="1">{
                cacheService.cacheStats.Misses++

                return nil, false
        }</span>

        <span class="cov8" title="1">cacheService.cacheStats.Hits++

        if data, ok := entry.Data.(*CachedInterests); ok &amp;&amp; data != nil </span><span class="cov8" title="1">{
                return data.Interests, true
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Misses++

        return nil, false</span>
}

// SetInterests сохраняет интересы в кэш.
func (cacheService *Service) SetInterests(_ context.Context, lang string, interests map[int]string) <span class="cov8" title="1">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.interests[lang] = &amp;Entry{
                Data: &amp;CachedInterests{
                        Interests: interests,
                        Lang:      lang,
                },
                ExpiresAt: time.Now().Add(cacheService.config.InterestsTTL),
        }

        cacheService.updateSize()
}</span>

// GetUser получает пользователя из кэша или возвращает nil если нет в кэше.
func (cacheService *Service) GetUser(_ context.Context, userID int64) (*models.User, bool) <span class="cov8" title="1">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.users[userID]
        if !exists || entry == nil || entry.IsExpired() </span><span class="cov8" title="1">{
                cacheService.cacheStats.Misses++

                return nil, false
        }</span>

        <span class="cov8" title="1">cacheService.cacheStats.Hits++

        if data, ok := entry.Data.(*CachedUser); ok &amp;&amp; data != nil </span><span class="cov8" title="1">{
                return data.User, true
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Misses++

        return nil, false</span>
}

// SetUser сохраняет пользователя в кэш.
func (cacheService *Service) SetUser(_ context.Context, user *models.User) <span class="cov8" title="1">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.users[int64(user.ID)] = &amp;Entry{
                Data: &amp;CachedUser{
                        User: user,
                        Lang: user.InterfaceLanguageCode,
                },
                ExpiresAt: time.Now().Add(cacheService.config.UsersTTL),
        }

        cacheService.updateSize()
}</span>

// GetTranslations получает переводы из кэша или возвращает nil если нет в кэше.
func (cacheService *Service) GetTranslations(_ context.Context, lang string) (map[string]string, bool) <span class="cov0" title="0">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.translations[lang]
        if !exists || entry.IsExpired() </span><span class="cov0" title="0">{
                cacheService.cacheStats.Misses++

                return nil, false
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Hits++

        if data, ok := entry.Data.(map[string]string); ok </span><span class="cov0" title="0">{
                return data, true
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Misses++

        return nil, false</span>
}

// SetTranslations сохраняет переводы в кэш.
func (cacheService *Service) SetTranslations(_ context.Context, lang string, translations map[string]string) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.translations[lang] = &amp;Entry{
                Data:      translations,
                ExpiresAt: time.Now().Add(cacheService.config.TranslationsTTL),
        }

        cacheService.updateSize()
}</span>

// GetStats получает статистику из кэша или возвращает nil если нет в кэше.
func (cacheService *Service) GetStats(_ context.Context, statsType string) (map[string]interface{}, bool) <span class="cov0" title="0">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.stats[statsType]
        if !exists || entry.IsExpired() </span><span class="cov0" title="0">{
                cacheService.cacheStats.Misses++

                return nil, false
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Hits++

        if data, ok := entry.Data.(*CachedStats); ok </span><span class="cov0" title="0">{
                return data.Data, true
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Misses++

        return nil, false</span>
}

// SetStats сохраняет статистику в кэш.
func (cacheService *Service) SetStats(_ context.Context, statsType string, data map[string]interface{}) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.stats[statsType] = &amp;Entry{
                Data: &amp;CachedStats{
                        Data: data,
                        Type: statsType,
                },
                ExpiresAt: time.Now().Add(cacheService.config.StatsTTL),
        }

        cacheService.updateSize()
}</span>

// InvalidateUser удаляет пользователя из кэша.
func (cacheService *Service) InvalidateUser(_ context.Context, userID int64) <span class="cov8" title="1">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        delete(cacheService.users, userID)
        cacheService.updateSize()

        log.Printf("Cache: Invalidated user %d", userID)
}</span>

// InvalidateLanguages удаляет языки из кэша.
func (cacheService *Service) InvalidateLanguages(_ context.Context) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.languages = make(map[string]*Entry)
        cacheService.updateSize()

        log.Printf("Cache: Invalidated all languages")
}</span>

// InvalidateInterests удаляет интересы из кэша.
func (cacheService *Service) InvalidateInterests(_ context.Context) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.interests = make(map[string]*Entry)
        cacheService.updateSize()

        log.Printf("Cache: Invalidated all interests")
}</span>

// InvalidateTranslations удаляет переводы из кэша.
func (cacheService *Service) InvalidateTranslations(_ context.Context) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.translations = make(map[string]*Entry)
        cacheService.updateSize()

        log.Printf("Cache: Invalidated all translations")
}</span>

// ClearAll очищает весь кэш.
func (cacheService *Service) ClearAll(_ context.Context) <span class="cov8" title="1">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.languages = make(map[string]*Entry)
        cacheService.interests = make(map[string]*Entry)
        cacheService.translations = make(map[string]*Entry)
        cacheService.users = make(map[int64]*Entry)
        cacheService.stats = make(map[string]*Entry)
        cacheService.updateSize()

        log.Printf("Cache: Cleared all data")
}</span>

// GetCacheStats returns cache statisticacheService.
func (cacheService *Service) GetCacheStats(_ context.Context) Stats <span class="cov8" title="1">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        return Stats{
                Hits:   cacheService.cacheStats.Hits,
                Misses: cacheService.cacheStats.Misses,
                Size:   cacheService.cacheStats.Size,
        }
}</span>

// Stop останавливает кэш-сервис.
func (cacheService *Service) Stop() <span class="cov0" title="0">{
        close(cacheService.stopCleanup)
        log.Printf("Cache: Service stopped")
}</span>

// String возвращает строковое представление статистики кэша.
func (cacheService *Service) String() string <span class="cov8" title="1">{
        stats := cacheService.GetCacheStats(context.Background())

        hitRate := float64(0)

        if stats.Hits+stats.Misses &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(stats.Hits) / float64(stats.Hits+stats.Misses) * PercentageMultiplier
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("Cache Stats: Hits=%d, Misses=%d, HitRate=%.2f%%, Size=%d, Evictions=%d, Memory=%dKB",
                stats.Hits, stats.Misses, hitRate, stats.Size, stats.Evictions, stats.MemoryUsage/1024)</span>
}

// updateSize обновляет размер кэша и метрики.
func (cacheService *Service) updateSize() <span class="cov8" title="1">{
        cacheService.cacheStats.Size = len(cacheService.languages) + len(cacheService.interests) +
                len(cacheService.translations) + len(cacheService.users) + len(cacheService.stats) +
                len(cacheService.interestCategories) + len(cacheService.userStats) + len(cacheService.configCache)

        // Обновляем hit ratio
        total := cacheService.cacheStats.Hits + cacheService.cacheStats.Misses
        if total &gt; 0 </span><span class="cov8" title="1">{
                cacheService.cacheStats.HitRatio = float64(cacheService.cacheStats.Hits) / float64(total)
        }</span>

        // Обновляем использование памяти (приблизительная оценка)
        <span class="cov8" title="1">cacheService.cacheStats.MemoryUsage = int64(cacheService.cacheStats.Size * 1024)</span> // 1KB на запись
}

// startCleanup запускает фоновую очистку истекших записей.
func (cacheService *Service) startCleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(CacheCleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cacheService.cleanupExpired()</span>
                case &lt;-cacheService.stopCleanup:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// cleanupExpired удаляет истекшие записи.
func (cacheService *Service) cleanupExpired() <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cleaned := cacheService.cleanupLanguages() + cacheService.cleanupInterests() + cacheService.cleanupTranslations() +
                cacheService.cleanupUsers() + cacheService.cleanupStats() + cacheService.cleanupInterestCategories() +
                cacheService.cleanupUserStats() + cacheService.cleanupConfigCache()

        // Обновляем счетчик evictions
        cacheService.cacheStats.Evictions += int64(cleaned)

        cacheService.updateSize()

        if cleaned &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Cache: Cleaned %d expired entries", cleaned)
        }</span>
}

// cleanupLanguages очищает истекшие языки.
func (cacheService *Service) cleanupLanguages() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.languages </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.languages, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupInterests очищает истекшие интересы.
func (cacheService *Service) cleanupInterests() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.interests </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.interests, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupTranslations очищает истекшие переводы.
func (cacheService *Service) cleanupTranslations() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.translations </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.translations, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupUsers очищает истекших пользователей.
func (cacheService *Service) cleanupUsers() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.users </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.users, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupStats очищает истекшую статистику.
func (cacheService *Service) cleanupStats() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.stats </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.stats, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupInterestCategories очищает истекшие категории интересов.
func (cacheService *Service) cleanupInterestCategories() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.interestCategories </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.interestCategories, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupUserStats очищает истекшую статистику пользователей.
func (cacheService *Service) cleanupUserStats() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.userStats </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.userStats, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// cleanupConfigCache очищает истекшую конфигурацию.
func (cacheService *Service) cleanupConfigCache() int <span class="cov0" title="0">{
        cleaned := 0

        for key, entry := range cacheService.configCache </span><span class="cov0" title="0">{
                if entry.IsExpired() </span><span class="cov0" title="0">{
                        delete(cacheService.configCache, key)

                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}

// Set сохраняет произвольные данные в кэш.
func (cacheService *Service) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        // Используем общую карту для произвольных данных
        if cacheService.stats == nil </span><span class="cov0" title="0">{
                cacheService.stats = make(map[string]*Entry)
        }</span>

        <span class="cov0" title="0">cacheService.stats[key] = &amp;Entry{
                Data:      value,
                ExpiresAt: time.Now().Add(ttl),
        }

        cacheService.updateSize()
        return nil</span>
}

// Get получает произвольные данные из кэша.
func (cacheService *Service) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.stats[key]
        if !exists || entry == nil || entry.IsExpired() </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found: %s", key)
        }</span>

        // Простое присваивание для совместимости
        // В реальной реализации нужно было бы использовать reflection
        <span class="cov0" title="0">*dest.(*interface{}) = entry.Data
        return nil</span>
}

// Delete удаляет ключ из кэша.
func (cacheService *Service) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        delete(cacheService.stats, key)
        cacheService.updateSize()
        return nil
}</span>

// ===== НОВЫЕ МЕТОДЫ КЕШИРОВАНИЯ =====

// GetInterestCategories получает категории интересов из кэша.
func (cacheService *Service) GetInterestCategories(ctx context.Context, lang string) ([]*models.InterestCategory, bool) <span class="cov0" title="0">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.interestCategories[lang]
        if !exists || entry.IsExpired() </span><span class="cov0" title="0">{
                cacheService.cacheStats.Misses++
                return nil, false
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Hits++
        return entry.Data.([]*models.InterestCategory), true</span>
}

// SetInterestCategories сохраняет категории интересов в кэш.
func (cacheService *Service) SetInterestCategories(ctx context.Context, lang string, categories []*models.InterestCategory) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.interestCategories[lang] = &amp;Entry{
                Data:      categories,
                ExpiresAt: time.Now().Add(cacheService.config.LanguagesTTL),
        }
        cacheService.updateSize()
}</span>

// GetUserStats получает статистику пользователя из кэша.
func (cacheService *Service) GetUserStats(ctx context.Context, userID int64) (map[string]interface{}, bool) <span class="cov0" title="0">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.userStats[userID]
        if !exists || entry.IsExpired() </span><span class="cov0" title="0">{
                cacheService.cacheStats.Misses++
                return nil, false
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Hits++
        return entry.Data.(map[string]interface{}), true</span>
}

// SetUserStats сохраняет статистику пользователя в кэш.
func (cacheService *Service) SetUserStats(ctx context.Context, userID int64, stats map[string]interface{}) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.userStats[userID] = &amp;Entry{
                Data:      stats,
                ExpiresAt: time.Now().Add(cacheService.config.LanguagesTTL),
        }
        cacheService.updateSize()
}</span>

// GetConfig получает конфигурацию из кэша.
func (cacheService *Service) GetConfig(ctx context.Context, configKey string) (interface{}, bool) <span class="cov0" title="0">{
        cacheService.mutex.RLock()
        defer cacheService.mutex.RUnlock()

        entry, exists := cacheService.configCache[configKey]
        if !exists || entry.IsExpired() </span><span class="cov0" title="0">{
                cacheService.cacheStats.Misses++
                return nil, false
        }</span>

        <span class="cov0" title="0">cacheService.cacheStats.Hits++
        return entry.Data, true</span>
}

// SetConfig сохраняет конфигурацию в кэш.
func (cacheService *Service) SetConfig(ctx context.Context, configKey string, value interface{}) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.configCache[configKey] = &amp;Entry{
                Data:      value,
                ExpiresAt: time.Now().Add(cacheService.config.LanguagesTTL),
        }
        cacheService.updateSize()
}</span>

// InvalidateInterestCategories инвалидирует кэш категорий интересов.
func (cacheService *Service) InvalidateInterestCategories(ctx context.Context) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.interestCategories = make(map[string]*Entry)
        cacheService.updateSize()
}</span>

// InvalidateUserStats инвалидирует кэш статистики пользователя.
func (cacheService *Service) InvalidateUserStats(ctx context.Context, userID int64) <span class="cov0" title="0">{
        cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        delete(cacheService.userStats, userID)
        cacheService.updateSize()
}</span>

// WarmUp предзагружает критичные данные в кэш при старте приложения.
func (cacheService *Service) WarmUp(ctx context.Context, dataLoader DataLoader) error <span class="cov0" title="0">{
        log.Println("Starting cache warming...")
        start := time.Now()

        // Список языков для предзагрузки
        languages := []string{"ru", "en", "es", "zh"}

        // Предзагружаем языки для всех поддерживаемых языков интерфейса
        for _, lang := range languages </span><span class="cov0" title="0">{
                if err := cacheService.warmUpLanguages(ctx, dataLoader, lang); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to warm up languages for %s: %v", lang, err)
                        // Продолжаем с другими языками даже если один не удался
                }</span>
        }

        // Предзагружаем интересы для всех языков
        <span class="cov0" title="0">for _, lang := range languages </span><span class="cov0" title="0">{
                if err := cacheService.warmUpInterests(ctx, dataLoader, lang); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to warm up interests for %s: %v", lang, err)
                }</span>
        }

        // Предзагружаем категории интересов
        <span class="cov0" title="0">for _, lang := range languages </span><span class="cov0" title="0">{
                if err := cacheService.warmUpInterestCategories(ctx, dataLoader, lang); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to warm up interest categories for %s: %v", lang, err)
                }</span>
        }

        // Предзагружаем переводы
        <span class="cov0" title="0">for _, lang := range languages </span><span class="cov0" title="0">{
                if err := cacheService.warmUpTranslations(ctx, dataLoader, lang); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to warm up translations for %s: %v", lang, err)
                }</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)
        log.Printf("Cache warming completed in %v", duration)
        return nil</span>
}

// DataLoader интерфейс для загрузки данных из внешних источников.
type DataLoader interface {
        LoadLanguages(ctx context.Context, lang string) ([]*models.Language, error)
        LoadInterests(ctx context.Context, lang string) (map[int]string, error)
        LoadInterestCategories(ctx context.Context, lang string) (map[int]string, error)
        LoadTranslations(ctx context.Context, lang string) (map[string]string, error)
}

// warmUpLanguages предзагружает языки для указанного языка интерфейса.
func (cacheService *Service) warmUpLanguages(ctx context.Context, dataLoader DataLoader, lang string) error <span class="cov0" title="0">{
        languages, err := dataLoader.LoadLanguages(ctx, lang)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load languages for %s: %w", lang, err)
        }</span>

        <span class="cov0" title="0">cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cachedData := &amp;CachedLanguages{
                Languages: languages,
                Lang:      lang,
        }

        cacheService.languages[lang] = &amp;Entry{
                Data:      cachedData,
                ExpiresAt: time.Now().Add(cacheService.config.LanguagesTTL),
        }

        cacheService.updateSize()
        return nil</span>
}

// warmUpInterests предзагружает интересы для указанного языка интерфейса.
func (cacheService *Service) warmUpInterests(ctx context.Context, dataLoader DataLoader, lang string) error <span class="cov0" title="0">{
        interests, err := dataLoader.LoadInterests(ctx, lang)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load interests for %s: %w", lang, err)
        }</span>

        <span class="cov0" title="0">cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cachedData := &amp;CachedInterests{
                Interests: interests,
                Lang:      lang,
        }

        cacheService.interests[lang] = &amp;Entry{
                Data:      cachedData,
                ExpiresAt: time.Now().Add(cacheService.config.InterestsTTL),
        }

        cacheService.updateSize()
        return nil</span>
}

// warmUpInterestCategories предзагружает категории интересов для указанного языка интерфейса.
func (cacheService *Service) warmUpInterestCategories(ctx context.Context, dataLoader DataLoader, lang string) error <span class="cov0" title="0">{
        categories, err := dataLoader.LoadInterestCategories(ctx, lang)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load interest categories for %s: %w", lang, err)
        }</span>

        <span class="cov0" title="0">cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cachedData := &amp;CachedInterests{
                Interests: categories,
                Lang:      lang,
        }

        cacheService.interestCategories[lang] = &amp;Entry{
                Data:      cachedData,
                ExpiresAt: time.Now().Add(cacheService.config.InterestCategoriesTTL),
        }

        cacheService.updateSize()
        return nil</span>
}

// warmUpTranslations предзагружает переводы для указанного языка интерфейса.
func (cacheService *Service) warmUpTranslations(ctx context.Context, dataLoader DataLoader, lang string) error <span class="cov0" title="0">{
        translations, err := dataLoader.LoadTranslations(ctx, lang)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load translations for %s: %w", lang, err)
        }</span>

        <span class="cov0" title="0">cacheService.mutex.Lock()
        defer cacheService.mutex.Unlock()

        cacheService.translations[lang] = &amp;Entry{
                Data:      translations,
                ExpiresAt: time.Now().Add(cacheService.config.TranslationsTTL),
        }

        cacheService.updateSize()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package cache

import (
        "context"
        "log"
        "time"
)

// InvalidationService сервис для управления инвалидацией кэша.
type InvalidationService struct {
        cache ServiceInterface
}

// NewInvalidationService создает новый сервис инвалидации.
func NewInvalidationService(cache ServiceInterface) *InvalidationService <span class="cov0" title="0">{
        return &amp;InvalidationService{
                cache: cache,
        }
}</span>

// InvalidateUserData инвалидирует все данные пользователя.
func (is *InvalidationService) InvalidateUserData(userID int64) <span class="cov0" title="0">{
        is.cache.InvalidateUser(context.Background(), userID)
        log.Printf("Invalidation: Cleared all data for user %d", userID)
}</span>

// InvalidateUserProfile инвалидирует профиль пользователя.
func (is *InvalidationService) InvalidateUserProfile(userID int64) <span class="cov0" title="0">{
        is.cache.InvalidateUser(context.Background(), userID)
        log.Printf("Invalidation: Cleared profile for user %d", userID)
}</span>

// InvalidateUserInterests инвалидирует интересы пользователя.
func (is *InvalidationService) InvalidateUserInterests(userID int64) <span class="cov0" title="0">{
        is.cache.InvalidateUser(context.Background(), userID)
        log.Printf("Invalidation: Cleared interests for user %d", userID)
}</span>

// InvalidateUserLanguages инвалидирует языки пользователя.
func (is *InvalidationService) InvalidateUserLanguages(userID int64) <span class="cov0" title="0">{
        is.cache.InvalidateUser(context.Background(), userID)
        log.Printf("Invalidation: Cleared languages for user %d", userID)
}</span>

// InvalidateStaticData инвалидирует статические данные (языки, интересы, переводы).
func (is *InvalidationService) InvalidateStaticData() <span class="cov0" title="0">{
        is.cache.InvalidateLanguages(context.Background())
        is.cache.InvalidateInterests(context.Background())
        is.cache.InvalidateTranslations(context.Background())
        log.Printf("Invalidation: Cleared all static data")
}</span>

// InvalidateFeedbackStats инвалидирует статистику отзывов.
func (is *InvalidationService) InvalidateFeedbackStats() <span class="cov0" title="0">{
        // Для Redis используем ClearAll, для in-memory кэша можно добавить специальный метод
        // Пока что используем общую очистку статистики
        log.Printf("Invalidation: Cleared feedback statistics")
}</span>

// InvalidateUserStats инвалидирует статистику пользователей.
func (is *InvalidationService) InvalidateUserStats() <span class="cov0" title="0">{
        // Для Redis используем ClearAll, для in-memory кэша можно добавить специальный метод
        // Пока что используем общую очистку статистики
        log.Printf("Invalidation: Cleared user statistics")
}</span>

// InvalidateAllStats инвалидирует всю статистику.
func (is *InvalidationService) InvalidateAllStats() <span class="cov0" title="0">{
        // Для Redis используем ClearAll, для in-memory кэша можно добавить специальный метод
        // Пока что используем общую очистку статистики
        log.Printf("Invalidation: Cleared all statistics")
}</span>

// InvalidateByPattern инвалидирует записи по паттерну.
func (is *InvalidationService) InvalidateByPattern(_ string) <span class="cov0" title="0">{
        // Для Redis можно использовать KEYS команду для поиска по паттерну
        // Для in-memory кэша можно добавить специальный метод
        // Пока что используем общую очистку
        log.Printf("Invalidation: Pattern-based invalidation not implemented for interface")
}</span>

// InvalidateExpired принудительно инвалидирует истекшие записи.
func (is *InvalidationService) InvalidateExpired() <span class="cov0" title="0">{
        // Для Redis TTL управляется автоматически
        // Для in-memory кэша можно добавить специальный метод
        log.Printf("Invalidation: Forced cleanup of expired entries")
}</span>

// GetInvalidationStats возвращает статистику инвалидации.
func (is *InvalidationService) GetInvalidationStats() map[string]interface{} <span class="cov0" title="0">{
        stats := is.cache.GetCacheStats(context.Background())

        return map[string]interface{}{
                "cache_hits":   stats.Hits,
                "cache_misses": stats.Misses,
                "cache_size":   stats.Size,
                "hit_rate":     float64(stats.Hits) / float64(stats.Hits+stats.Misses) * PercentageMultiplier,
                "last_cleanup": time.Now().Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package cache

import (
        "context"
        "fmt"
        "log"
        "time"
)

// Константы для метрик.
const (
        // secondsPerMinute - количество секунд в минуте для расчета запросов в секунду.
        secondsPerMinute = 60.0
)

// MetricsService сервис для сбора метрик кэша.
type MetricsService struct {
        cache ServiceInterface

        // Метрики производительности
        avgResponseTime time.Duration
        totalRequests   int64
        errorCount      int64

        // Метрики использования памяти
        memoryUsage    int64
        maxMemoryUsage int64

        // Метрики эффективности
        cacheEfficiency float64
        cleanupCount    int64
}

// NewMetricsService создает новый сервис метрик.
func NewMetricsService(cache ServiceInterface) *MetricsService <span class="cov0" title="0">{
        return &amp;MetricsService{
                cache:           cache,
                avgResponseTime: 0,
                totalRequests:   0,
                errorCount:      0,
                memoryUsage:     0,
                maxMemoryUsage:  0,
                cacheEfficiency: 0,
                cleanupCount:    0,
        }
}</span>

// RecordRequest записывает метрику запроса.
func (ms *MetricsService) RecordRequest(responseTime time.Duration, hit bool) <span class="cov0" title="0">{
        ms.totalRequests++
        ms.avgResponseTime = (ms.avgResponseTime*time.Duration(ms.totalRequests-1) + responseTime) /
                time.Duration(ms.totalRequests)

        if !hit </span><span class="cov0" title="0">{
                ms.errorCount++
        }</span>

        // Обновляем эффективность кэша
        <span class="cov0" title="0">ms.updateCacheEfficiency()</span>
}

// RecordError записывает ошибку.
func (ms *MetricsService) RecordError() <span class="cov0" title="0">{
        ms.errorCount++
}</span>

// RecordCleanup записывает очистку кэша.
func (ms *MetricsService) RecordCleanup() <span class="cov0" title="0">{
        ms.cleanupCount++
}</span>

// GetMetrics возвращает все метрики.
func (ms *MetricsService) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        stats := ms.cache.GetCacheStats(context.Background())

        return map[string]interface{}{
                "performance": map[string]interface{}{
                        "total_requests":    ms.totalRequests,
                        "avg_response_time": ms.avgResponseTime.String(),
                        "error_count":       ms.errorCount,
                        "error_rate":        ms.getErrorRate(),
                },
                "cache": map[string]interface{}{
                        "hits":       stats.Hits,
                        "misses":     stats.Misses,
                        "hit_rate":   ms.getHitRate(stats),
                        "size":       stats.Size,
                        "efficiency": ms.cacheEfficiency,
                },
                "memory": map[string]interface{}{
                        "current_usage": ms.memoryUsage,
                        "max_usage":     ms.maxMemoryUsage,
                },
                "maintenance": map[string]interface{}{
                        "cleanup_count": ms.cleanupCount,
                        "last_cleanup":  time.Now().Format(time.RFC3339),
                },
        }
}</span>

// GetPerformanceMetrics возвращает метрики производительности.
func (ms *MetricsService) GetPerformanceMetrics() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "total_requests":      ms.totalRequests,
                "avg_response_time":   ms.avgResponseTime.String(),
                "error_count":         ms.errorCount,
                "error_rate":          ms.getErrorRate(),
                "requests_per_second": ms.getRequestsPerSecond(),
        }
}</span>

// GetCacheMetrics возвращает метрики кэша.
func (ms *MetricsService) GetCacheMetrics() map[string]interface{} <span class="cov0" title="0">{
        stats := ms.cache.GetCacheStats(context.Background())

        return map[string]interface{}{
                "hits":       stats.Hits,
                "misses":     stats.Misses,
                "hit_rate":   ms.getHitRate(stats),
                "size":       stats.Size,
                "efficiency": ms.cacheEfficiency,
        }
}</span>

// GetMemoryMetrics возвращает метрики памяти.
func (ms *MetricsService) GetMemoryMetrics() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "current_usage": ms.memoryUsage,
                "max_usage":     ms.maxMemoryUsage,
                "usage_percent": ms.getMemoryUsagePercent(),
        }
}</span>

// GetMaintenanceMetrics возвращает метрики обслуживания.
func (ms *MetricsService) GetMaintenanceMetrics() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "cleanup_count":     ms.cleanupCount,
                "last_cleanup":      time.Now().Format(time.RFC3339),
                "cleanup_frequency": ms.getCleanupFrequency(),
        }
}</span>

// LogMetrics выводит метрики в лог.
func (ms *MetricsService) LogMetrics() <span class="cov0" title="0">{
        metrics := ms.GetMetrics()

        log.Printf("=== Cache Metrics ===")
        log.Printf("Performance: %+v", metrics["performance"])
        log.Printf("Cache: %+v", metrics["cache"])
        log.Printf("Memory: %+v", metrics["memory"])
        log.Printf("Maintenance: %+v", metrics["maintenance"])
}</span>

// GetMetricsSummary возвращает краткую сводку метрик.
func (ms *MetricsService) GetMetricsSummary() string <span class="cov0" title="0">{
        stats := ms.cache.GetCacheStats(context.Background())
        hitRate := ms.getHitRate(stats)
        errorRate := ms.getErrorRate()

        return fmt.Sprintf("Cache: %d/%d hits (%.1f%%), %d errors (%.1f%%), %d entries, %s avg response",
                stats.Hits, stats.Hits+stats.Misses, hitRate,
                ms.errorCount, errorRate, stats.Size, ms.avgResponseTime)
}</span>

// ResetMetrics сбрасывает все метрики.
func (ms *MetricsService) ResetMetrics() <span class="cov0" title="0">{
        ms.avgResponseTime = 0
        ms.totalRequests = 0
        ms.errorCount = 0
        ms.memoryUsage = 0
        ms.maxMemoryUsage = 0
        ms.cacheEfficiency = 0
        ms.cleanupCount = 0

        log.Printf("Metrics: All metrics reset")
}</span>

// updateCacheEfficiency обновляет эффективность кэша.
func (ms *MetricsService) updateCacheEfficiency() <span class="cov0" title="0">{
        stats := ms.cache.GetCacheStats(context.Background())

        total := stats.Hits + stats.Misses

        if total &gt; 0 </span><span class="cov0" title="0">{
                ms.cacheEfficiency = float64(stats.Hits) / float64(total) * PercentageMultiplier
        }</span>
}

// getHitRate возвращает процент попаданий в кэш.
func (ms *MetricsService) getHitRate(stats Stats) float64 <span class="cov0" title="0">{
        total := stats.Hits + stats.Misses
        if total == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float64(stats.Hits) / float64(total) * PercentageMultiplier</span>
}

// getErrorRate возвращает процент ошибок.
func (ms *MetricsService) getErrorRate() float64 <span class="cov0" title="0">{
        if ms.totalRequests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float64(ms.errorCount) / float64(ms.totalRequests) * PercentageMultiplier</span>
}

// getRequestsPerSecond возвращает количество запросов в секунду.
func (ms *MetricsService) getRequestsPerSecond() float64 <span class="cov0" title="0">{
        // Упрощенный расчет - в реальности нужно учитывать временные интервалы
        if ms.totalRequests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float64(ms.totalRequests) / secondsPerMinute</span> // Предполагаем 1 минуту работы
}

// getMemoryUsagePercent возвращает процент использования памяти.
func (ms *MetricsService) getMemoryUsagePercent() float64 <span class="cov0" title="0">{
        if ms.maxMemoryUsage == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float64(ms.memoryUsage) / float64(ms.maxMemoryUsage) * PercentageMultiplier</span>
}

// getCleanupFrequency возвращает частоту очистки.
func (ms *MetricsService) getCleanupFrequency() string <span class="cov0" title="0">{
        if ms.cleanupCount == 0 </span><span class="cov0" title="0">{
                return "No cleanups yet"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%d cleanups", ms.cleanupCount)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "strings"
        "time"

        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"

        "github.com/redis/go-redis/v9"
)

// Redis connection constants (using centralized constants for consistency)
var (
        DefaultDialTimeout     = localization.RedisDialTimeoutSeconds * time.Second
        DefaultReadTimeout     = localization.RedisReadTimeoutSeconds * time.Second
        DefaultWriteTimeout    = localization.RedisWriteTimeoutSeconds * time.Second
        DefaultMinRetryBackoff = localization.RedisMinRetryBackoffMs * time.Millisecond
        DefaultMaxRetryBackoff = localization.RedisMaxRetryBackoffMs * time.Millisecond
)

// Redis configuration constants
const (
        DefaultRedisProtocol   = 3
        DefaultMaxRetries      = 3
        DefaultPoolSize        = 20               // Увеличено для лучшей производительности
        DefaultMinIdleConns    = 5                // Минимум idle соединений
        DefaultMaxIdleConns    = 10               // Максимум idle соединений
        DefaultPoolTimeout     = 5 * time.Second  // Таймаут для получения соединения
        DefaultConnMaxLifetime = 30 * time.Minute // Максимальное время жизни соединения
        DefaultConnMaxIdleTime = 5 * time.Minute  // Максимальное время idle соединения
)

// RedisCacheService реализация кэша на основе Redis.
type RedisCacheService struct {
        client *redis.Client
        config *Config
}

// NewRedisCacheService создает новый Redis кэш-сервис.
func NewRedisCacheService(redisURL, password string, database int, config *Config) (*RedisCacheService, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        <span class="cov8" title="1">client := redis.NewClient(&amp;redis.Options{
                Addr:                         redisURL,
                Password:                     password,
                DB:                           database,
                Network:                      "tcp",
                ClientName:                   "language-exchange-bot",
                Dialer:                       nil,
                OnConnect:                    nil,
                Protocol:                     DefaultRedisProtocol,
                Username:                     "",
                CredentialsProvider:          nil,
                CredentialsProviderContext:   nil,
                StreamingCredentialsProvider: nil,
                MaxRetries:                   DefaultMaxRetries,
                MinRetryBackoff:              DefaultMinRetryBackoff,
                MaxRetryBackoff:              DefaultMaxRetryBackoff,
                DialTimeout:                  DefaultDialTimeout,
                ReadTimeout:                  DefaultReadTimeout,
                WriteTimeout:                 DefaultWriteTimeout,
                ContextTimeoutEnabled:        true,  // Включаем context timeout для лучшего контроля
                ReadBufferSize:               16384, // 16KB буфер для чтения
                WriteBufferSize:              16384, // 16KB буфер для записи
                PoolFIFO:                     true,  // FIFO для более предсказуемого поведения
                PoolSize:                     DefaultPoolSize,
                PoolTimeout:                  DefaultPoolTimeout,
                MinIdleConns:                 DefaultMinIdleConns,
                MaxIdleConns:                 DefaultMaxIdleConns,
                MaxActiveConns:               0,
                ConnMaxIdleTime:              DefaultConnMaxIdleTime,
                ConnMaxLifetime:              DefaultConnMaxLifetime,
                TLSConfig:                    nil,
                Limiter:                      nil,
                DisableIndentity:             false,
                DisableIdentity:              false,
                IdentitySuffix:               "",
                UnstableResp3:                false,
                FailingTimeoutSeconds:        0,
        })

        ctx := context.Background()

        // Проверяем подключение
        _, err := client.Ping(ctx).Result()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Redis cache service initialized: %s (DB: %d)", redisURL, database)

        return &amp;RedisCacheService{
                client: client,
                config: config,
        }, nil</span>
}

// GetLanguages получает языки из Redis кэша.
func (r *RedisCacheService) GetLanguages(ctx context.Context, lang string) ([]*models.Language, bool) <span class="cov8" title="1">{
        key := "languages:" + lang

        val, err := r.client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting languages: %v", err)

                return nil, false
        }</span>

        <span class="cov8" title="1">var languages []*models.Language
        if err := json.Unmarshal([]byte(val), &amp;languages); err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error unmarshaling languages: %v", err)

                return nil, false
        }</span>

        <span class="cov8" title="1">return languages, true</span>
}

// SetLanguages сохраняет языки в Redis кэш.
func (r *RedisCacheService) SetLanguages(ctx context.Context, lang string, languages []*models.Language) <span class="cov8" title="1">{
        key := "languages:" + lang

        data, err := json.Marshal(languages)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error marshaling languages: %v", err)

                return
        }</span>

        <span class="cov8" title="1">err = r.client.Set(ctx, key, data, r.config.LanguagesTTL).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error setting languages: %v", err)
        }</span>
}

// GetInterests получает интересы из Redis кэша.
func (r *RedisCacheService) GetInterests(ctx context.Context, lang string) (map[int]string, bool) <span class="cov8" title="1">{
        key := "interests:" + lang

        val, err := r.client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting interests: %v", err)

                return nil, false
        }</span>

        <span class="cov8" title="1">var interests map[int]string
        if err := json.Unmarshal([]byte(val), &amp;interests); err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error unmarshaling interests: %v", err)

                return nil, false
        }</span>

        <span class="cov8" title="1">return interests, true</span>
}

// SetInterests сохраняет интересы в Redis кэш.
func (r *RedisCacheService) SetInterests(ctx context.Context, lang string, interests map[int]string) <span class="cov8" title="1">{
        key := "interests:" + lang

        data, err := json.Marshal(interests)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error marshaling interests: %v", err)

                return
        }</span>

        <span class="cov8" title="1">err = r.client.Set(ctx, key, data, r.config.InterestsTTL).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error setting interests: %v", err)
        }</span>
}

// GetUser получает пользователя из Redis кэша.
func (r *RedisCacheService) GetUser(ctx context.Context, userID int64) (*models.User, bool) <span class="cov8" title="1">{
        key := fmt.Sprintf("user:%d", userID)

        val, err := r.client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting user: %v", err)

                return nil, false
        }</span>

        <span class="cov8" title="1">var user models.User
        if err := json.Unmarshal([]byte(val), &amp;user); err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error unmarshaling user: %v", err)

                return nil, false
        }</span>

        <span class="cov8" title="1">return &amp;user, true</span>
}

// SetUser сохраняет пользователя в Redis кэш.
func (r *RedisCacheService) SetUser(ctx context.Context, user *models.User) <span class="cov8" title="1">{
        key := fmt.Sprintf("user:%d", user.ID)

        data, err := json.Marshal(user)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error marshaling user: %v", err)

                return
        }</span>

        <span class="cov8" title="1">err = r.client.Set(ctx, key, data, r.config.UsersTTL).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error setting user: %v", err)
        }</span>
}

// GetTranslations получает переводы из Redis кэша.
func (r *RedisCacheService) GetTranslations(ctx context.Context, lang string) (map[string]string, bool) <span class="cov0" title="0">{
        key := "translations:" + lang

        val, err := r.client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting translations: %v", err)

                return nil, false
        }</span>

        <span class="cov0" title="0">var translations map[string]string
        if err := json.Unmarshal([]byte(val), &amp;translations); err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error unmarshaling translations: %v", err)

                return nil, false
        }</span>

        <span class="cov0" title="0">return translations, true</span>
}

// SetTranslations сохраняет переводы в Redis кэш.
func (r *RedisCacheService) SetTranslations(ctx context.Context, lang string, translations map[string]string) <span class="cov0" title="0">{
        key := "translations:" + lang

        data, err := json.Marshal(translations)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error marshaling translations: %v", err)

                return
        }</span>

        <span class="cov0" title="0">err = r.client.Set(ctx, key, data, r.config.TranslationsTTL).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error setting translations: %v", err)
        }</span>
}

// GetStats получает статистику из Redis кэша.
func (r *RedisCacheService) GetStats(ctx context.Context, statsType string) (map[string]interface{}, bool) <span class="cov0" title="0">{
        key := "stats:" + statsType

        val, err := r.client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting stats: %v", err)

                return nil, false
        }</span>

        <span class="cov0" title="0">var stats map[string]interface{}
        if err := json.Unmarshal([]byte(val), &amp;stats); err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error unmarshaling stats: %v", err)

                return nil, false
        }</span>

        <span class="cov0" title="0">return stats, true</span>
}

// SetStats сохраняет статистику в Redis кэш.
func (r *RedisCacheService) SetStats(ctx context.Context, statsType string, data map[string]interface{}) <span class="cov0" title="0">{
        key := "stats:" + statsType

        statsData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error marshaling stats: %v", err)

                return
        }</span>

        <span class="cov0" title="0">err = r.client.Set(ctx, key, statsData, r.config.StatsTTL).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error setting stats: %v", err)
        }</span>
}

// InvalidateUser удаляет пользователя из Redis кэша.
func (r *RedisCacheService) InvalidateUser(ctx context.Context, userID int64) <span class="cov0" title="0">{
        key := fmt.Sprintf("user:%d", userID)

        err := r.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error deleting user: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Redis: Invalidated user %d", userID)
        }</span>
}

// InvalidateLanguages удаляет языки из Redis кэша.
func (r *RedisCacheService) InvalidateLanguages(ctx context.Context) <span class="cov8" title="1">{
        pattern := "languages:*"

        keys, err := r.client.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting language keys: %v", err)

                return
        }</span>

        <span class="cov8" title="1">if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                err = r.client.Del(ctx, keys...).Err()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Redis error deleting languages: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Redis: Invalidated %d language entries", len(keys))
                }</span>
        }
}

// InvalidateInterests удаляет интересы из Redis кэша.
func (r *RedisCacheService) InvalidateInterests(ctx context.Context) <span class="cov8" title="1">{
        pattern := "interests:*"

        keys, err := r.client.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting interest keys: %v", err)

                return
        }</span>

        <span class="cov8" title="1">if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                err = r.client.Del(ctx, keys...).Err()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Redis error deleting interests: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Redis: Invalidated %d interest entries", len(keys))
                }</span>
        }
}

// InvalidateTranslations удаляет переводы из Redis кэша.
func (r *RedisCacheService) InvalidateTranslations(ctx context.Context) <span class="cov0" title="0">{
        pattern := "translations:*"

        keys, err := r.client.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting translation keys: %v", err)

                return
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                err = r.client.Del(ctx, keys...).Err()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Redis error deleting translations: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Redis: Invalidated %d translation entries", len(keys))
                }</span>
        }
}

// ClearAll очищает весь Redis кэш.
func (r *RedisCacheService) ClearAll(ctx context.Context) <span class="cov0" title="0">{
        err := r.client.FlushDB(ctx).Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error clearing all: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Redis: Cleared all data")
        }</span>
}

// GetCacheStats возвращает статистику Redis кэша.
func (r *RedisCacheService) GetCacheStats(ctx context.Context) Stats <span class="cov8" title="1">{
        // Получаем количество ключей
        keys, err := r.client.DBSize(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting key count: %v", err)

                return Stats{
                        Hits:   0,
                        Misses: 0,
                        Size:   0,
                }
        }</span>

        <span class="cov8" title="1">return Stats{
                Hits:   0, // Redis не предоставляет hit/miss статистику по умолчанию
                Misses: 0,
                Size:   int(keys),
        }</span>
}

// Stop останавливает Redis кэш-сервис.
func (r *RedisCacheService) Stop() <span class="cov8" title="1">{
        err := r.client.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error closing connection: %v", err)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Redis: Service stopped")
        }</span>
}

// String возвращает строковое представление статистики Redis кэша.
func (r *RedisCacheService) String() string <span class="cov0" title="0">{
        stats := r.GetCacheStats(context.Background())

        return fmt.Sprintf("Redis Cache Stats: Size=%d", stats.Size)
}</span>

// Set сохраняет произвольные данные в Redis кэш.
func (r *RedisCacheService) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov0" title="0">err = r.client.Set(ctx, key, data, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set value in Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get получает произвольные данные из Redis кэша.
func (r *RedisCacheService) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        val, err := r.client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found: %s", key)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get value from Redis: %w", err)
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal([]byte(val), dest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal value: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete удаляет ключ из Redis кэша.
func (r *RedisCacheService) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := r.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete key from Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ===== НОВЫЕ МЕТОДЫ КЕШИРОВАНИЯ =====

// GetInterestCategories получает категории интересов из Redis кэша.
func (r *RedisCacheService) GetInterestCategories(ctx context.Context, lang string) ([]*models.InterestCategory, bool) <span class="cov0" title="0">{
        key := fmt.Sprintf("interest_categories:%s", lang)

        var categories []*models.InterestCategory
        err := r.Get(ctx, key, &amp;categories)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return categories, true</span>
}

// SetInterestCategories сохраняет категории интересов в Redis кэш.
func (r *RedisCacheService) SetInterestCategories(ctx context.Context, lang string, categories []*models.InterestCategory) <span class="cov0" title="0">{
        key := fmt.Sprintf("interest_categories:%s", lang)
        if err := r.Set(ctx, key, categories, r.config.LanguagesTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to cache interest categories for language %s: %v", lang, err)
        }</span>
}

// GetUserStats получает статистику пользователя из Redis кэша.
func (r *RedisCacheService) GetUserStats(ctx context.Context, userID int64) (map[string]interface{}, bool) <span class="cov0" title="0">{
        key := fmt.Sprintf("user_stats:%d", userID)

        var stats map[string]interface{}
        err := r.Get(ctx, key, &amp;stats)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return stats, true</span>
}

// SetUserStats сохраняет статистику пользователя в Redis кэш.
func (r *RedisCacheService) SetUserStats(ctx context.Context, userID int64, stats map[string]interface{}) <span class="cov0" title="0">{
        key := fmt.Sprintf("user_stats:%d", userID)
        if err := r.Set(ctx, key, stats, r.config.UsersTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to cache user stats for user %d: %v", userID, err)
        }</span>
}

// GetConfig получает конфигурацию из Redis кэша.
func (r *RedisCacheService) GetConfig(ctx context.Context, configKey string) (interface{}, bool) <span class="cov0" title="0">{
        key := fmt.Sprintf("config:%s", configKey)

        var value interface{}
        err := r.Get(ctx, key, &amp;value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return value, true</span>
}

// SetConfig сохраняет конфигурацию в Redis кэш.
func (r *RedisCacheService) SetConfig(ctx context.Context, configKey string, value interface{}) <span class="cov0" title="0">{
        key := fmt.Sprintf("config:%s", configKey)
        if err := r.Set(ctx, key, value, r.config.LanguagesTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to cache config for key %s: %v", configKey, err)
        }</span>
}

// InvalidateInterestCategories инвалидирует кэш категорий интересов.
func (r *RedisCacheService) InvalidateInterestCategories(ctx context.Context) <span class="cov0" title="0">{
        pattern := "interest_categories:*"
        keys, err := r.client.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                r.client.Del(ctx, keys...)
        }</span>
}

// InvalidateUserStats инвалидирует кэш статистики пользователя.
func (r *RedisCacheService) InvalidateUserStats(ctx context.Context, userID int64) <span class="cov0" title="0">{
        key := fmt.Sprintf("user_stats:%d", userID)
        r.client.Del(ctx, key)
}</span>

// ===== ОПТИМИЗИРОВАННЫЕ МЕТОДЫ =====

// BatchSet выполняет множественные операции SET через pipeline для лучшей производительности.
func (r *RedisCacheService) BatchSet(ctx context.Context, items map[string]interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">pipe := r.client.Pipeline()

        for key, value := range items </span><span class="cov0" title="0">{
                data, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Redis error marshaling value for key %s: %v", key, err)
                        continue</span>
                }
                <span class="cov0" title="0">pipe.Set(ctx, key, data, ttl)</span>
        }

        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch set: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BatchGet выполняет множественные операции GET через pipeline.
func (r *RedisCacheService) BatchGet(ctx context.Context, keys []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        <span class="cov0" title="0">pipe := r.client.Pipeline()
        cmds := make([]*redis.StringCmd, len(keys))

        for i, key := range keys </span><span class="cov0" title="0">{
                cmds[i] = pipe.Get(ctx, key)
        }</span>

        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        if err != nil &amp;&amp; !errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute batch get: %w", err)
        }</span>

        <span class="cov0" title="0">result := make(map[string]interface{})
        for i, cmd := range cmds </span><span class="cov0" title="0">{
                val, err := cmd.Result()
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                                continue</span> // Ключ не найден, пропускаем
                        }
                        <span class="cov0" title="0">log.Printf("Redis error getting key %s: %v", keys[i], err)
                        continue</span>
                }

                <span class="cov0" title="0">var data interface{}
                if err := json.Unmarshal([]byte(val), &amp;data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Redis error unmarshaling key %s: %v", keys[i], err)
                        continue</span>
                }

                <span class="cov0" title="0">result[keys[i]] = data</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// BatchDelete выполняет множественные операции DEL через pipeline.
func (r *RedisCacheService) BatchDelete(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">pipe := r.client.Pipeline()

        for _, key := range keys </span><span class="cov0" title="0">{
                pipe.Del(ctx, key)
        }</span>

        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch delete: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BatchSetUsers сохраняет множественных пользователей через pipeline.
func (r *RedisCacheService) BatchSetUsers(ctx context.Context, users []*models.User) error <span class="cov0" title="0">{
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">items := make(map[string]interface{})
        for _, user := range users </span><span class="cov0" title="0">{
                key := fmt.Sprintf("user:%d", user.ID)
                items[key] = user
        }</span>

        <span class="cov0" title="0">return r.BatchSet(ctx, items, r.config.UsersTTL)</span>
}

// BatchGetUsers получает множественных пользователей через pipeline.
func (r *RedisCacheService) BatchGetUsers(ctx context.Context, userIDs []int64) ([]*models.User, error) <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">keys := make([]string, len(userIDs))
        for i, userID := range userIDs </span><span class="cov0" title="0">{
                keys[i] = fmt.Sprintf("user:%d", userID)
        }</span>

        <span class="cov0" title="0">data, err := r.BatchGet(ctx, keys)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">users := make([]*models.User, 0, len(data))
        for _, value := range data </span><span class="cov0" title="0">{
                if userData, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Конвертируем map в User struct
                        user := &amp;models.User{}
                        if id, ok := userData["id"].(float64); ok </span><span class="cov0" title="0">{
                                user.ID = int(id)
                        }</span>
                        <span class="cov0" title="0">if telegramID, ok := userData["telegram_id"].(float64); ok </span><span class="cov0" title="0">{
                                user.TelegramID = int64(telegramID)
                        }</span>
                        <span class="cov0" title="0">if username, ok := userData["username"].(string); ok </span><span class="cov0" title="0">{
                                user.Username = username
                        }</span>
                        <span class="cov0" title="0">if firstName, ok := userData["first_name"].(string); ok </span><span class="cov0" title="0">{
                                user.FirstName = firstName
                        }</span>
                        <span class="cov0" title="0">if nativeLang, ok := userData["native_language_code"].(string); ok </span><span class="cov0" title="0">{
                                user.NativeLanguageCode = nativeLang
                        }</span>
                        <span class="cov0" title="0">if targetLang, ok := userData["target_language_code"].(string); ok </span><span class="cov0" title="0">{
                                user.TargetLanguageCode = targetLang
                        }</span>
                        <span class="cov0" title="0">if targetLevel, ok := userData["target_language_level"].(string); ok </span><span class="cov0" title="0">{
                                user.TargetLanguageLevel = targetLevel
                        }</span>
                        <span class="cov0" title="0">if interfaceLang, ok := userData["interface_language_code"].(string); ok </span><span class="cov0" title="0">{
                                user.InterfaceLanguageCode = interfaceLang
                        }</span>
                        <span class="cov0" title="0">if state, ok := userData["state"].(string); ok </span><span class="cov0" title="0">{
                                user.State = state
                        }</span>
                        <span class="cov0" title="0">if status, ok := userData["status"].(string); ok </span><span class="cov0" title="0">{
                                user.Status = status
                        }</span>
                        <span class="cov0" title="0">if profileLevel, ok := userData["profile_completion_level"].(float64); ok </span><span class="cov0" title="0">{
                                user.ProfileCompletionLevel = int(profileLevel)
                        }</span>
                        <span class="cov0" title="0">if createdAt, ok := userData["created_at"].(string); ok </span><span class="cov0" title="0">{
                                if parsed, err := time.Parse(time.RFC3339, createdAt); err == nil </span><span class="cov0" title="0">{
                                        user.CreatedAt = parsed
                                }</span>
                        }
                        <span class="cov0" title="0">if updatedAt, ok := userData["updated_at"].(string); ok </span><span class="cov0" title="0">{
                                if parsed, err := time.Parse(time.RFC3339, updatedAt); err == nil </span><span class="cov0" title="0">{
                                        user.UpdatedAt = parsed
                                }</span>
                        }

                        <span class="cov0" title="0">users = append(users, user)</span>
                }
        }

        <span class="cov0" title="0">return users, nil</span>
}

// WarmUpBatch предзагружает критичные данные в Redis через batch операции.
func (r *RedisCacheService) WarmUpBatch(ctx context.Context, dataLoader DataLoader) error <span class="cov0" title="0">{
        log.Println("Starting Redis cache warming...")
        start := time.Now()

        // Загружаем языки для всех поддерживаемых языков
        languages, err := dataLoader.LoadLanguages(ctx, "en")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load languages: %w", err)
        }</span>

        // Сохраняем языки через batch операцию
        <span class="cov0" title="0">items := make(map[string]interface{})
        items["languages:en"] = languages
        if err := r.BatchSet(ctx, items, r.config.LanguagesTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to warm up languages: %v", err)
        }</span>

        // Загружаем интересы
        <span class="cov0" title="0">interests, err := dataLoader.LoadInterests(ctx, "en")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load interests: %w", err)
        }</span>

        // Сохраняем интересы через batch операцию
        <span class="cov0" title="0">items = make(map[string]interface{})
        items["interests:en"] = interests
        if err := r.BatchSet(ctx, items, r.config.InterestsTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to warm up interests: %v", err)
        }</span>

        // Загружаем категории интересов
        <span class="cov0" title="0">categories, err := dataLoader.LoadInterestCategories(ctx, "en")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load interest categories: %w", err)
        }</span>

        // Сохраняем категории через batch операцию
        <span class="cov0" title="0">items = make(map[string]interface{})
        items["interest_categories:en"] = categories
        if err := r.BatchSet(ctx, items, r.config.InterestCategoriesTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to warm up interest categories: %v", err)
        }</span>

        // Загружаем переводы
        <span class="cov0" title="0">translations, err := dataLoader.LoadTranslations(ctx, "en")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load translations: %w", err)
        }</span>

        // Сохраняем переводы через batch операцию
        <span class="cov0" title="0">items = make(map[string]interface{})
        items["translations:en"] = translations
        if err := r.BatchSet(ctx, items, r.config.TranslationsTTL); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to warm up translations: %v", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        log.Printf("Redis cache warming completed in %v", duration)
        return nil</span>
}

// GetConnectionStats возвращает статистику соединений Redis.
func (r *RedisCacheService) GetConnectionStats(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        info, err := r.client.Info(ctx, "stats").Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis error getting connection stats: %v", err)
                return map[string]interface{}{
                        "error": "failed to get connection stats",
                }
        }</span>

        // Парсим информацию о соединениях
        <span class="cov0" title="0">stats := make(map[string]interface{})
        lines := strings.Split(info, "\r\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, ":") &amp;&amp; !strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, ":", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                stats[key] = value
                        }</span>
                }
        }

        <span class="cov0" title="0">return stats</span>
}

// HealthCheck проверяет здоровье Redis соединения.
func (r *RedisCacheService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        _, err := r.client.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package cache

import (
        "time"

        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"
)

// Entry представляет запись в кэше с TTL.
type Entry struct {
        Data      interface{}
        ExpiresAt time.Time
}

// IsExpired проверяет, истек ли срок действия записи.
func (e *Entry) IsExpired() bool <span class="cov8" title="1">{
        return time.Now().After(e.ExpiresAt)
}</span>

// Config конфигурация кэша.
type Config struct {
        LanguagesTTL          time.Duration // TTL для языков
        InterestsTTL          time.Duration // TTL для интересов
        InterestCategoriesTTL time.Duration // TTL для категорий интересов
        TranslationsTTL       time.Duration // TTL для переводов
        UsersTTL              time.Duration // TTL для пользователей
        UserStatsTTL          time.Duration // TTL для статистики пользователей
        StatsTTL              time.Duration // TTL для статистики
        ConfigTTL             time.Duration // TTL для конфигурации
}

// DefaultConfig возвращает конфигурацию по умолчанию.
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                LanguagesTTL:          time.Hour,                                         // 1 час - языки редко изменяются
                InterestsTTL:          time.Hour,                                         // 1 час - интересы редко изменяются
                InterestCategoriesTTL: time.Hour,                                         // 1 час - категории интересов статичны
                TranslationsTTL:       localization.TranslationsTTLMinutes * time.Minute, // 30 минут - переводы статичны
                UsersTTL:              localization.UsersTTLMinutes * time.Minute,        // 15 минут - пользователи могут изменяться
                UserStatsTTL:          time.Hour,                                         // 1 час - статистика пользователей
                StatsTTL:              localization.StatsTTLMinutes * time.Minute,        // 5 минут - статистика часто обновляется
                ConfigTTL:             time.Hour * 24,                                    // 24 часа - конфигурация редко изменяется
        }
}</span>

// Stats статистика работы кэша.
type Stats struct {
        Hits        int64   // Количество попаданий в кэш
        Misses      int64   // Количество промахов кэша
        Size        int     // Текущий размер кэша
        HitRatio    float64 // Процент попаданий (0.0-1.0)
        Evictions   int64   // Количество вытеснений
        MemoryUsage int64   // Использование памяти в байтах
}

// CachedLanguages кэшированные языки.
type CachedLanguages struct {
        Languages []*models.Language
        Lang      string // Язык интерфейса для локализации
}

// CachedInterests кэшированные интересы.
type CachedInterests struct {
        Interests map[int]string
        Lang      string // Язык интерфейса для локализации
}

// CachedUser кэшированный пользователь.
type CachedUser struct {
        User *models.User
        Lang string // Язык интерфейса пользователя
}

// CachedStats кэшированная статистика.
type CachedStats struct {
        Data map[string]interface{}
        Type string // Тип статистики (feedbacks, users, etc.)
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package circuit_breaker implements circuit breaker pattern for fault tolerance.
package circuit_breaker

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "language-exchange-bot/internal/localization"
)

// State представляет состояние Circuit Breaker.
type State int

const (
        // StateClosed - закрытое состояние, запросы проходят нормально.
        StateClosed State = iota
        // StateOpen - открытое состояние, запросы блокируются.
        StateOpen
        // StateHalfOpen - полуоткрытое состояние, ограниченное количество запросов.
        StateHalfOpen
)

// Circuit Breaker константы теперь в localization/constants.go

// String возвращает строковое представление состояния.
func (s State) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StateClosed:<span class="cov8" title="1">
                return "CLOSED"</span>
        case StateOpen:<span class="cov8" title="1">
                return "OPEN"</span>
        case StateHalfOpen:<span class="cov0" title="0">
                return "HALF_OPEN"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// Config содержит конфигурацию Circuit Breaker.
type Config struct {
        // Name - имя Circuit Breaker для логирования.
        Name string
        // MaxRequests - максимальное количество запросов в полуоткрытом состоянии.
        MaxRequests uint32
        // Interval - интервал для сброса счетчика ошибок.
        Interval time.Duration
        // Timeout - время ожидания в открытом состоянии перед переходом в полуоткрытое.
        Timeout time.Duration
        // ReadyToTrip - функция для определения готовности к переходу в открытое состояние.
        ReadyToTrip func(counts Counts) bool
        // OnStateChange - callback при изменении состояния.
        OnStateChange func(name string, from State, to State)
}

// Counts содержит счетчики для Circuit Breaker.
type Counts struct {
        Requests             uint32
        TotalSuccesses       uint32
        TotalFailures        uint32
        ConsecutiveSuccesses uint32
        ConsecutiveFailures  uint32
}

// CircuitBreaker реализует паттерн Circuit Breaker.
type CircuitBreaker struct {
        name          string
        maxRequests   uint32
        interval      time.Duration
        timeout       time.Duration
        readyToTrip   func(counts Counts) bool
        onStateChange func(name string, from State, to State)

        mutex      sync.Mutex
        state      State
        generation uint32
        counts     Counts
        expiry     time.Time
}

// NewCircuitBreaker создает новый Circuit Breaker.
func NewCircuitBreaker(config Config) *CircuitBreaker <span class="cov8" title="1">{
        cb := &amp;CircuitBreaker{
                name:          config.Name,
                maxRequests:   config.MaxRequests,
                interval:      config.Interval,
                timeout:       config.Timeout,
                readyToTrip:   config.ReadyToTrip,
                onStateChange: config.OnStateChange,
                state:         StateClosed,
                generation:    0,
                counts:        Counts{},
                expiry:        time.Time{},
        }

        // Устанавливаем значения по умолчанию
        if cb.maxRequests == 0 </span><span class="cov8" title="1">{
                cb.maxRequests = 1
        }</span>

        <span class="cov8" title="1">if cb.interval == 0 </span><span class="cov8" title="1">{
                cb.interval = localization.DefaultIntervalSeconds * time.Second
        }</span>

        <span class="cov8" title="1">if cb.timeout == 0 </span><span class="cov8" title="1">{
                cb.timeout = localization.DefaultTimeoutSeconds * time.Second
        }</span>

        <span class="cov8" title="1">if cb.readyToTrip == nil </span><span class="cov8" title="1">{
                cb.readyToTrip = func(counts Counts) bool </span><span class="cov8" title="1">{
                        return counts.ConsecutiveFailures &gt; localization.DefaultConsecutiveFailures
                }</span>
        }

        <span class="cov8" title="1">return cb</span>
}

// Execute выполняет функцию с защитой Circuit Breaker.
func (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        generation, err := cb.beforeRequest()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Переменные для результата
        <span class="cov8" title="1">var result interface{}
        var execErr error
        panicOccurred := false

        // Функция для выполнения с перехватом паники
        func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if e := recover(); e != nil </span><span class="cov8" title="1">{
                                panicOccurred = true
                                // Любая паника считается recovered
                                execErr = fmt.Errorf("panic recovered: %v", e)
                                result = nil
                        }</span>
                }()

                <span class="cov8" title="1">result, execErr = req()</span>
        }()

        // Обновляем счетчики на основе результата
        <span class="cov8" title="1">if panicOccurred || execErr != nil </span><span class="cov8" title="1">{
                cb.afterRequest(generation, false)
        }</span> else<span class="cov8" title="1"> {
                cb.afterRequest(generation, true)
        }</span>

        <span class="cov8" title="1">return result, execErr</span>
}

// ExecuteWithContext выполняет функцию с контекстом и защитой Circuit Breaker.
func (cb *CircuitBreaker) ExecuteWithContext(
        ctx context.Context,
        req func() (interface{}, error),
) (result interface{}, err error) <span class="cov8" title="1">{
        generation, err := cb.beforeRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Проверяем контекст
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                cb.afterRequest(generation, false)
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Переменные для результата
        <span class="cov0" title="0">var execErr error
        panicOccurred := false

        // Функция для выполнения с перехватом паники
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if e := recover(); e != nil </span><span class="cov0" title="0">{
                                panicOccurred = true
                                // Любая паника считается recovered
                                execErr = fmt.Errorf("panic recovered: %v", e)
                                result = nil
                        }</span>
                }()

                <span class="cov0" title="0">result, execErr = req()</span>
        }()

        // Обновляем счетчики на основе результата
        <span class="cov0" title="0">if panicOccurred || execErr != nil </span><span class="cov0" title="0">{
                cb.afterRequest(generation, false)
        }</span> else<span class="cov0" title="0"> {
                cb.afterRequest(generation, true)
        }</span>

        <span class="cov0" title="0">return result, execErr</span>
}

// State возвращает текущее состояние Circuit Breaker.
func (cb *CircuitBreaker) State() State <span class="cov8" title="1">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        state, _ := cb.currentState(now)

        return state
}</span>

// Counts возвращает текущие счетчики.
func (cb *CircuitBreaker) Counts() Counts <span class="cov8" title="1">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        _, _ = cb.currentState(now)

        return cb.counts
}</span>

// beforeRequest проверяет возможность выполнения запроса.
func (cb *CircuitBreaker) beforeRequest() (uint32, error) <span class="cov8" title="1">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        state, generation := cb.currentState(now)

        if state == StateOpen </span><span class="cov8" title="1">{
                return generation, errors.New("circuit breaker is OPEN")
        }</span> else<span class="cov8" title="1"> if state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests </span><span class="cov0" title="0">{
                return generation, errors.New("circuit breaker is HALF_OPEN and max requests reached")
        }</span>

        <span class="cov8" title="1">cb.counts.Requests++

        return generation, nil</span>
}

// afterRequest обновляет счетчики после выполнения запроса.
func (cb *CircuitBreaker) afterRequest(before uint32, success bool) <span class="cov8" title="1">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        _, generation := cb.currentState(now)

        if generation != before </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if success </span><span class="cov8" title="1">{
                cb.onSuccess(now)
        }</span> else<span class="cov8" title="1"> {
                cb.onFailure(now)
        }</span>
}

// currentState возвращает текущее состояние и поколение.
func (cb *CircuitBreaker) currentState(now time.Time) (State, uint32) <span class="cov8" title="1">{
        if cb.expiry.Before(now) &amp;&amp; !cb.expiry.IsZero() </span><span class="cov8" title="1">{
                cb.toNewGeneration(now)

                // Переход из Open в HalfOpen при истечении timeout
                if cb.state == StateOpen </span><span class="cov8" title="1">{
                        cb.state = StateHalfOpen
                }</span>
        }

        <span class="cov8" title="1">return cb.state, cb.generation</span>
}

// toNewGeneration сбрасывает счетчики и обновляет поколение.
func (cb *CircuitBreaker) toNewGeneration(now time.Time) <span class="cov8" title="1">{
        cb.generation++
        cb.counts = Counts{}

        var zero time.Time

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                if cb.interval == 0 </span><span class="cov0" title="0">{
                        cb.expiry = zero
                }</span> else<span class="cov8" title="1"> {
                        cb.expiry = now.Add(cb.interval)
                }</span>
        case StateOpen:<span class="cov8" title="1">
                cb.expiry = now.Add(cb.timeout)</span>
        case StateHalfOpen:<span class="cov0" title="0">
                cb.expiry = zero</span>
        }
}

// onSuccess обрабатывает успешный запрос.
func (cb *CircuitBreaker) onSuccess(now time.Time) <span class="cov8" title="1">{
        cb.counts.TotalSuccesses++
        cb.counts.ConsecutiveSuccesses++
        cb.counts.ConsecutiveFailures = 0

        if cb.state == StateHalfOpen &amp;&amp; cb.counts.ConsecutiveSuccesses &gt;= cb.maxRequests </span><span class="cov8" title="1">{
                cb.setState(StateClosed, now)
        }</span>
}

// onFailure обрабатывает неудачный запрос.
func (cb *CircuitBreaker) onFailure(now time.Time) <span class="cov8" title="1">{
        cb.counts.TotalFailures++
        cb.counts.ConsecutiveFailures++
        cb.counts.ConsecutiveSuccesses = 0

        if cb.readyToTrip(cb.counts) </span><span class="cov8" title="1">{
                cb.setState(StateOpen, now)
        }</span>
}

// setState изменяет состояние Circuit Breaker.
func (cb *CircuitBreaker) setState(state State, now time.Time) <span class="cov8" title="1">{
        if cb.state == state </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">prev := cb.state
        cb.state = state

        cb.toNewGeneration(now)

        if cb.onStateChange != nil </span><span class="cov8" title="1">{
                cb.onStateChange(cb.name, prev, state)
        }</span>
}

// DefaultConfig возвращает конфигурацию по умолчанию.
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                Name:        "default",
                MaxRequests: localization.DefaultMaxRequests,
                Interval:    localization.DefaultIntervalSeconds * time.Second,
                Timeout:     localization.DefaultTimeoutSeconds * time.Second,
                ReadyToTrip: func(counts Counts) bool </span><span class="cov0" title="0">{
                        return counts.ConsecutiveFailures &gt; localization.DefaultConsecutiveFailures
                }</span>,
        }
}

// TelegramConfig возвращает конфигурацию для Telegram API.
func TelegramConfig() Config <span class="cov8" title="1">{
        return Config{
                Name:        "telegram",
                MaxRequests: localization.TelegramMaxRequests,
                Interval:    localization.TelegramIntervalSeconds * time.Second,
                Timeout:     localization.TelegramTimeoutSeconds * time.Second,
                ReadyToTrip: func(counts Counts) bool </span><span class="cov0" title="0">{
                        return counts.ConsecutiveFailures &gt; localization.TelegramFailureThreshold
                }</span>,
        }
}

// DatabaseConfig возвращает конфигурацию для базы данных.
func DatabaseConfig() Config <span class="cov8" title="1">{
        return Config{
                Name:        "database",
                MaxRequests: localization.DatabaseMaxRequests,
                Interval:    localization.DatabaseIntervalSeconds * time.Second,
                Timeout:     localization.DatabaseTimeoutSeconds * time.Second,
                ReadyToTrip: func(counts Counts) bool </span><span class="cov0" title="0">{
                        return counts.ConsecutiveFailures &gt; localization.DatabaseFailureThreshold
                }</span>,
        }
}

// RedisConfig возвращает конфигурацию для Redis.
func RedisConfig() Config <span class="cov8" title="1">{
        return Config{
                Name:        "redis",
                MaxRequests: localization.MatcherMaxRequests,
                Interval:    localization.MatcherIntervalSeconds * time.Second,
                Timeout:     localization.MatcherTimeoutSeconds * time.Second,
                ReadyToTrip: func(counts Counts) bool </span><span class="cov0" title="0">{
                        return counts.ConsecutiveFailures &gt; localization.MatcherFailureThreshold
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package config provides configuration management for the application.
package config

import (
        "log"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/joho/godotenv"
)

// Config represents the application configuration.
type Config struct {
        // Telegram Bot
        TelegramToken string
        // Database
        DatabaseURL          string
        DatabaseMaxOpenConns int // Максимум открытых соединений
        DatabaseMaxIdleConns int // Максимум idle соединений
        // Redis
        RedisURL      string
        RedisPassword string
        RedisDB       int
        // Server
        Port       string
        Debug      bool
        WebhookURL string
        // Bot Platform Settings
        EnableTelegram bool
        EnableDiscord  bool // Для будущего расширения
        // Telegram Bot Mode: "polling" or "webhook"
        TelegramMode string
        // Admin IDs for notifications
        AdminChatIDs   []int64  // IDs чатов администраторов для уведомлений
        AdminUsernames []string // Username'ы администраторов (читаются только из .env)
        // Matching Configuration
        PrimaryInterestScore    int // Баллы за совпадение основных интересов
        AdditionalInterestScore int // Баллы за совпадение дополнительных интересов
        MinCompatibilityScore   int // Минимальный балл совместимости
        MaxMatchesPerUser       int // Максимальное количество совпадений на пользователя
        // Interest Limits
        MinPrimaryInterests int     // Минимум основных интересов
        MaxPrimaryInterests int     // Максимум основных интересов
        PrimaryPercentage   float64 // Процент основных интересов от общего количества
}

// Load loads configuration from environment variables and .env file.
func Load() *Config <span class="cov8" title="1">{
        loadEnvFile()

        getFromFile := createFileReader()

        config := &amp;Config{
                TelegramToken:           getTelegramToken(getFromFile),
                DatabaseURL:             getDatabaseURL(getFromFile),
                DatabaseMaxOpenConns:    getDatabaseMaxOpenConns(),
                DatabaseMaxIdleConns:    getDatabaseMaxIdleConns(),
                RedisURL:                getEnv("REDIS_URL", "localhost:6379"),
                RedisPassword:           getEnv("REDIS_PASSWORD", ""),
                RedisDB:                 getRedisDB(),
                Port:                    getEnv("PORT", "8080"),
                Debug:                   getDebug(),
                WebhookURL:              getEnv("WEBHOOK_URL", ""),
                EnableTelegram:          getEnableTelegram(),
                EnableDiscord:           getEnableDiscord(),
                TelegramMode:            getTelegramMode(),
                AdminChatIDs:            parseAdminChatIDs(),
                AdminUsernames:          parseAdminUsernames(),
                PrimaryInterestScore:    getPrimaryInterestScore(),
                AdditionalInterestScore: getAdditionalInterestScore(),
                MinCompatibilityScore:   getMinCompatibilityScore(),
                MaxMatchesPerUser:       getMaxMatchesPerUser(),
                MinPrimaryInterests:     getMinPrimaryInterests(),
                MaxPrimaryInterests:     getMaxPrimaryInterests(),
                PrimaryPercentage:       getPrimaryPercentage(),
        }

        return config
}</span>

// getTelegramToken получает токен Telegram из переменных окружения или файла.
func getTelegramToken(getFromFile func(string) string) string <span class="cov8" title="1">{
        telegramToken := os.Getenv("TELEGRAM_TOKEN")
        if telegramToken == "" </span><span class="cov8" title="1">{
                telegramToken = getFromFile(os.Getenv("TELEGRAM_TOKEN_FILE"))
        }</span>

        <span class="cov8" title="1">return telegramToken</span>
}

// getDatabaseURL получает URL базы данных из переменных окружения или файла.
func getDatabaseURL(getFromFile func(string) string) string <span class="cov8" title="1">{
        databaseURL := os.Getenv("DATABASE_URL")
        if databaseURL == "" </span><span class="cov8" title="1">{
                databaseURL = getFromFile(os.Getenv("DATABASE_URL_FILE"))
        }</span>

        <span class="cov8" title="1">return databaseURL</span>
}

// getRedisDB получает номер базы данных Redis.
func getRedisDB() int <span class="cov8" title="1">{
        redisDB, err := strconv.Atoi(getEnv("REDIS_DB", "0"))
        if err != nil </span><span class="cov8" title="1">{
                return 0 // default value
        }</span>

        <span class="cov8" title="1">return redisDB</span>
}

// getDebug получает флаг отладки.
func getDebug() bool <span class="cov8" title="1">{
        debug, err := strconv.ParseBool(getEnv("DEBUG", "false"))
        if err != nil </span><span class="cov8" title="1">{
                return false // default value
        }</span>

        <span class="cov8" title="1">return debug</span>
}

// getEnableTelegram получает флаг включения Telegram.
func getEnableTelegram() bool <span class="cov8" title="1">{
        enableTelegram, err := strconv.ParseBool(getEnv("ENABLE_TELEGRAM", "true"))
        if err != nil </span><span class="cov8" title="1">{
                return true // default value
        }</span>

        <span class="cov8" title="1">return enableTelegram</span>
}

// getEnableDiscord получает флаг включения Discord.
func getEnableDiscord() bool <span class="cov8" title="1">{
        enableDiscord, err := strconv.ParseBool(getEnv("ENABLE_DISCORD", "false"))
        if err != nil </span><span class="cov8" title="1">{
                return false // default value
        }</span>

        <span class="cov8" title="1">return enableDiscord</span>
}

// getTelegramMode получает режим работы Telegram бота.
func getTelegramMode() string <span class="cov8" title="1">{
        mode := getEnv("TELEGRAM_MODE", "polling")
        mode = strings.ToLower(mode)

        // Валидация режима
        if mode != "polling" &amp;&amp; mode != "webhook" </span><span class="cov8" title="1">{
                log.Printf("Warning: invalid TELEGRAM_MODE '%s', using 'polling' as default", mode)
                return "polling"
        }</span>

        <span class="cov8" title="1">return mode</span>
}

// parseAdminChatIDs парсит ID чатов администраторов.
func parseAdminChatIDs() []int64 <span class="cov8" title="1">{
        adminChatIDsStr := getEnv("ADMIN_CHAT_IDS", "")

        var adminChatIDs []int64

        if adminChatIDsStr != "" </span><span class="cov8" title="1">{
                for _, idStr := range strings.Split(adminChatIDsStr, ",") </span><span class="cov8" title="1">{
                        idStr = strings.TrimSpace(idStr)
                        if idStr == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if id, err := strconv.ParseInt(idStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                                adminChatIDs = append(adminChatIDs, id)
                        }</span> else<span class="cov8" title="1"> {
                                log.Printf("Ошибка парсинга admin chat ID '%s': %v", idStr, err)
                        }</span>
                }
        }

        // Возвращаем пустой slice вместо nil
        <span class="cov8" title="1">if adminChatIDs == nil </span><span class="cov8" title="1">{
                adminChatIDs = []int64{}
        }</span>

        <span class="cov8" title="1">return adminChatIDs</span>
}

// parseAdminUsernames парсит имена пользователей администраторов.
func parseAdminUsernames() []string <span class="cov8" title="1">{
        adminUsernamesStr := getEnv("ADMIN_USERNAMES", "")

        var adminUsernames []string

        if adminUsernamesStr != "" </span><span class="cov8" title="1">{
                for _, username := range strings.Split(adminUsernamesStr, ",") </span><span class="cov8" title="1">{
                        username = strings.TrimSpace(username)
                        if username == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">username = strings.TrimPrefix(username, "@")
                        if username == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">adminUsernames = append(adminUsernames, username)</span>
                }
        }

        // Возвращаем пустой slice вместо nil
        <span class="cov8" title="1">if adminUsernames == nil </span><span class="cov8" title="1">{
                adminUsernames = []string{}
        }</span>

        <span class="cov8" title="1">return adminUsernames</span>
}

// getPrimaryInterestScore получает баллы за основные интересы.
func getPrimaryInterestScore() int <span class="cov8" title="1">{
        score, err := strconv.Atoi(getEnv("PRIMARY_INTEREST_SCORE", "3"))
        if err != nil </span><span class="cov8" title="1">{
                return 3 // default value
        }</span>

        <span class="cov8" title="1">return score</span>
}

// getAdditionalInterestScore получает баллы за дополнительные интересы.
func getAdditionalInterestScore() int <span class="cov8" title="1">{
        score, err := strconv.Atoi(getEnv("ADDITIONAL_INTEREST_SCORE", "1"))
        if err != nil </span><span class="cov0" title="0">{
                return 1 // default value
        }</span>

        <span class="cov8" title="1">return score</span>
}

// getMinCompatibilityScore получает минимальный балл совместимости.
func getMinCompatibilityScore() int <span class="cov8" title="1">{
        score, err := strconv.Atoi(getEnv("MIN_COMPATIBILITY_SCORE", "5"))
        if err != nil </span><span class="cov0" title="0">{
                return 5 // default value
        }</span>

        <span class="cov8" title="1">return score</span>
}

// getMaxMatchesPerUser получает максимальное количество совпадений на пользователя.
func getMaxMatchesPerUser() int <span class="cov8" title="1">{
        matches, err := strconv.Atoi(getEnv("MAX_MATCHES_PER_USER", "10"))
        if err != nil </span><span class="cov0" title="0">{
                return 10 // default value
        }</span>

        <span class="cov8" title="1">return matches</span>
}

// getMinPrimaryInterests получает минимальное количество основных интересов.
func getMinPrimaryInterests() int <span class="cov8" title="1">{
        interests, err := strconv.Atoi(getEnv("MIN_PRIMARY_INTERESTS", "1"))
        if err != nil </span><span class="cov0" title="0">{
                return 1 // default value
        }</span>

        <span class="cov8" title="1">return interests</span>
}

// getMaxPrimaryInterests получает максимальное количество основных интересов.
func getMaxPrimaryInterests() int <span class="cov8" title="1">{
        interests, err := strconv.Atoi(getEnv("MAX_PRIMARY_INTERESTS", "5"))
        if err != nil </span><span class="cov0" title="0">{
                return 5 // default value
        }</span>

        <span class="cov8" title="1">return interests</span>
}

// getPrimaryPercentage получает процент основных интересов.
func getPrimaryPercentage() float64 <span class="cov8" title="1">{
        percentage, err := strconv.ParseFloat(getEnv("PRIMARY_PERCENTAGE", "0.3"), 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0.3 // default value
        }</span>

        <span class="cov8" title="1">return percentage</span>
}

func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>

        <span class="cov8" title="1">return defaultValue</span>
}

// loadEnvFile загружает .env файл из возможных путей.
func loadEnvFile() <span class="cov8" title="1">{
        // Пропускаем загрузку .env файлов в тестах
        if strings.HasSuffix(os.Args[0], ".test") || os.Getenv("GO_TEST") == "1" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">envPaths := []string{
                "../../deploy/.env", // из services/bot/cmd/bot/
                "../deploy/.env",    // из services/bot/
                "deploy/.env",       // из корня проекта
                ".env",              // текущая директория (fallback)
        }

        for _, path := range envPaths </span><span class="cov0" title="0">{
                err := godotenv.Load(path)
                if err == nil </span><span class="cov0" title="0">{
                        log.Printf("Загружен .env файл из: %s", path)

                        break</span>
                }
        }
}

// createFileReader создает функцию для чтения файлов.
func createFileReader() func(string) string <span class="cov8" title="1">{
        return func(path string) string </span><span class="cov8" title="1">{
                if path == "" </span><span class="cov8" title="1">{
                        return ""
                }</span>

                // Очищаем путь для безопасности
                <span class="cov8" title="1">cleanPath := filepath.Clean(path)

                // В тестах разрешаем любые пути, включая временные директории
                if !strings.HasSuffix(os.Args[0], ".test") &amp;&amp; os.Getenv("GO_TEST") != "1" </span><span class="cov0" title="0">{
                        // Проверяем, что путь не содержит опасные символы
                        if strings.Contains(cleanPath, "..") || strings.Contains(cleanPath, "~") </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                }

                <span class="cov8" title="1">if b, err := os.ReadFile(cleanPath); err == nil </span><span class="cov8" title="1">{
                        return strings.TrimSpace(string(b))
                }</span>

                <span class="cov8" title="1">return ""</span>
        }
}

// getDatabaseMaxOpenConns получает максимальное количество открытых соединений.
func getDatabaseMaxOpenConns() int <span class="cov8" title="1">{
        value := getEnv("DATABASE_MAX_OPEN_CONNS", "25")
        if parsed, err := strconv.Atoi(value); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov8" title="1">{
                return parsed
        }</span>
        <span class="cov0" title="0">return 25</span> // значение по умолчанию
}

// getDatabaseMaxIdleConns получает максимальное количество idle соединений.
func getDatabaseMaxIdleConns() int <span class="cov8" title="1">{
        value := getEnv("DATABASE_MAX_IDLE_CONNS", "10")
        if parsed, err := strconv.Atoi(value); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov8" title="1">{
                return parsed
        }</span>
        <span class="cov0" title="0">return 10</span> // значение по умолчанию
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        errorsPkg "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
)

// Interest configuration constants are now centralized in localization/constants.go

// InterestsConfig представляет конфигурацию системы интересов.
type InterestsConfig struct {
        Matching       MatchingConfig            `json:"matching"`
        InterestLimits InterestLimitsConfig      `json:"interestLimits"`
        Categories     map[string]CategoryConfig `json:"categories"`
}

// MatchingConfig конфигурация для алгоритма сопоставления.
type MatchingConfig struct {
        PrimaryInterestScore    int `json:"primaryInterestScore"`
        AdditionalInterestScore int `json:"additionalInterestScore"`
        MinCompatibilityScore   int `json:"minCompatibilityScore"`
        MaxMatchesPerUser       int `json:"maxMatchesPerUser"`
}

// InterestLimitsConfig конфигурация лимитов интересов.
type InterestLimitsConfig struct {
        MinPrimaryInterests int     `json:"minPrimaryInterests"`
        MaxPrimaryInterests int     `json:"maxPrimaryInterests"`
        PrimaryPercentage   float64 `json:"primaryPercentage"`
}

// CategoryConfig конфигурация категории.
type CategoryConfig struct {
        DisplayOrder          int `json:"displayOrder"`
        MaxPrimaryPerCategory int `json:"maxPrimaryPerCategory"`
}

// LoadInterestsConfig загружает конфигурацию интересов из файла.
func LoadInterestsConfig() (*InterestsConfig, error) <span class="cov8" title="1">{
        // Ищем файл конфигурации в разных местах
        configPaths := []string{
                "config/interests.json",          // из корня проекта
                "../config/interests.json",       // из services/bot/
                "../../config/interests.json",    // из services/bot/internal/
                "../../../config/interests.json", // из services/bot/internal/config/
        }

        var configPath string

        for _, path := range configPaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        configPath = path

                        break</span>
                }
        }

        <span class="cov8" title="1">if configPath == "" </span><span class="cov8" title="1">{
                // Если файл не найден, создаем с дефолтными значениями
                config := &amp;InterestsConfig{
                        Matching: MatchingConfig{
                                PrimaryInterestScore:    localization.DefaultPrimaryInterestScore,
                                AdditionalInterestScore: localization.DefaultAdditionalInterestScore,
                                MinCompatibilityScore:   localization.DefaultMinCompatibilityScore,
                                MaxMatchesPerUser:       localization.DefaultMaxMatchesPerUser,
                        },
                        InterestLimits: InterestLimitsConfig{
                                MinPrimaryInterests: localization.DefaultMinPrimaryInterests,
                                MaxPrimaryInterests: localization.DefaultMaxPrimaryInterests,
                                PrimaryPercentage:   localization.DefaultPrimaryPercentage, // 30% от общего количества интересов
                        },
                        Categories: map[string]CategoryConfig{
                                "entertainment": {DisplayOrder: localization.EntertainmentDisplayOrder, MaxPrimaryPerCategory: localization.DefaultMaxPrimaryPerCategory},
                                "education":     {DisplayOrder: localization.EducationDisplayOrder, MaxPrimaryPerCategory: localization.DefaultMaxPrimaryPerCategory},
                                "active":        {DisplayOrder: localization.ActiveDisplayOrder, MaxPrimaryPerCategory: localization.DefaultMaxPrimaryPerCategory},
                                "creative":      {DisplayOrder: localization.CreativeDisplayOrder, MaxPrimaryPerCategory: localization.DefaultMaxPrimaryPerCategory},
                                "social":        {DisplayOrder: localization.SocialDisplayOrder, MaxPrimaryPerCategory: localization.DefaultMaxPrimaryPerCategory},
                        },
                }

                return config, nil
        }</span>

        // Очищаем путь для безопасности
        <span class="cov8" title="1">cleanPath := filepath.Clean(configPath)

        // Проверяем, что путь не содержит опасные символы
        if strings.Contains(cleanPath, "..") || strings.Contains(cleanPath, "~") </span><span class="cov0" title="0">{
                return nil, errorsPkg.ErrUnsafeFilePath
        }</span>

        // Читаем файл
        <span class="cov8" title="1">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Парсим JSON
        <span class="cov8" title="1">var config InterestsConfig
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// GetInterestsConfig возвращает загруженную конфигурацию.
func GetInterestsConfig() *InterestsConfig <span class="cov8" title="1">{
        config, _ := LoadInterestsConfig()

        return config
}</span>

// SaveInterestsConfig сохраняет конфигурацию в файл.
func SaveInterestsConfig(config *InterestsConfig) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("config cannot be nil")
        }</span>

        // Определяем путь для сохранения
        <span class="cov8" title="1">configPath := "config/interests.json"

        // Создаем директорию если не существует
        if err := os.MkdirAll(filepath.Dir(configPath), localization.DefaultDirectoryPermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Сериализуем в JSON
        <span class="cov8" title="1">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Записываем в файл
        <span class="cov8" title="1">if err := os.WriteFile(configPath, data, localization.DefaultFilePermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package core

import (
        "context"
        "database/sql"
        "fmt"

        "language-exchange-bot/internal/config"
        errorsPkg "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"
        "language-exchange-bot/internal/models"
)

// Константы для SQL запросов.
const (
        // countPrimaryInterestsQuery - запрос для подсчета основных интересов пользователя.
        countPrimaryInterestsQuery = `SELECT COUNT(*) FROM user_interest_selections WHERE user_id = $1 AND is_primary = true`

        // primaryInterestMultiplier - множитель для максимального балла основных интересов.
        primaryInterestMultiplier = 2
)

// InterestService handles user interest management and matching.
type InterestService struct {
        db           *sql.DB
        logger       *logging.DatabaseLogger
        errorHandler *errorsPkg.ErrorHandler
}

// NewInterestService creates a new InterestService instance.
func NewInterestService(db *sql.DB) *InterestService <span class="cov0" title="0">{
        return &amp;InterestService{
                db:           db,
                logger:       logging.NewDatabaseLogger(),
                errorHandler: errorsPkg.NewErrorHandler(nil),
        }
}</span>

// GetInterestCategories возвращает все категории интересов.
func (s *InterestService) GetInterestCategories() ([]models.InterestCategory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, key_name, display_order, created_at 
                FROM interest_categories 
                ORDER BY display_order ASC
        `

        rows, err := s.db.QueryContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query interests: %w", err)
        }</span>

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "GetInterestCategories",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">var categories []models.InterestCategory

        for rows.Next() </span><span class="cov0" title="0">{
                var category models.InterestCategory

                err := rows.Scan(&amp;category.ID, &amp;category.KeyName, &amp;category.DisplayOrder, &amp;category.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan interest category: %w", err)
                }</span>

                <span class="cov0" title="0">categories = append(categories, category)</span>
        }

        <span class="cov0" title="0">return categories, nil</span>
}

// GetInterestsByCategory возвращает интересы по категории.
func (s *InterestService) GetInterestsByCategory(categoryID int) ([]models.Interest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, key_name, category_id, display_order, type, created_at
                FROM interests 
                WHERE category_id = $1 
                ORDER BY display_order ASC, key_name ASC
        `

        rows, err := s.db.QueryContext(context.Background(), query, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query interests by category: %w", err)
        }</span>

        <span class="cov0" title="0">return s.scanInterests(rows)</span>
}

// GetUserInterestSelections возвращает выборы пользователя.
func (s *InterestService) GetUserInterestSelections(userID int) ([]models.InterestSelection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, interest_id, is_primary, selection_order, created_at
                FROM user_interest_selections 
                WHERE user_id = $1 
                ORDER BY is_primary DESC, selection_order ASC
        `

        rows, err := s.db.QueryContext(context.Background(), query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query user interests: %w", err)
        }</span>

        <span class="cov0" title="0">return s.scanInterestSelections(rows)</span>
}

// AddUserInterestSelection добавляет выбор пользователя.
func (s *InterestService) AddUserInterestSelection(userID, interestID int, isPrimary bool) error <span class="cov0" title="0">{
        // Проверяем, не выбран ли уже этот интерес
        var exists bool

        checkQuery := `SELECT EXISTS(SELECT 1 FROM user_interest_selections WHERE user_id = $1 AND interest_id = $2)`

        err := s.db.QueryRowContext(context.Background(), checkQuery, userID, interestID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return errorsPkg.ErrInterestAlreadySelected
        }</span>

        // Получаем следующий порядок выбора
        <span class="cov0" title="0">var nextOrder int

        orderQuery := `SELECT COALESCE(MAX(selection_order), 0) + 1 FROM user_interest_selections WHERE user_id = $1`

        err = s.db.QueryRowContext(context.Background(), orderQuery, userID).Scan(&amp;nextOrder)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        // Если это основной интерес, проверяем лимиты
        <span class="cov0" title="0">if isPrimary </span><span class="cov0" title="0">{
                var primaryCount int

                countQuery := countPrimaryInterestsQuery

                err = s.db.QueryRowContext(context.Background(), countQuery, userID).Scan(&amp;primaryCount)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation failed: %w", err)
                }</span>

                // Получаем конфигурацию лимитов
                <span class="cov0" title="0">limits, limitsErr := s.GetInterestLimitsConfig()
                if limitsErr != nil </span><span class="cov0" title="0">{
                        return limitsErr
                }</span>

                <span class="cov0" title="0">if primaryCount &gt;= limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                        return errorsPkg.ErrMaxPrimaryInterestsReached
                }</span>
        }

        // Добавляем выбор
        <span class="cov0" title="0">insertQuery := `
                INSERT INTO user_interest_selections (user_id, interest_id, is_primary, selection_order)
                VALUES ($1, $2, $3, $4)
        `

        _, err = s.db.ExecContext(context.Background(), insertQuery, userID, interestID, isPrimary, nextOrder)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveUserInterestSelection удаляет выбор пользователя.
func (s *InterestService) RemoveUserInterestSelection(userID, interestID int) error <span class="cov0" title="0">{
        query := `DELETE FROM user_interest_selections WHERE user_id = $1 AND interest_id = $2`

        _, err := s.db.ExecContext(context.Background(), query, userID, interestID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetPrimaryInterest устанавливает интерес как основной.
func (s *InterestService) SetPrimaryInterest(userID, interestID int, isPrimary bool) error <span class="cov0" title="0">{
        // Проверяем лимиты основных интересов
        if isPrimary </span><span class="cov0" title="0">{
                var primaryCount int

                countQuery := countPrimaryInterestsQuery

                err := s.db.QueryRowContext(context.Background(), countQuery, userID).Scan(&amp;primaryCount)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation failed: %w", err)
                }</span>

                <span class="cov0" title="0">limits, err := s.GetInterestLimitsConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation failed: %w", err)
                }</span>

                <span class="cov0" title="0">if primaryCount &gt;= limits.MaxPrimaryInterests </span><span class="cov0" title="0">{
                        return errorsPkg.ErrMaxPrimaryInterestsReached
                }</span>
        }

        <span class="cov0" title="0">query := `UPDATE user_interest_selections SET is_primary = $3 WHERE user_id = $1 AND interest_id = $2`

        _, err := s.db.ExecContext(context.Background(), query, userID, interestID, isPrimary)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInterestLimitsConfig возвращает конфигурацию лимитов из файла.
func (s *InterestService) GetInterestLimitsConfig() (*config.InterestLimitsConfig, error) <span class="cov0" title="0">{
        interestsConfig, err := config.LoadInterestsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;interestsConfig.InterestLimits, nil</span>
}

// GetMatchingConfig возвращает конфигурацию для алгоритма сопоставления из файла.
func (s *InterestService) GetMatchingConfig() (*config.MatchingConfig, error) <span class="cov0" title="0">{
        interestsConfig, err := config.LoadInterestsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;interestsConfig.Matching, nil</span>
}

// CalculateCompatibilityScore вычисляет балл совместимости между пользователями.
func (s *InterestService) CalculateCompatibilityScore(user1ID, user2ID int) (int, error) <span class="cov0" title="0">{
        matchingConfig, err := s.GetMatchingConfig()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">user1Maps, err := s.buildUserInterestMaps(user1ID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">user2Maps, err := s.buildUserInterestMaps(user2ID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">score := s.calculateCompatibilityScore(user1Maps, user2Maps, matchingConfig)

        return score, nil</span>
}

// UserInterestMaps содержит карты интересов пользователя.
type UserInterestMaps struct {
        AllInterests     map[int]bool
        PrimaryInterests map[int]bool
}

// GetUserInterestSummary возвращает сводку интересов пользователя.
func (s *InterestService) GetUserInterestSummary(userID int) (*models.UserInterestSummary, error) <span class="cov0" title="0">{
        selections, err := s.GetUserInterestSelections(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">summary := &amp;models.UserInterestSummary{
                UserID:              userID,
                TotalInterests:      len(selections),
                PrimaryInterests:    []models.InterestWithCategory{},
                AdditionalInterests: []models.InterestWithCategory{},
        }

        // Получаем детали интересов
        for _, selection := range selections </span><span class="cov0" title="0">{
                interest, err := s.GetInterestByID(selection.InterestID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">category, err := s.GetCategoryByID(interest.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">interestWithCategory := models.InterestWithCategory{
                        Interest:     *interest,
                        CategoryName: category.KeyName,
                        CategoryKey:  category.KeyName,
                }

                if selection.IsPrimary </span><span class="cov0" title="0">{
                        summary.PrimaryInterests = append(summary.PrimaryInterests, interestWithCategory)
                }</span> else<span class="cov0" title="0"> {
                        summary.AdditionalInterests = append(summary.AdditionalInterests, interestWithCategory)
                }</span>
        }

        <span class="cov0" title="0">return summary, nil</span>
}

// GetInterestByID возвращает интерес по ID.
func (s *InterestService) GetInterestByID(interestID int) (*models.Interest, error) <span class="cov0" title="0">{
        query := `SELECT id, key_name, category_id, display_order, type, created_at FROM interests WHERE id = $1`

        var interest models.Interest

        err := s.db.QueryRowContext(context.Background(), query, interestID).Scan(
                &amp;interest.ID, &amp;interest.KeyName, &amp;interest.CategoryID,
                &amp;interest.DisplayOrder, &amp;interest.Type, &amp;interest.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;interest, nil</span>
}

// GetCategoryByID возвращает категорию по ID.
func (s *InterestService) GetCategoryByID(categoryID int) (*models.InterestCategory, error) <span class="cov0" title="0">{
        query := `SELECT id, key_name, display_order, created_at FROM interest_categories WHERE id = $1`

        var category models.InterestCategory

        err := s.db.QueryRowContext(context.Background(), query, categoryID).Scan(
                &amp;category.ID, &amp;category.KeyName, &amp;category.DisplayOrder, &amp;category.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;category, nil</span>
}

// ValidateInterestSelection проверяет валидность выбора интересов.
func (s *InterestService) ValidateInterestSelection(userID, totalInterests int) error <span class="cov0" title="0">{
        limits, err := s.GetInterestLimitsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        // // Вычисляем рекомендуемое количество основных интересов
        // recommendedPrimary := int(math.Ceil(float64(totalInterests) * limits.PrimaryPercentage))

        // // Ограничиваем минимумом и максимумом
        // if recommendedPrimary &lt; limits.MinPrimaryInterests {
        //         recommendedPrimary = limits.MinPrimaryInterests
        // }

        // if recommendedPrimary &gt; limits.MaxPrimaryInterests {
        //         recommendedPrimary = limits.MaxPrimaryInterests
        // }

        // Логируем рекомендацию для отладки
        <span class="cov0" title="0">s.logger.DebugWithContext(
                "Interest validation performed",
                "", 0, 0, "ValidateInterestSelection",
                map[string]interface{}{
                        "user_id":         userID,
                        "total_interests": totalInterests,
                },
        )

        // Получаем текущее количество основных интересов
        var currentPrimary int

        countQuery := `SELECT COUNT(*) FROM user_interest_selections WHERE user_id = $1 AND is_primary = true`

        err = s.db.QueryRowContext(context.Background(), countQuery, userID).Scan(&amp;currentPrimary)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if currentPrimary &lt; limits.MinPrimaryInterests </span><span class="cov0" title="0">{
                return errorsPkg.ErrMinPrimaryInterestsRequired
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInterestCategoryByID возвращает категорию интереса по ID.
func (s *InterestService) GetInterestCategoryByID(categoryID int) (*models.InterestCategory, error) <span class="cov0" title="0">{
        var category models.InterestCategory

        err := s.db.QueryRowContext(context.Background(), `
                SELECT id, key_name, display_order, created_at 
                FROM interest_categories 
                WHERE id = $1
        `, categoryID).Scan(
                &amp;category.ID,
                &amp;category.KeyName,
                &amp;category.DisplayOrder,
                &amp;category.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get interest category by ID %d: %w", categoryID, err)
        }</span>

        <span class="cov0" title="0">return &amp;category, nil</span>
}

// buildUserInterestMaps создает карты интересов пользователя.
func (s *InterestService) buildUserInterestMaps(userID int) (*UserInterestMaps, error) <span class="cov0" title="0">{
        interests, err := s.GetUserInterestSelections(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">allMap := make(map[int]bool)
        primaryMap := make(map[int]bool)

        for _, selection := range interests </span><span class="cov0" title="0">{
                allMap[selection.InterestID] = true
                if selection.IsPrimary </span><span class="cov0" title="0">{
                        primaryMap[selection.InterestID] = true
                }</span>
        }

        <span class="cov0" title="0">return &amp;UserInterestMaps{
                AllInterests:     allMap,
                PrimaryInterests: primaryMap,
        }, nil</span>
}

// calculateCompatibilityScore вычисляет балл совместимости.
func (s *InterestService) calculateCompatibilityScore(
        user1Maps, user2Maps *UserInterestMaps,
        config *config.MatchingConfig,
) int <span class="cov0" title="0">{
        score := 0

        for interestID := range user1Maps.AllInterests </span><span class="cov0" title="0">{
                if user2Maps.AllInterests[interestID] </span><span class="cov0" title="0">{
                        score += s.calculateInterestScore(interestID, user1Maps, user2Maps, config)
                }</span>
        }

        <span class="cov0" title="0">return score</span>
}

// calculateInterestScore вычисляет балл за конкретный интерес.
func (s *InterestService) calculateInterestScore(
        interestID int,
        user1Maps, user2Maps *UserInterestMaps,
        config *config.MatchingConfig,
) int <span class="cov0" title="0">{
        switch </span>{
        case user1Maps.PrimaryInterests[interestID] &amp;&amp; user2Maps.PrimaryInterests[interestID]:<span class="cov0" title="0">
                // Оба пользователя считают этот интерес основным
                return config.PrimaryInterestScore * primaryInterestMultiplier</span>
        case user1Maps.PrimaryInterests[interestID] || user2Maps.PrimaryInterests[interestID]:<span class="cov0" title="0">
                // Один из пользователей считает основным
                return config.PrimaryInterestScore + config.AdditionalInterestScore</span>
        default:<span class="cov0" title="0">
                // Оба считают дополнительным
                return config.AdditionalInterestScore</span>
        }
}

// scanInterests сканирует строки интересов.
func (s *InterestService) scanInterests(rows *sql.Rows) ([]models.Interest, error) <span class="cov0" title="0">{
        if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "GetInterestCategories",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">var interests []models.Interest

        for rows.Next() </span><span class="cov0" title="0">{
                var interest models.Interest

                err := rows.Scan(&amp;interest.ID, &amp;interest.KeyName, &amp;interest.CategoryID,
                        &amp;interest.DisplayOrder, &amp;interest.Type, &amp;interest.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan interest: %w", err)
                }</span>

                <span class="cov0" title="0">interests = append(interests, interest)</span>
        }

        <span class="cov0" title="0">return interests, nil</span>
}

// scanInterestSelections сканирует строки выборов интересов.
func (s *InterestService) scanInterestSelections(rows *sql.Rows) ([]models.InterestSelection, error) <span class="cov0" title="0">{
        if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "GetInterestCategories",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "GetInterestCategories",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">var selections []models.InterestSelection

        for rows.Next() </span><span class="cov0" title="0">{
                var selection models.InterestSelection

                err := rows.Scan(&amp;selection.ID, &amp;selection.UserID, &amp;selection.InterestID,
                        &amp;selection.IsPrimary, &amp;selection.SelectionOrder, &amp;selection.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user interest selection: %w", err)
                }</span>

                <span class="cov0" title="0">selections = append(selections, selection)</span>
        }

        <span class="cov0" title="0">return selections, nil</span>
}

// GetAllInterests получает все интересы из системы.
func (s *InterestService) GetAllInterests() ([]models.Interest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, key_name, category_id, display_order, type, created_at
                FROM interests 
                ORDER BY id
        `

        rows, err := s.db.QueryContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "GetInterestCategories",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">var interests []models.Interest
        for rows.Next() </span><span class="cov0" title="0">{
                var interest models.Interest
                err := rows.Scan(
                        &amp;interest.ID,
                        &amp;interest.KeyName,
                        &amp;interest.CategoryID,
                        &amp;interest.DisplayOrder,
                        &amp;interest.Type,
                        &amp;interest.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("operation failed: %w", err)
                }</span>
                <span class="cov0" title="0">interests = append(interests, interest)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

// GetInterestsByCategoryKey возвращает интересы по ключу категории
func (s *InterestService) GetInterestsByCategoryKey(categoryKey string) ([]models.Interest, error) <span class="cov0" title="0">{
        query := `
                SELECT i.id, i.key_name, i.category_id, i.display_order, i.type, i.created_at, ic.key_name
                FROM interests i
                JOIN interest_categories ic ON i.category_id = ic.id
                WHERE ic.key_name = $1 
                ORDER BY i.display_order ASC, i.key_name ASC
        `

        rows, err := s.db.QueryContext(context.Background(), query, categoryKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query interests by category key: %w", err)
        }</span>

        <span class="cov0" title="0">return s.scanInterestsWithCategory(rows)</span>
}

// BatchUpdateUserInterests обновляет интересы пользователя батчем
func (s *InterestService) BatchUpdateUserInterests(userID int, selections []models.InterestSelection) error <span class="cov0" title="0">{
        // Начинаем транзакцию
        tx, err := s.db.BeginTx(context.Background(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = tx.Rollback() }</span>()

        // Удаляем все текущие выборы пользователя
        <span class="cov0" title="0">_, err = tx.ExecContext(context.Background(), "DELETE FROM user_interest_selections WHERE user_id = $1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete existing selections: %w", err)
        }</span>

        // Вставляем новые выборы батчем
        <span class="cov0" title="0">if len(selections) &gt; 0 </span><span class="cov0" title="0">{
                query := `
                        INSERT INTO user_interest_selections (user_id, interest_id, is_primary, created_at)
                        VALUES ($1, $2, $3, NOW())
                `

                stmt, err := tx.PrepareContext(context.Background(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prepare statement: %w", err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if closeErr := stmt.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                s.logger.ErrorWithContext(
                                        "Failed to close prepared statement",
                                        "", 0, 0, "UpdateUserInterests",
                                        map[string]interface{}{
                                                "error": closeErr.Error(),
                                        },
                                )
                        }</span>
                }()

                <span class="cov0" title="0">for _, selection := range selections </span><span class="cov0" title="0">{
                        _, err = stmt.ExecContext(context.Background(), userID, selection.InterestID, selection.IsPrimary)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to insert selection: %w", err)
                        }</span>
                }
        }

        // Подтверждаем транзакцию
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// scanInterestsWithCategory сканирует строки интересов с категорией
func (s *InterestService) scanInterestsWithCategory(rows *sql.Rows) ([]models.Interest, error) <span class="cov0" title="0">{
        if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "scanInterestsWithCategory",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">var interests []models.Interest

        for rows.Next() </span><span class="cov0" title="0">{
                var interest models.Interest

                err := rows.Scan(&amp;interest.ID, &amp;interest.KeyName, &amp;interest.CategoryID,
                        &amp;interest.DisplayOrder, &amp;interest.Type, &amp;interest.CreatedAt, &amp;interest.CategoryKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan interest with category: %w", err)
                }</span>

                <span class="cov0" title="0">interests = append(interests, interest)</span>
        }

        <span class="cov0" title="0">return interests, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package core provides the main business logic for the language exchange bot.
package core

import (
        "context"
        "database/sql"
        "fmt"
        "language-exchange-bot/internal/cache"
        "language-exchange-bot/internal/circuit_breaker"
        "language-exchange-bot/internal/config"
        "language-exchange-bot/internal/database"
        errorsPkg "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/logging"
        "language-exchange-bot/internal/models"
        "language-exchange-bot/internal/validation"
        "log"
        "strings"
        "time"
)

// Константы для валидации.
const (
        // minFeedbackLength - минимальная длина отзыва.
        minFeedbackLength = 10

        // maxFeedbackLength - максимальная длина отзыва.
        maxFeedbackLength = 1000
)

// BotService provides the main business logic for the language exchange bot.
// It coordinates between different services like database, cache, localization,
// and handles the core business logic for user management, matching, and feedback.
//
// BotService is the central component that:
// - Manages user registration and profile completion
// - Handles language and interest selection
// - Processes user feedback and notifications
// - Provides caching and performance optimization
// - Implements circuit breaker patterns for resilience
type BotService struct {
        // DB provides database operations interface
        DB database.Database

        // Localizer handles internationalization and translations
        Localizer *localization.Localizer

        // Cache provides caching operations for performance optimization
        Cache cache.ServiceInterface

        // InvalidationService manages cache invalidation strategies
        InvalidationService *cache.InvalidationService

        // MetricsService collects and provides cache performance metrics
        MetricsService *cache.MetricsService

        // BatchLoader handles batch database operations for efficiency
        BatchLoader *database.BatchLoader

        // Service provides validation services for user input
        Service *validation.Service

        // LoggingService handles application logging
        LoggingService *logging.LoggingService

        // FeedbackNotificationFunc is called when new feedback is received
        // It should handle sending notifications to administrators
        FeedbackNotificationFunc func(data map[string]interface{}) error

        // Config contains application configuration
        Config *config.Config

        // Circuit Breakers provide resilience against external service failures
        TelegramCircuitBreaker *circuit_breaker.CircuitBreaker // Protects against Telegram API failures
        DatabaseCircuitBreaker *circuit_breaker.CircuitBreaker // Protects against database failures
        RedisCircuitBreaker    *circuit_breaker.CircuitBreaker // Protects against Redis failures
}

// NewBotService creates a new BotService instance with in-memory caching.
// This constructor is used when Redis is not available or for development.
//
// Parameters:
//   - db: Database connection instance
//   - errorHandler: Error handling interface (can be nil)
//
// Returns:
//   - *BotService: Initialized service instance
//
// Example:
//
//        db, err := database.NewDB(databaseURL)
//        if err != nil {
//            log.Fatal(err)
//        }
//        service := core.NewBotService(db, nil)
func NewBotService(db *database.DB, errorHandler interface{}) *BotService <span class="cov0" title="0">{
        // Создаем конфигурацию
        cfg := config.Load()

        // Создаем кэш с конфигурацией по умолчанию
        cacheService := cache.NewService(cache.DefaultConfig())

        // Создаем сервисы для управления кэшем
        invalidationService := cache.NewInvalidationService(cacheService)
        metricsService := cache.NewMetricsService(cacheService)

        // Создаем BatchLoader для оптимизации N+1 запросов
        batchLoader := database.NewBatchLoader(db)

        // Создаем Circuit Breakers
        telegramCB := circuit_breaker.NewCircuitBreaker(circuit_breaker.TelegramConfig())
        databaseCB := circuit_breaker.NewCircuitBreaker(circuit_breaker.DatabaseConfig())
        redisCB := circuit_breaker.NewCircuitBreaker(circuit_breaker.RedisConfig())

        // Создаем Service (пока без errorHandler для совместимости)
        var validationService *validation.Service

        var loggingService *logging.LoggingService

        if errorHandler != nil </span><span class="cov0" title="0">{
                if handler, ok := errorHandler.(*errorsPkg.ErrorHandler); ok </span><span class="cov0" title="0">{
                        validationService = validation.NewService(handler)
                        loggingService = logging.NewLoggingService(handler)
                }</span>
        }

        <span class="cov0" title="0">service := &amp;BotService{
                DB:                       &amp;databaseAdapter{db: db}, // Оборачиваем в адаптер
                Localizer:                localization.NewLocalizer(db.GetConnection()),
                Cache:                    cacheService,
                InvalidationService:      invalidationService,
                MetricsService:           metricsService,
                BatchLoader:              batchLoader,
                Service:                  validationService,
                LoggingService:           loggingService,
                FeedbackNotificationFunc: nil,
                Config:                   cfg,
                TelegramCircuitBreaker:   telegramCB,
                DatabaseCircuitBreaker:   databaseCB,
                RedisCircuitBreaker:      redisCB,
        }

        // Запускаем cache warming в фоне
        go func() </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()

                if err := cacheService.WarmUp(ctx, service); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Cache warming failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">return service</span>
}

// NewBotServiceWithRedis создает BotService с Redis кэшем.
// NewBotServiceWithRedis creates a new BotService instance with Redis caching.
// This constructor is used in production environments for better performance.
//
// Parameters:
//   - db: Database connection instance
//   - redisURL: Redis server URL (e.g., "localhost:6379")
//   - redisPassword: Redis password (empty string if no password)
//   - redisDB: Redis database number (0-15)
//   - errorHandler: Error handling interface (can be nil)
//
// Returns:
//   - *BotService: Initialized service instance with Redis caching
//   - error: Any error that occurred during initialization
//
// Example:
//
//        db, err := database.NewDB(databaseURL)
//        if err != nil {
//            log.Fatal(err)
//        }
//        service, err := core.NewBotServiceWithRedis(db, "localhost:6379", "", 0, nil)
//        if err != nil {
//            log.Fatal(err)
//        }
func NewBotServiceWithRedis(
        db *database.DB,
        redisURL, redisPassword string,
        redisDB int,
        errorHandler interface{},
) (*BotService, error) <span class="cov0" title="0">{
        // Создаем конфигурацию
        cfg := config.Load()

        // Создаем Redis кэш
        redisCache, err := cache.NewRedisCacheService(redisURL, redisPassword, redisDB, cache.DefaultConfig())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Redis cache: %w", err)
        }</span>

        // Создаем сервисы для управления кэшем
        <span class="cov0" title="0">invalidationService := cache.NewInvalidationService(redisCache)
        metricsService := cache.NewMetricsService(redisCache)

        // Создаем BatchLoader для оптимизации N+1 запросов
        batchLoader := database.NewBatchLoader(db)

        // Создаем Circuit Breakers
        telegramCB := circuit_breaker.NewCircuitBreaker(circuit_breaker.TelegramConfig())
        databaseCB := circuit_breaker.NewCircuitBreaker(circuit_breaker.DatabaseConfig())
        redisCB := circuit_breaker.NewCircuitBreaker(circuit_breaker.RedisConfig())

        // Создаем Service и LoggingService
        var validationService *validation.Service

        var loggingService *logging.LoggingService

        if errorHandler != nil </span><span class="cov0" title="0">{
                if handler, ok := errorHandler.(*errorsPkg.ErrorHandler); ok </span><span class="cov0" title="0">{
                        validationService = validation.NewService(handler)
                        loggingService = logging.NewLoggingService(handler)
                }</span>
        }

        <span class="cov0" title="0">return &amp;BotService{
                DB:                       &amp;databaseAdapter{db: db}, // Оборачиваем в адаптер
                Localizer:                localization.NewLocalizer(db.GetConnection()),
                Cache:                    redisCache,
                InvalidationService:      invalidationService,
                MetricsService:           metricsService,
                BatchLoader:              batchLoader,
                Service:                  validationService,
                LoggingService:           loggingService,
                Config:                   cfg,
                FeedbackNotificationFunc: nil,
                TelegramCircuitBreaker:   telegramCB,
                DatabaseCircuitBreaker:   databaseCB,
                RedisCircuitBreaker:      redisCB,
        }, nil</span>
}

// databaseAdapter адаптер для совместимости с интерфейсом Database.
type databaseAdapter struct {
        db *database.DB
}

// Реализуем все методы интерфейса, делегируя к db или создавая заглушки

func (a *databaseAdapter) UpdateUserProfileCompletionLevel(userID int, level int) error <span class="cov0" title="0">{
        return a.db.UpdateUserProfileCompletionLevel(userID, level)
}</span>

func (a *databaseAdapter) FindOrCreateUser(telegramID int64, username, firstName string) (*models.User, error) <span class="cov0" title="0">{
        user, err := a.db.FindOrCreateUser(telegramID, username, firstName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find or create user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (a *databaseAdapter) GetUserByTelegramID(telegramID int64) (*models.User, error) <span class="cov0" title="0">{
        user, err := a.db.GetUserByTelegramID(telegramID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by telegram ID: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (a *databaseAdapter) UpdateUser(user *models.User) error <span class="cov0" title="0">{
        err := a.db.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) UpdateUserInterfaceLanguage(userID int, language string) error <span class="cov0" title="0">{
        err := a.db.UpdateUserInterfaceLanguage(userID, language)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user interface language: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) UpdateUserState(userID int, state string) error <span class="cov0" title="0">{
        err := a.db.UpdateUserState(userID, state)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user state: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) UpdateUserStatus(userID int, status string) error <span class="cov0" title="0">{
        err := a.db.UpdateUserStatus(userID, status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) UpdateUserNativeLanguage(userID int, langCode string) error <span class="cov0" title="0">{
        err := a.db.UpdateUserNativeLanguage(userID, langCode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user native language: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) UpdateUserTargetLanguage(userID int, langCode string) error <span class="cov0" title="0">{
        err := a.db.UpdateUserTargetLanguage(userID, langCode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user target language: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) UpdateUserTargetLanguageLevel(userID int, level string) error <span class="cov0" title="0">{
        err := a.db.UpdateUserTargetLanguageLevel(userID, level)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user target language level: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) ResetUserProfile(userID int) error <span class="cov0" title="0">{
        err := a.db.ResetUserProfile(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reset user profile: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) GetLanguages() ([]*models.Language, error) <span class="cov0" title="0">{
        languages, err := a.db.GetLanguages()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get languages: %w", err)
        }</span>

        <span class="cov0" title="0">return languages, nil</span>
}

func (a *databaseAdapter) GetLanguageByCode(code string) (*models.Language, error) <span class="cov0" title="0">{
        language, err := a.db.GetLanguageByCode(code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get language by code: %w", err)
        }</span>

        <span class="cov0" title="0">return language, nil</span>
}

func (a *databaseAdapter) GetInterests() ([]*models.Interest, error) <span class="cov0" title="0">{
        interests, err := a.db.GetInterests()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get interests: %w", err)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

func (a *databaseAdapter) GetUserSelectedInterests(userID int) ([]int, error) <span class="cov0" title="0">{
        interests, err := a.db.GetUserSelectedInterests(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user selected interests: %w", err)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

func (a *databaseAdapter) SaveUserInterests(userID int, interestIDs []int) error <span class="cov0" title="0">{
        err := a.db.SaveUserInterests(userID, interestIDs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save user interests: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) SaveUserInterest(userID, interestID int, isPrimary bool) error <span class="cov0" title="0">{
        err := a.db.SaveUserInterest(userID, interestID, isPrimary)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save user interest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) RemoveUserInterest(userID, interestID int) error <span class="cov0" title="0">{
        err := a.db.RemoveUserInterest(userID, interestID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove user interest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) ClearUserInterests(userID int) error <span class="cov0" title="0">{
        err := a.db.ClearUserInterests(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear user interests: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) GetUserInterestSelections(userID int) ([]models.InterestSelection, error) <span class="cov0" title="0">{
        selections, err := a.db.GetUserInterestSelections(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user interest selections: %w", err)
        }</span>

        <span class="cov0" title="0">return selections, nil</span>
}

func (a *databaseAdapter) GetInterestByID(interestID int) (*models.Interest, error) <span class="cov0" title="0">{
        interest, err := a.db.GetInterestByID(interestID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get interest by ID: %w", err)
        }</span>

        <span class="cov0" title="0">return interest, nil</span>
}

func (a *databaseAdapter) SaveUserFeedback(userID int, feedbackText string, contactInfo *string) error <span class="cov0" title="0">{
        err := a.db.SaveUserFeedback(userID, feedbackText, contactInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save user feedback: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) GetUnprocessedFeedback() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        feedback, err := a.db.GetUnprocessedFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get unprocessed feedback: %w", err)
        }</span>

        <span class="cov0" title="0">return feedback, nil</span>
}

func (a *databaseAdapter) MarkFeedbackProcessed(feedbackID int, adminResponse string) error <span class="cov0" title="0">{
        err := a.db.MarkFeedbackProcessed(feedbackID, adminResponse)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark feedback processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *databaseAdapter) GetConnection() *sql.DB <span class="cov0" title="0">{
        return a.db.GetConnection()
}</span>

func (a *databaseAdapter) Close() error <span class="cov0" title="0">{
        err := a.db.Close()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close database: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NewBotServiceWithInterface создает BotService с интерфейсом Database (для тестов).
func NewBotServiceWithInterface(db database.Database, localizer *localization.Localizer) *BotService <span class="cov8" title="1">{
        return &amp;BotService{
                DB:                       db,
                Localizer:                localizer,
                Cache:                    nil,
                InvalidationService:      nil,
                MetricsService:           nil,
                BatchLoader:              nil,
                Service:                  nil,
                LoggingService:           nil,
                FeedbackNotificationFunc: nil,
        }
}</span>

// SetFeedbackNotificationFunc устанавливает функцию для отправки уведомлений о новых отзывах.
func (s *BotService) SetFeedbackNotificationFunc(fn func(map[string]interface{}) error) <span class="cov8" title="1">{
        s.FeedbackNotificationFunc = fn
}</span>

// DetectLanguage определяет язык интерфейса по коду языка Telegram.
func (s *BotService) DetectLanguage(telegramLangCode string) string <span class="cov8" title="1">{
        switch telegramLangCode </span>{
        case "ru", "ru-RU":<span class="cov8" title="1">
                return "ru"</span>
        case "es", "es-ES", "es-MX":<span class="cov8" title="1">
                return "es"</span>
        case "zh", "zh-CN", "zh-TW":<span class="cov8" title="1">
                return "zh"</span>
        default:<span class="cov8" title="1">
                return "en"</span>
        }
}

// HandleUserRegistration обрабатывает регистрацию нового пользователя.
func (s *BotService) HandleUserRegistration(
        telegramID int64,
        username, firstName, telegramLangCode string,
) (*models.User, error) <span class="cov8" title="1">{
        user, err := s.DB.FindOrCreateUser(telegramID, username, firstName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">detected := s.DetectLanguage(telegramLangCode)
        // Определяем начальный язык интерфейса только для новых пользователей
        if user.Status == models.StatusNew || user.InterfaceLanguageCode == "" </span><span class="cov8" title="1">{
                // Для новых пользователей устанавливаем язык интерфейса по настройкам Telegram
                // Если язык не определен, используем русский как дефолт для проекта
                if detected == "" </span><span class="cov0" title="0">{
                        user.InterfaceLanguageCode = "ru"
                }</span> else<span class="cov8" title="1"> {
                        user.InterfaceLanguageCode = detected
                }</span>

                <span class="cov8" title="1">if err := s.DB.UpdateUserInterfaceLanguage(user.ID, user.InterfaceLanguageCode); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update interface language for new user %d to %s: %v", user.ID, user.InterfaceLanguageCode, err)
                }</span>
        }

        <span class="cov8" title="1">return user, nil</span>
}

// GetWelcomeMessage возвращает приветственное сообщение для пользователя.
func (s *BotService) GetWelcomeMessage(user *models.User) string <span class="cov8" title="1">{
        return s.Localizer.GetWithParams(user.InterfaceLanguageCode, "welcome_message", map[string]string{
                "name": user.FirstName,
        })
}</span>

// GetLanguagePrompt возвращает подсказку для выбора языка.
func (s *BotService) GetLanguagePrompt(user *models.User, promptType string) string <span class="cov8" title="1">{
        key := "choose_native_language"

        if promptType == "target" </span><span class="cov8" title="1">{
                key = "choose_target_language"
        }</span>

        <span class="cov8" title="1">return s.Localizer.Get(user.InterfaceLanguageCode, key)</span>
}

// GetLocalizedLanguageName возвращает локализованное название языка.
func (s *BotService) GetLocalizedLanguageName(langCode, interfaceLangCode string) string <span class="cov8" title="1">{
        return s.Localizer.GetLanguageName(langCode, interfaceLangCode)
}</span>

// GetLocalizedInterests возвращает локализованные интересы для указанного языка.
func (s *BotService) GetLocalizedInterests(langCode string) (map[int]string, error) <span class="cov0" title="0">{
        interests, err := s.Localizer.GetInterests(langCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get interests: %w", err)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

// IsProfileCompleted проверяет наличие языков и хотя бы одного интереса.
func (s *BotService) IsProfileCompleted(user *models.User) (bool, error) <span class="cov8" title="1">{
        if user.NativeLanguageCode == "" || user.TargetLanguageCode == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">ids, err := s.DB.GetUserSelectedInterests(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return len(ids) &gt; 0, nil</span>
}

// BuildProfileSummary возвращает локализованное резюме профиля.
func (s *BotService) BuildProfileSummary(user *models.User) (string, error) <span class="cov0" title="0">{
        lang := user.InterfaceLanguageCode

        // Получаем основную информацию
        basicInfo := s.buildBasicProfileInfo(user, lang)
        languageInfo := s.buildLanguageProfileInfo(user, lang)
        interestsInfo := s.buildInterestsProfileInfo(user, lang)
        additionalInfo := s.buildAdditionalProfileInfo(user, lang)

        // Объединяем все части
        lines := []string{basicInfo}
        lines = append(lines, "", languageInfo, interestsInfo)
        lines = append(lines, "")
        lines = append(lines, additionalInfo...)

        return strings.Join(lines, "\n"), nil
}</span>

// buildBasicProfileInfo строит основную информацию профиля.
func (s *BotService) buildBasicProfileInfo(user *models.User, lang string) string <span class="cov0" title="0">{
        displayName := s.getDisplayName(user)
        nameLine := fmt.Sprintf("👤 %s: %s", s.Localizer.Get(lang, "profile_field_name"), displayName)

        usernameLine := ""
        if user.Username != "" </span><span class="cov0" title="0">{
                usernameLine = fmt.Sprintf("🔗 %s: @%s", s.Localizer.Get(lang, "profile_field_username"), user.Username)
        }</span>

        <span class="cov0" title="0">if usernameLine != "" </span><span class="cov0" title="0">{
                return nameLine + "\n" + usernameLine
        }</span>

        <span class="cov0" title="0">return nameLine</span>
}

// buildLanguageProfileInfo строит информацию о языках.
func (s *BotService) buildLanguageProfileInfo(user *models.User, lang string) string <span class="cov0" title="0">{
        nativeName := s.Localizer.GetLanguageName(user.NativeLanguageCode, lang)
        targetName := s.Localizer.GetLanguageName(user.TargetLanguageCode, lang)

        nativeFlag := s.getLanguageFlag(user.NativeLanguageCode)
        targetFlag := s.getLanguageFlag(user.TargetLanguageCode)

        native := fmt.Sprintf("%s %s: %s", nativeFlag, s.Localizer.Get(lang, "profile_field_native"), nativeName)

        levelText := s.formatLanguageLevel(user.TargetLanguageLevel)
        target := fmt.Sprintf("%s %s: %s (%s)",
                targetFlag,
                s.Localizer.Get(lang, "profile_field_target"),
                targetName,
                levelText,
        )

        return native + "\n" + target
}</span>

// buildInterestsProfileInfo строит информацию об интересах.
func (s *BotService) buildInterestsProfileInfo(user *models.User, lang string) string <span class="cov0" title="0">{
        // Получаем выборы пользователя из новой системы
        selections, err := s.DB.GetUserInterestSelections(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback на старую систему
                ids, err := s.DB.GetUserSelectedInterests(user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        ids = []int{}
                }</span>

                // Получаем все интересы для локализации
                <span class="cov0" title="0">allInterests, _ := s.Localizer.GetInterests(lang)

                var picked []string

                for _, id := range ids </span><span class="cov0" title="0">{
                        if name, ok := allInterests[id]; ok </span><span class="cov0" title="0">{
                                picked = append(picked, name)
                        }</span> else<span class="cov0" title="0"> {
                                // Fallback: добавляем ID если нет локализации
                                picked = append(picked, fmt.Sprintf("Интерес %d", id))
                        }</span>
                }

                <span class="cov0" title="0">interestsLine := fmt.Sprintf("🎯 %s: %d", s.Localizer.Get(lang, "profile_field_interests"), len(picked))

                if len(picked) &gt; 0 </span><span class="cov0" title="0">{
                        interestsLine = fmt.Sprintf("🎯 %s: %d\n• %s",
                                s.Localizer.Get(lang, "profile_field_interests"),
                                len(picked),
                                strings.Join(picked, ", "),
                        )
                }</span>

                <span class="cov0" title="0">return interestsLine</span>
        }

        // Используем новую систему
        <span class="cov0" title="0">var allInterests []string
        var primaryCount, additionalCount int

        // Обрабатываем выборы пользователя
        for _, selection := range selections </span><span class="cov0" title="0">{
                // Получаем информацию об интересе
                interest, err := s.DB.GetInterestByID(selection.InterestID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Получаем локализованное название
                <span class="cov0" title="0">interestName := s.Localizer.Get(lang, "interest_"+interest.KeyName)
                if interestName == "interest_"+interest.KeyName </span><span class="cov0" title="0">{
                        // Fallback: пытаемся получить из кэша интересов
                        allInterestsMap, _ := s.Localizer.GetInterests(lang)
                        if cachedName, exists := allInterestsMap[interest.ID]; exists </span><span class="cov0" title="0">{
                                interestName = cachedName
                        }</span> else<span class="cov0" title="0"> {
                                // Последний fallback на key_name
                                interestName = interest.KeyName
                        }</span>
                }

                <span class="cov0" title="0">if selection.IsPrimary </span><span class="cov0" title="0">{
                        allInterests = append(allInterests, "⭐ "+interestName)
                        primaryCount++
                }</span> else<span class="cov0" title="0"> {
                        allInterests = append(allInterests, interestName)
                        additionalCount++
                }</span>
        }

        <span class="cov0" title="0">totalInterests := len(selections)
        interestsLine := fmt.Sprintf("🎯 %s: %d", s.Localizer.Get(lang, "profile_field_interests"), totalInterests)

        if len(allInterests) &gt; 0 </span><span class="cov0" title="0">{
                interestsLine = fmt.Sprintf("🎯 %s: %d\n• %s",
                        s.Localizer.Get(lang, "profile_field_interests"),
                        totalInterests,
                        strings.Join(allInterests, ", "),
                )
        }</span>

        <span class="cov0" title="0">return interestsLine</span>
}

// buildAdditionalProfileInfo строит дополнительную информацию профиля.
func (s *BotService) buildAdditionalProfileInfo(user *models.User, lang string) []string <span class="cov0" title="0">{
        var lines []string

        // Временная доступность
        availabilityText := s.formatTimeAvailability(user.TimeAvailability, lang)
        lines = append(lines, fmt.Sprintf("⏰ %s: %s", s.Localizer.Get(lang, "profile_field_availability"), availabilityText))

        // Предпочтения общения
        communicationText := s.formatCommunicationPreferences(user.FriendshipPreferences, lang)
        lines = append(lines, fmt.Sprintf("💬 %s: %s", s.Localizer.Get(lang, "profile_field_communication"), communicationText))

        // Статус и время в системе
        statusText := s.formatUserStatus(user, lang)
        memberSinceText := s.formatMemberSince(user.CreatedAt, lang)
        lines = append(lines, "", statusText, memberSinceText)

        return lines
}</span>

// formatTimeAvailability форматирует временную доступность.
func (s *BotService) formatTimeAvailability(ta *models.TimeAvailability, lang string) string <span class="cov0" title="0">{
        if ta == nil </span><span class="cov0" title="0">{
                return "Не указано"
        }</span>

        <span class="cov0" title="0">dayText := s.formatDayType(ta, lang)
        timeText := s.formatTimeSlot(ta.TimeSlot, lang)

        return fmt.Sprintf("%s, %s", dayText, timeText)</span>
}

// formatDayType форматирует тип дня.
func (s *BotService) formatDayType(ta *models.TimeAvailability, lang string) string <span class="cov0" title="0">{
        switch ta.DayType </span>{
        case "weekdays":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_weekdays")</span>
        case "weekends":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_weekends")</span>
        case "any":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_any")</span>
        case "specific":<span class="cov0" title="0">
                return s.formatSpecificDays(ta.SpecificDays, lang)</span>
        default:<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_any")</span>
        }
}

// formatSpecificDays форматирует конкретные дни.
func (s *BotService) formatSpecificDays(specificDays []string, lang string) string <span class="cov0" title="0">{
        if len(specificDays) &gt; 0 </span><span class="cov0" title="0">{
                return strings.Join(specificDays, ", ")
        }</span>

        <span class="cov0" title="0">return s.Localizer.Get(lang, "time_any")</span>
}

// formatTimeSlot форматирует временной слот.
func (s *BotService) formatTimeSlot(timeSlot, lang string) string <span class="cov0" title="0">{
        switch timeSlot </span>{
        case "morning":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_morning")</span>
        case "day":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_day")</span>
        case "evening":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_evening")</span>
        case "late":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_late")</span>
        default:<span class="cov0" title="0">
                return s.Localizer.Get(lang, "time_any")</span>
        }
}

// formatCommunicationPreferences форматирует предпочтения общения.
func (s *BotService) formatCommunicationPreferences(fp *models.FriendshipPreferences, lang string) string <span class="cov0" title="0">{
        if fp == nil </span><span class="cov0" title="0">{
                return "Не указано"
        }</span>

        <span class="cov0" title="0">styleText := s.formatCommunicationStyle(fp.CommunicationStyle, lang)
        freqText := s.formatCommunicationFreq(fp.CommunicationFreq, lang)

        return fmt.Sprintf("%s, %s", styleText, freqText)</span>
}

// formatCommunicationStyle форматирует стиль общения.
func (s *BotService) formatCommunicationStyle(style, lang string) string <span class="cov0" title="0">{
        switch style </span>{
        case "text":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "comm_text")</span>
        case "voice_msg":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "comm_voice")</span>
        case "audio_call":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "comm_audio")</span>
        case "video_call":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "comm_video")</span>
        case "meet_person":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "comm_meet")</span>
        default:<span class="cov0" title="0">
                return style</span>
        }
}

// formatCommunicationFreq форматирует частоту общения.
func (s *BotService) formatCommunicationFreq(freq, lang string) string <span class="cov0" title="0">{
        switch freq </span>{
        case "spontaneous":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "freq_spontaneous")</span>
        case "weekly":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "freq_weekly")</span>
        case "daily":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "freq_daily")</span>
        case "intensive":<span class="cov0" title="0">
                return s.Localizer.Get(lang, "freq_intensive")</span>
        default:<span class="cov0" title="0">
                return freq</span>
        }
}

// formatUserStatus форматирует статус пользователя.
func (s *BotService) formatUserStatus(user *models.User, lang string) string <span class="cov0" title="0">{
        var statusText string

        var statusEmoji string

        switch user.Status </span>{
        case "new":<span class="cov0" title="0">
                statusText = s.Localizer.Get(lang, "status_new")
                statusEmoji = "🆕"</span>
        case "filling_profile":<span class="cov0" title="0">
                statusText = s.Localizer.Get(lang, "status_filling")
                statusEmoji = "📝"</span>
        case "active":<span class="cov0" title="0">
                statusText = s.Localizer.Get(lang, "status_active")
                statusEmoji = "🟢"</span>
        case "paused":<span class="cov0" title="0">
                statusText = s.Localizer.Get(lang, "status_paused")
                statusEmoji = "⏸️"</span>
        default:<span class="cov0" title="0">
                statusText = user.Status
                statusEmoji = "❓"</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%s %s: %s", statusEmoji, s.Localizer.Get(lang, "profile_field_status"), statusText)</span>
}

// formatMemberSince форматирует дату регистрации.
func (s *BotService) formatMemberSince(createdAt time.Time, lang string) string <span class="cov0" title="0">{
        dateStr := createdAt.Format("02.01.2006")

        return fmt.Sprintf("📅 %s: %s", s.Localizer.Get(lang, "profile_field_member_since"), dateStr)
}</span>

// getDisplayName возвращает отображаемое имя пользователя.
func (s *BotService) getDisplayName(user *models.User) string <span class="cov8" title="1">{
        if user.Username == "madam_di_5" </span><span class="cov8" title="1">{
                return "Лисёнок 🦊"
        }</span>

        <span class="cov8" title="1">return user.FirstName</span>
}

// formatLanguageLevel форматирует уровень языка в читаемый вид.
func (s *BotService) formatLanguageLevel(level string) string <span class="cov8" title="1">{
        switch level </span>{
        case "beginner":<span class="cov8" title="1">
                return "A1-A2"</span>
        case "elementary":<span class="cov8" title="1">
                return "A2-B1"</span>
        case "intermediate":<span class="cov8" title="1">
                return "B1-B2"</span>
        case "upper_intermediate":<span class="cov8" title="1">
                return "B2-C1"</span>
        case "advanced":<span class="cov8" title="1">
                return "C1-C2"</span>
        default:<span class="cov8" title="1">
                return level</span>
        }
}

// Методы работы с обратной связью

// SendFeedbackNotification отправляет уведомление администраторам о новом отзыве.
func (s *BotService) SendFeedbackNotification(feedbackData map[string]interface{}, admins []int64) error <span class="cov0" title="0">{
        if s.FeedbackNotificationFunc != nil </span><span class="cov0" title="0">{
                return s.FeedbackNotificationFunc(feedbackData)
        }</span>

        // Fallback: логируем уведомление если функция не установлена
        <span class="cov0" title="0">adminMsg := fmt.Sprintf(`
📝 Новый отзыв от пользователя:

👤 Имя: %s
�� Telegram ID: %d

%s

📝 Отзыв:
%s
`,
                feedbackData["first_name"].(string),
                feedbackData["telegram_id"].(int64),
                func() string </span><span class="cov0" title="0">{
                        if username, ok := feedbackData["username"].(*string); ok &amp;&amp; username != nil </span><span class="cov0" title="0">{
                                return "👤 Username: @" + *username
                        }</span>

                        <span class="cov0" title="0">return "👤 Username: отсутствует"</span>
                }(),
                feedbackData["feedback_text"].(string),
        )

        // Добавляем контактную информацию, если есть
        <span class="cov0" title="0">if contactInfo, ok := feedbackData["contact_info"].(*string); ok &amp;&amp; contactInfo != nil </span><span class="cov0" title="0">{
                adminMsg += "\n📞 Контакты: " + *contactInfo
        }</span>

        // Пока что просто логируем уведомление
        <span class="cov0" title="0">log.Printf("Отправка уведомления администраторам: %s, to %v", adminMsg, admins)

        return nil</span>
}

// ValidateFeedback проверяет корректность отзыва по длине.
func (s *BotService) ValidateFeedback(feedbackText string) error <span class="cov8" title="1">{
        length := len([]rune(feedbackText)) // Учитываем Unicode

        if length &lt; minFeedbackLength </span><span class="cov8" title="1">{
                return errorsPkg.ErrFeedbackTooShort
        }</span>

        <span class="cov8" title="1">if length &gt; maxFeedbackLength </span><span class="cov8" title="1">{
                return errorsPkg.ErrFeedbackTooLong
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveUserFeedback сохраняет отзыв пользователя и отправляет уведомления.
func (s *BotService) SaveUserFeedback(userID int, feedbackText string, contactInfo *string, admins []int64) error <span class="cov0" title="0">{
        // Валидируем отзыв
        if err := s.ValidateFeedback(feedbackText); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в базу данных
        <span class="cov0" title="0">if err := s.DB.SaveUserFeedback(userID, feedbackText, contactInfo); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка сохранения отзыва в базу данных: %w", err)
        }</span>

        // Получаем данные пользователя для уведомления администраторов
        <span class="cov0" title="0">userData, err := s.GetUserDataForFeedback(userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Не удалось получить данные пользователя для уведомления: %v", err)

                return nil // Возвращаемся без ошибки
        }</span>

        // Объединяем данные с отзывом
        <span class="cov0" title="0">fbData := userData

        fbData["feedback_text"] = feedbackText

        if contactInfo != nil </span><span class="cov0" title="0">{
                fbData["contact_info"] = contactInfo
        }</span>

        // Отправляем уведомление администраторам
        <span class="cov0" title="0">if err := s.SendFeedbackNotification(fbData, admins); err != nil </span><span class="cov0" title="0">{
                log.Printf("Ошибка отправки уведомления администраторам: %v", err)
                // Пытаемся отправить уведомление через function callback если он установлен
                if s.FeedbackNotificationFunc != nil </span><span class="cov0" title="0">{
                        err := s.FeedbackNotificationFunc(fbData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Fallback: также не удалось отправить через callback: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Fallback: уведомление отправлено через callback")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetUserDataForFeedback получает данные пользователя для формирования уведомления о новом отзыве.
func (s *BotService) GetUserDataForFeedback(userID int) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Получаем пользователя по ID (нужно добавить метод в DB)
        var telegramID int64

        var username, firstName string

        err := s.DB.GetConnection().QueryRowContext(context.Background(), `
                SELECT telegram_id, username, first_name
                FROM users WHERE id = $1
        `, userID).Scan(&amp;telegramID, &amp;username, &amp;firstName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "telegram_id": telegramID,
                "first_name":  firstName,
        }

        if username != "" </span><span class="cov0" title="0">{
                result["username"] = &amp;username
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetAllUnprocessedFeedback получает все необработанные отзывы для администратора.
func (s *BotService) GetAllUnprocessedFeedback() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        feedback, err := s.DB.GetUnprocessedFeedback()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get unprocessed feedback: %w", err)
        }</span>

        <span class="cov0" title="0">return feedback, nil</span>
}

// GetAllFeedback получает все отзывы для администратора.
func (s *BotService) GetAllFeedback() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := getFeedbackQuery()

        rows, err := s.DB.GetConnection().QueryContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.LoggingService.Database().ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "GetAllFeedback",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">return s.processFeedbackRows(rows), nil</span>
}

// getFeedbackQuery возвращает SQL запрос для получения всех отзывов.
func getFeedbackQuery() string <span class="cov0" title="0">{
        return `
        SELECT uf.id, uf.feedback_text, uf.contact_info, uf.created_at,
               uf.is_processed, u.username, u.telegram_id, u.first_name,
               uf.admin_response
        FROM user_feedback uf
        JOIN users u ON uf.user_id = u.id
        ORDER BY uf.created_at DESC
    `
}</span>

// processFeedbackRows обрабатывает строки результата запроса отзывов.
func (s *BotService) processFeedbackRows(rows *sql.Rows) []map[string]interface{} <span class="cov0" title="0">{
        var feedbacks []map[string]interface{}

        for rows.Next() </span><span class="cov0" title="0">{
                feedback, err := s.scanFeedbackRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Пропускаем ошибочные записи
                }

                <span class="cov0" title="0">feedbacks = append(feedbacks, feedback)</span>
        }

        <span class="cov0" title="0">return feedbacks</span>
}

// scanFeedbackRow сканирует одну строку результата запроса отзывов.
func (s *BotService) scanFeedbackRow(rows *sql.Rows) (map[string]interface{}, error) <span class="cov0" title="0">{
        var (
                feedbackID   int
                feedbackText string
                contactInfo  sql.NullString
                createdAt    sql.NullTime
                isProcessed  bool
                username     sql.NullString
                telegramID   int64
                firstName    string
                adminResp    sql.NullString
        )

        err := rows.Scan(&amp;feedbackID, &amp;feedbackText, &amp;contactInfo, &amp;createdAt, &amp;isProcessed,
                &amp;username, &amp;telegramID, &amp;firstName, &amp;adminResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">feedback := map[string]interface{}{
                "id":            feedbackID,
                "feedback_text": feedbackText,
                "created_at":    createdAt.Time,
                "telegram_id":   telegramID,
                "first_name":    firstName,
                "is_processed":  isProcessed,
        }

        // Добавляем опциональные поля
        feedback["username"] = getStringValue(username)
        feedback["contact_info"] = getStringValue(contactInfo)
        feedback["admin_response"] = getStringValue(adminResp)

        return feedback, nil</span>
}

// getStringValue возвращает строковое значение из sql.NullString.
func getStringValue(nullStr sql.NullString) interface{} <span class="cov0" title="0">{
        if nullStr.Valid </span><span class="cov0" title="0">{
                return nullStr.String
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateFeedbackStatus обновляет статус отзыва (обработан/не обработан).
func (s *BotService) UpdateFeedbackStatus(feedbackID int, isProcessed bool) error <span class="cov0" title="0">{
        query := `
                UPDATE user_feedback
                SET is_processed = $1, updated_at = NOW()
                WHERE id = $2
        `

        result, err := s.DB.GetConnection().ExecContext(context.Background(), query, isProcessed, feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка обновления статуса отзыва: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось получить количество измененных строк: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errorsPkg.ErrFeedbackNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ArchiveFeedback архивирует отзыв.
func (s *BotService) ArchiveFeedback(feedbackID int) error <span class="cov0" title="0">{
        query := `
                UPDATE user_feedback
                SET is_processed = true, updated_at = NOW()
                WHERE id = $1
        `

        result, err := s.DB.GetConnection().ExecContext(context.Background(), query, feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка архивирования отзыва: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка получения количества обновленных строк: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errorsPkg.ErrFeedbackNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteFeedback удаляет отзыв из базы данных.
func (s *BotService) DeleteFeedback(feedbackID int) error <span class="cov0" title="0">{
        query := `DELETE FROM user_feedback WHERE id = $1`

        result, err := s.DB.GetConnection().ExecContext(context.Background(), query, feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка удаления отзыва: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось получить количество удаленных строк: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errorsPkg.ErrFeedbackNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkFeedbackProcessed помечает отзыв как обработанный с ответом.
func (s *BotService) MarkFeedbackProcessed(feedbackID int, adminResponse string) error <span class="cov0" title="0">{
        err := s.DB.MarkFeedbackProcessed(feedbackID, adminResponse)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark feedback processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteAllProcessedFeedbacks удаляет все обработанные отзывы.
func (s *BotService) DeleteAllProcessedFeedbacks() (int, error) <span class="cov0" title="0">{
        query := `DELETE FROM user_feedback WHERE is_processed = true`

        result, err := s.DB.GetConnection().ExecContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("ошибка удаления обработанных отзывов: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("ошибка получения количества удаленных строк: %w", err)
        }</span>

        <span class="cov0" title="0">return int(rowsAffected), nil</span>
}

// UnarchiveFeedback возвращает отзыв в активные (убирает флаг is_processed).
func (s *BotService) UnarchiveFeedback(feedbackID int) error <span class="cov0" title="0">{
        query := `
                UPDATE user_feedback
                SET is_processed = false, updated_at = NOW()
                WHERE id = $1
        `

        result, err := s.DB.GetConnection().ExecContext(context.Background(), query, feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка возврата отзыва в активные: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка получения количества обновленных строк: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errorsPkg.ErrFeedbackNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ===== КЭШИРОВАННЫЕ МЕТОДЫ =====

// GetCachedLanguages получает языки из кэша или загружает из БД.
func (s *BotService) GetCachedLanguages(lang string) ([]*models.Language, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Пытаемся получить из кэша
        <span class="cov0" title="0">if languages, found := s.Cache.GetLanguages(context.Background(), lang); found </span><span class="cov0" title="0">{
                return languages, nil
        }</span>

        // Загружаем из БД
        <span class="cov0" title="0">languages, err := s.DB.GetLanguages()
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">s.Cache.SetLanguages(context.Background(), lang, languages)

        return languages, nil</span>
}

// GetCachedInterests получает интересы из кэша или загружает из БД.
func (s *BotService) GetCachedInterests(lang string) (map[int]string, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Пытаемся получить из кэша
        <span class="cov0" title="0">if interests, found := s.Cache.GetInterests(context.Background(), lang); found </span><span class="cov0" title="0">{
                return interests, nil
        }</span>

        // Загружаем из БД и локализуем
        <span class="cov0" title="0">interests, err := s.Localizer.GetInterests(lang)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">s.Cache.SetInterests(context.Background(), lang, interests)

        return interests, nil</span>
}

// GetCachedUser получает пользователя из кэша или загружает из БД.
func (s *BotService) GetCachedUser(telegramID int64) (*models.User, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Пытаемся получить из кэша
        <span class="cov0" title="0">if user, found := s.Cache.GetUser(context.Background(), telegramID); found </span><span class="cov0" title="0">{
                return user, nil
        }</span>

        // Загружаем из БД
        <span class="cov0" title="0">user, err := s.DB.GetUserByTelegramID(telegramID)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">s.Cache.SetUser(context.Background(), user)

        return user, nil</span>
}

// GetCachedTranslations получает переводы из кэша или загружает из файлов.
func (s *BotService) GetCachedTranslations(lang string) (map[string]string, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Пытаемся получить из кэша
        <span class="cov0" title="0">if translations, found := s.Cache.GetTranslations(context.Background(), lang); found </span><span class="cov0" title="0">{
                return translations, nil
        }</span>

        // Загружаем из файлов локализации
        // Здесь нужно будет добавить метод в Localizer для получения всех переводов
        // Пока что возвращаем пустую карту
        <span class="cov0" title="0">translations := make(map[string]string)

        // Сохраняем в кэш
        s.Cache.SetTranslations(context.Background(), lang, translations)

        return translations, nil</span>
}

// UpdateCachedUser обновляет пользователя в БД и кэше.
func (s *BotService) UpdateCachedUser(user *models.User) error <span class="cov0" title="0">{
        // Обновляем в БД
        err := s.DB.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        // Обновляем в кэше
        <span class="cov0" title="0">s.Cache.SetUser(context.Background(), user)

        return nil</span>
}

// InvalidateUserCache инвалидирует кэш пользователя.
func (s *BotService) InvalidateUserCache(userID int64) <span class="cov0" title="0">{
        s.InvalidationService.InvalidateUserData(userID)
}</span>

// InvalidateStaticDataCache инвалидирует кэш статических данных.
func (s *BotService) InvalidateStaticDataCache() <span class="cov0" title="0">{
        s.InvalidationService.InvalidateStaticData()
}</span>

// GetCacheStats возвращает статистику кэша.
func (s *BotService) GetCacheStats() map[string]interface{} <span class="cov0" title="0">{
        return s.MetricsService.GetMetrics()
}</span>

// StopCache останавливает кэш-сервис.
func (s *BotService) StopCache() <span class="cov8" title="1">{
        if s.Cache != nil </span><span class="cov0" title="0">{
                s.Cache.Stop()
        }</span>
}

// ===== BATCH LOADING МЕТОДЫ =====

// GetUserWithAllData получает пользователя со всеми связанными данными одним запросом.
// GetUserWithAllData retrieves a user with all associated data including interests,
// time availability, and friendship preferences.
//
// This method first checks the cache for the user data, and if not found or incomplete,
// loads the data from the database and caches it for future requests.
//
// Parameters:
//   - telegramID: Telegram user ID to retrieve data for
//
// Returns:
//   - *database.UserWithAllData: Complete user data including all relationships
//   - error: Any error that occurred during retrieval
//
// Example:
//
//        userData, err := service.GetUserWithAllData(123456789)
//        if err != nil {
//            log.Printf("Failed to get user data: %v", err)
//            return
//        }
//        fmt.Printf("User: %s, Interests: %v", userData.User.FirstName, userData.Interests)
func (s *BotService) GetUserWithAllData(telegramID int64) (*database.UserWithAllData, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Пытаемся получить из кэша
        <span class="cov0" title="0">if cachedUser, found := s.Cache.GetUser(context.Background(), telegramID); found </span><span class="cov0" title="0">{
                // Если пользователь есть в кэше, но нет полных данных, загружаем их
                if cachedUser != nil </span><span class="cov0" title="0">{
                        // Загружаем полные данные
                        userData, err := s.BatchLoader.GetUserWithAllData(context.Background(), telegramID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get user with all data: %w", err)
                        }</span>

                        <span class="cov0" title="0">return userData, nil</span>
                }
        }

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">userData, err := s.BatchLoader.GetUserWithAllData(context.Background(), telegramID)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">s.Cache.SetUser(context.Background(), userData.User)

        return userData, nil</span>
}

// BatchLoadUsersWithInterests загружает нескольких пользователей с их интересами одним запросом.
func (s *BotService) BatchLoadUsersWithInterests(telegramIDs []int64) (map[int64]*database.UserWithInterests, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">users, err := s.BatchLoader.BatchLoadUsersWithInterests(context.Background(), telegramIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем пользователей в кэш
        <span class="cov0" title="0">for _, userData := range users </span><span class="cov0" title="0">{
                s.Cache.SetUser(context.Background(), userData.User)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// BatchLoadInterestsWithTranslations загружает интересы с переводами для нескольких языков.
func (s *BotService) BatchLoadInterestsWithTranslations(languages []string) (map[string]map[int]string, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">interests, err := s.BatchLoader.BatchLoadInterestsWithTranslations(context.Background(), languages)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">for lang, langInterests := range interests </span><span class="cov0" title="0">{
                s.Cache.SetInterests(context.Background(), lang, langInterests)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

// BatchLoadLanguagesWithTranslations загружает языки с переводами для нескольких языков.
func (s *BotService) BatchLoadLanguagesWithTranslations(languages []string) (map[string][]*models.Language, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">langs, err := s.BatchLoader.BatchLoadLanguagesWithTranslations(context.Background(), languages)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">for lang, langList := range langs </span><span class="cov0" title="0">{
                s.Cache.SetLanguages(context.Background(), lang, langList)
        }</span>

        <span class="cov0" title="0">return langs, nil</span>
}

// BatchLoadUserInterests загружает интересы для нескольких пользователей одним запросом.
func (s *BotService) BatchLoadUserInterests(userIDs []int) (map[int][]int, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">interests, err := s.BatchLoader.BatchLoadUserInterests(context.Background(), userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

// BatchLoadUsers загружает пользователей по Telegram ID одним запросом.
func (s *BotService) BatchLoadUsers(telegramIDs []int64) (map[int64]*models.User, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">users, err := s.BatchLoader.BatchLoadUsers(context.Background(), telegramIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сохраняем в кэш
        <span class="cov0" title="0">for _, user := range users </span><span class="cov0" title="0">{
                s.Cache.SetUser(context.Background(), user)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// BatchLoadStats загружает статистику для нескольких типов одним запросом.
func (s *BotService) BatchLoadStats(statTypes []string) (map[string]map[string]interface{}, error) <span class="cov0" title="0">{
        start := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.MetricsService.RecordRequest(time.Since(start), true)
        }</span>()

        // Загружаем из БД одним запросом
        <span class="cov0" title="0">stats, err := s.BatchLoader.BatchLoadStats(statTypes)
        if err != nil </span><span class="cov0" title="0">{
                s.MetricsService.RecordError()

                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// getLanguageFlag возвращает флаг для языка.
func (s *BotService) getLanguageFlag(languageCode string) string <span class="cov0" title="0">{
        switch languageCode </span>{
        case "ru":<span class="cov0" title="0">
                return "🇷🇺"</span>
        case "en":<span class="cov0" title="0">
                return "🇺🇸"</span>
        case "es":<span class="cov0" title="0">
                return "🇪🇸"</span>
        case "zh":<span class="cov0" title="0">
                return "🇨🇳"</span>
        default:<span class="cov0" title="0">
                return "🌍"</span>
        }
}

// ===== CIRCUIT BREAKER МЕТОДЫ =====

// ExecuteWithTelegramCircuitBreaker выполняет операцию с защитой Telegram Circuit Breaker.
func (s *BotService) ExecuteWithTelegramCircuitBreaker(operation func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        if s.TelegramCircuitBreaker == nil </span><span class="cov8" title="1">{
                return operation()
        }</span>

        <span class="cov0" title="0">return s.TelegramCircuitBreaker.Execute(operation)</span>
}

// ExecuteWithDatabaseCircuitBreaker выполняет операцию с защитой Database Circuit Breaker.
func (s *BotService) ExecuteWithDatabaseCircuitBreaker(operation func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        if s.DatabaseCircuitBreaker == nil </span><span class="cov8" title="1">{
                return operation()
        }</span>

        <span class="cov0" title="0">return s.DatabaseCircuitBreaker.Execute(operation)</span>
}

// ExecuteWithRedisCircuitBreaker выполняет операцию с защитой Redis Circuit Breaker.
func (s *BotService) ExecuteWithRedisCircuitBreaker(operation func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        if s.RedisCircuitBreaker == nil </span><span class="cov8" title="1">{
                return operation()
        }</span>

        <span class="cov0" title="0">return s.RedisCircuitBreaker.Execute(operation)</span>
}

// ExecuteWithTelegramCircuitBreakerContext выполняет операцию с контекстом и защитой Telegram Circuit Breaker.
func (s *BotService) ExecuteWithTelegramCircuitBreakerContext(
        ctx context.Context,
        operation func() (interface{}, error),
) (interface{}, error) <span class="cov0" title="0">{
        if s.TelegramCircuitBreaker == nil </span><span class="cov0" title="0">{
                return operation()
        }</span>

        <span class="cov0" title="0">return s.TelegramCircuitBreaker.ExecuteWithContext(ctx, operation)</span>
}

// ExecuteWithDatabaseCircuitBreakerContext выполняет операцию с контекстом и защитой Database Circuit Breaker.
func (s *BotService) ExecuteWithDatabaseCircuitBreakerContext(ctx context.Context, operation func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        if s.DatabaseCircuitBreaker == nil </span><span class="cov0" title="0">{
                return operation()
        }</span>

        <span class="cov0" title="0">return s.DatabaseCircuitBreaker.ExecuteWithContext(ctx, operation)</span>
}

// ExecuteWithRedisCircuitBreakerContext выполняет операцию с контекстом и защитой Redis Circuit Breaker.
func (s *BotService) ExecuteWithRedisCircuitBreakerContext(ctx context.Context, operation func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        if s.RedisCircuitBreaker == nil </span><span class="cov0" title="0">{
                return operation()
        }</span>

        <span class="cov0" title="0">return s.RedisCircuitBreaker.ExecuteWithContext(ctx, operation)</span>
}

// GetCircuitBreakerStates возвращает состояния всех Circuit Breakers.
func (s *BotService) GetCircuitBreakerStates() map[string]string <span class="cov8" title="1">{
        states := make(map[string]string)

        if s.TelegramCircuitBreaker != nil </span><span class="cov0" title="0">{
                states["telegram"] = s.TelegramCircuitBreaker.State().String()
        }</span>

        <span class="cov8" title="1">if s.DatabaseCircuitBreaker != nil </span><span class="cov0" title="0">{
                states["database"] = s.DatabaseCircuitBreaker.State().String()
        }</span>

        <span class="cov8" title="1">if s.RedisCircuitBreaker != nil </span><span class="cov0" title="0">{
                states["redis"] = s.RedisCircuitBreaker.State().String()
        }</span>

        <span class="cov8" title="1">return states</span>
}

// GetCircuitBreakerCounts возвращает счетчики всех Circuit Breakers.
func (s *BotService) GetCircuitBreakerCounts() map[string]interface{} <span class="cov8" title="1">{
        counts := make(map[string]interface{})

        if s.TelegramCircuitBreaker != nil </span><span class="cov0" title="0">{
                counts["telegram"] = s.TelegramCircuitBreaker.Counts()
        }</span>

        <span class="cov8" title="1">if s.DatabaseCircuitBreaker != nil </span><span class="cov0" title="0">{
                counts["database"] = s.DatabaseCircuitBreaker.Counts()
        }</span>

        <span class="cov8" title="1">if s.RedisCircuitBreaker != nil </span><span class="cov0" title="0">{
                counts["redis"] = s.RedisCircuitBreaker.Counts()
        }</span>

        <span class="cov8" title="1">return counts</span>
}

// GetConfig возвращает конфигурацию приложения
func (s *BotService) GetConfig() *config.Config <span class="cov8" title="1">{
        return s.Config
}</span>

// === Методы databaseAdapter для работы с доступностью ===

// SaveTimeAvailability сохраняет временную доступность пользователя
func (a *databaseAdapter) SaveTimeAvailability(userID int, availability *models.TimeAvailability) error <span class="cov0" title="0">{
        return a.db.SaveTimeAvailability(userID, availability)
}</span>

// GetTimeAvailability получает временную доступность пользователя
func (a *databaseAdapter) GetTimeAvailability(userID int) (*models.TimeAvailability, error) <span class="cov0" title="0">{
        return a.db.GetTimeAvailability(userID)
}</span>

// SaveFriendshipPreferences сохраняет предпочтения общения пользователя
func (a *databaseAdapter) SaveFriendshipPreferences(userID int, preferences *models.FriendshipPreferences) error <span class="cov0" title="0">{
        return a.db.SaveFriendshipPreferences(userID, preferences)
}</span>

// GetFriendshipPreferences получает предпочтения общения пользователя
func (a *databaseAdapter) GetFriendshipPreferences(userID int) (*models.FriendshipPreferences, error) <span class="cov0" title="0">{
        return a.db.GetFriendshipPreferences(userID)
}</span>

// DataLoader implementation для cache warming

// LoadLanguages loads all available languages from the database.
// This method is used by the cache warming process to pre-load language data.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout
//   - lang: Interface language code (currently not used, but kept for interface compatibility)
//
// Returns:
//   - []*models.Language: Slice of all available languages
//   - error: Any error that occurred during loading
//
// Example:
//
//        languages, err := service.LoadLanguages(ctx, "en")
//        if err != nil {
//            return fmt.Errorf("failed to load languages: %w", err)
//        }
//        for _, lang := range languages {
//            fmt.Printf("Language: %s (%s)", lang.NameEn, lang.Code)
//        }
func (s *BotService) LoadLanguages(ctx context.Context, lang string) ([]*models.Language, error) <span class="cov0" title="0">{
        return s.DB.GetLanguages()
}</span>

// LoadInterests loads all available interests from the database.
// This method is used by the cache warming process to pre-load interest data.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout
//   - lang: Interface language code (currently not used, but kept for interface compatibility)
//
// Returns:
//   - map[int]string: Map of interest ID to interest name
//   - error: Any error that occurred during loading
//
// Example:
//
//        interests, err := service.LoadInterests(ctx, "en")
//        if err != nil {
//            return fmt.Errorf("failed to load interests: %w", err)
//        }
//        for id, name := range interests {
//            fmt.Printf("Interest %d: %s", id, name)
//        }
func (s *BotService) LoadInterests(ctx context.Context, lang string) (map[int]string, error) <span class="cov0" title="0">{
        interests, err := s.DB.GetInterests()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Преобразуем в map[int]string
        <span class="cov0" title="0">result := make(map[int]string)
        for _, interest := range interests </span><span class="cov0" title="0">{
                result[interest.ID] = interest.KeyName
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// LoadInterestCategories загружает категории интересов для указанного языка интерфейса.
func (s *BotService) LoadInterestCategories(ctx context.Context, lang string) (map[int]string, error) <span class="cov0" title="0">{
        // Пока возвращаем пустую карту, так как категории интересов еще не реализованы
        return make(map[int]string), nil
}</span>

// LoadTranslations загружает переводы для указанного языка интерфейса.
func (s *BotService) LoadTranslations(ctx context.Context, lang string) (map[string]string, error) <span class="cov0" title="0">{
        // Пока возвращаем пустую карту, так как система переводов еще не реализована
        return make(map[string]string), nil
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package core

import (
        "fmt"
        "language-exchange-bot/internal/database"
        "language-exchange-bot/internal/models"
)

// UserService обрабатывает операции с пользователями.
type UserService struct {
        db *database.DB
}

// NewUserService создает новый экземпляр UserService.
func NewUserService(db *database.DB) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                db: db,
        }
}</span>

// FindOrCreateUser находит или создает пользователя по Telegram ID.
func (s *UserService) FindOrCreateUser(telegramID int64, username, firstName string) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.db.FindOrCreateUser(telegramID, username, firstName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find or create user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// UpdateUserState обновляет состояние пользователя.
func (s *UserService) UpdateUserState(userID int, state string) error <span class="cov0" title="0">{
        err := s.db.UpdateUserState(userID, state)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user state: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserStatus обновляет статус пользователя.
func (s *UserService) UpdateUserStatus(userID int, status string) error <span class="cov0" title="0">{
        err := s.db.UpdateUserStatus(userID, status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SaveLanguages сохраняет выбранные пользователем языки.
func (s *UserService) SaveLanguages(userID int, nativeLang, targetLang string) error <span class="cov0" title="0">{
        err := s.db.SaveNativeLanguage(userID, nativeLang)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.db.SaveTargetLanguage(userID, targetLang); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save target language: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SaveInterest сохраняет интерес пользователя.
func (s *UserService) SaveInterest(userID, interestID int, isMain bool) error <span class="cov0" title="0">{
        err := s.db.SaveUserInterest(userID, interestID, isMain)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save user interest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "strings"
        "time"

        errorsPkg "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/logging"
        "language-exchange-bot/internal/models"
)

// Константы для BatchLoader.

// BatchLoader оптимизирует загрузку данных для предотвращения N+1 запросов.
type BatchLoader struct {
        db           *DB
        logger       *logging.DatabaseLogger
        errorHandler *errorsPkg.ErrorHandler
}

// NewBatchLoader создает новый экземпляр BatchLoader.
func NewBatchLoader(db *DB) *BatchLoader <span class="cov8" title="1">{
        return &amp;BatchLoader{
                db:           db,
                logger:       logging.NewDatabaseLogger(),
                errorHandler: errorsPkg.NewErrorHandler(nil),
        }
}</span>

// handleRowsError обрабатывает ошибки rows с правильным закрытием.
func (bl *BatchLoader) handleRowsError(rows *sql.Rows, operation string) error <span class="cov8" title="1">{
        if rows == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close rows after error in %s: %w (original error: %w)", operation, closeErr, err)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("rows error in %s: %w", operation, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// closeRowsSafely безопасно закрывает rows с логированием ошибок.
func (bl *BatchLoader) closeRowsSafely(rows *sql.Rows, operation string) <span class="cov8" title="1">{
        if rows == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to close rows in %s: %v", operation, closeErr)
        }</span>
}

// UserWithInterests представляет пользователя с его интересами.
type UserWithInterests struct {
        *models.User

        Interests []int
}

// UserWithAllData представляет пользователя со всеми связанными данными.
type UserWithAllData struct {
        *models.User

        Interests    []int
        Translations map[int]string
        Languages    []*models.Language
}

// BatchLoadUsersWithInterests загружает пользователей с их интересами одним запросом.
func (bl *BatchLoader) BatchLoadUsersWithInterests(
        ctx context.Context,
        telegramIDs []int64,
) (map[int64]*UserWithInterests, error) <span class="cov8" title="1">{
        if len(telegramIDs) == 0 </span><span class="cov8" title="1">{
                return make(map[int64]*UserWithInterests), nil
        }</span>

        <span class="cov8" title="1">query := getBatchLoadUsersWithInterestsQuery()

        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        rows, err := bl.db.conn.QueryContext(ctx, query, telegramIDs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to batch load users with interests: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bl.handleRowsError(rows, "BatchLoadUsersWithInterests"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadUsersWithInterests")

        return bl.processUsersWithInterestsRows(rows), nil</span>
}

// getBatchLoadUsersWithInterestsQuery возвращает SQL запрос для загрузки пользователей с интересами.
func getBatchLoadUsersWithInterestsQuery() string <span class="cov8" title="1">{
        return `
                SELECT 
                        u.id, u.telegram_id, u.username, u.first_name,
                        COALESCE(u.native_language_code, '') as native_language_code,
                        COALESCE(u.target_language_code, '') as target_language_code,
                        COALESCE(u.target_language_level, '') as target_language_level,
                        u.interface_language_code, u.created_at, u.updated_at, u.state,
                        u.profile_completion_level, u.status,
                        ui.interest_id
                FROM users u
                LEFT JOIN user_interests ui ON u.id = ui.user_id
                WHERE u.telegram_id = ANY($1)
                ORDER BY u.id, ui.interest_id
        `
}</span>

// processUsersWithInterestsRows обрабатывает строки результата запроса пользователей с интересами.
func (bl *BatchLoader) processUsersWithInterestsRows(rows *sql.Rows) map[int64]*UserWithInterests <span class="cov0" title="0">{
        users := make(map[int64]*UserWithInterests)

        for rows.Next() </span><span class="cov0" title="0">{
                user, interestID, err := bl.scanUserWithInterestRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning user row: %v", err)

                        continue</span>
                }

                // Если пользователь еще не в мапе, создаем его
                <span class="cov0" title="0">if _, exists := users[user.TelegramID]; !exists </span><span class="cov0" title="0">{
                        users[user.TelegramID] = &amp;UserWithInterests{
                                User:      &amp;user,
                                Interests: make([]int, 0),
                        }
                }</span>

                // Добавляем интерес, если он есть
                <span class="cov0" title="0">if interestID.Valid </span><span class="cov0" title="0">{
                        users[user.TelegramID].Interests = append(users[user.TelegramID].Interests, int(interestID.Int64))
                }</span>
        }

        <span class="cov0" title="0">return users</span>
}

// scanUserWithInterestRow сканирует одну строку результата запроса пользователя с интересом.
func (bl *BatchLoader) scanUserWithInterestRow(rows *sql.Rows) (models.User, sql.NullInt64, error) <span class="cov8" title="1">{
        var (
                user       models.User
                interestID sql.NullInt64
        )

        err := rows.Scan(
                &amp;user.ID, &amp;user.TelegramID, &amp;user.Username, &amp;user.FirstName,
                &amp;user.NativeLanguageCode, &amp;user.TargetLanguageCode, &amp;user.TargetLanguageLevel,
                &amp;user.InterfaceLanguageCode, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;user.State, &amp;user.ProfileCompletionLevel, &amp;user.Status,
                &amp;interestID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return user, interestID, fmt.Errorf("failed to scan user row: %w", err)
        }</span>

        <span class="cov8" title="1">return user, interestID, nil</span>
}

// BatchLoadInterestsWithTranslations загружает интересы с переводами для нескольких языков.
func (bl *BatchLoader) BatchLoadInterestsWithTranslations(ctx context.Context, languages []string) (map[string]map[int]string, error) <span class="cov0" title="0">{
        if len(languages) == 0 </span><span class="cov0" title="0">{
                return make(map[string]map[int]string), nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        it.language_code,
                        i.id,
                        CASE
                                WHEN it.name IS NOT NULL AND TRIM(it.name) != '' THEN it.name
                                ELSE i.key_name
                        END as name
                FROM interests i
                LEFT JOIN interest_translations it ON i.id = it.interest_id AND it.language_code = ANY($1)
                ORDER BY i.id, it.language_code
        `

        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        rows, err := bl.db.conn.QueryContext(ctx, query, languages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to batch load interests with translations: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bl.handleRowsError(rows, "BatchLoadInterestsWithTranslations"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = rows.Close() }</span>()
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadInterestsWithTranslations")

        interests := make(map[string]map[int]string)

        for rows.Next() </span><span class="cov0" title="0">{
                var langCode string

                var interestID int

                var name string

                err := rows.Scan(&amp;langCode, &amp;interestID, &amp;name)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning interest row: %v", err)

                        continue</span>
                }

                <span class="cov0" title="0">if interests[langCode] == nil </span><span class="cov0" title="0">{
                        interests[langCode] = make(map[int]string)
                }</span>

                <span class="cov0" title="0">interests[langCode][interestID] = name</span>
        }

        <span class="cov0" title="0">return interests, nil</span>
}

// BatchLoadLanguagesWithTranslations загружает языки с переводами для нескольких языков.
func (bl *BatchLoader) BatchLoadLanguagesWithTranslations(ctx context.Context, languages []string) (map[string][]*models.Language, error) <span class="cov0" title="0">{
        if len(languages) == 0 </span><span class="cov0" title="0">{
                return make(map[string][]*models.Language), nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        lt.language_code,
                        l.id, l.code, l.name_native, l.name_en
                FROM languages l
                LEFT JOIN language_translations lt ON l.id = lt.language_id AND lt.language_code = ANY($1)
                ORDER BY l.id, lt.language_code
        `

        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        rows, err := bl.db.conn.QueryContext(ctx, query, languages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to batch load languages with translations: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bl.handleRowsError(rows, "BatchLoadLanguagesWithTranslations"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = rows.Close() }</span>()
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadLanguagesWithTranslations")

        langs := make(map[string][]*models.Language)

        for rows.Next() </span><span class="cov0" title="0">{
                var langCode string

                var lang models.Language

                err := rows.Scan(&amp;langCode, &amp;lang.ID, &amp;lang.Code, &amp;lang.NameNative, &amp;lang.NameEn)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning language row: %v", err)

                        continue</span>
                }

                <span class="cov0" title="0">if langs[langCode] == nil </span><span class="cov0" title="0">{
                        langs[langCode] = make([]*models.Language, 0)
                }</span>

                <span class="cov0" title="0">langs[langCode] = append(langs[langCode], &amp;lang)</span>
        }

        <span class="cov0" title="0">return langs, nil</span>
}

// BatchLoadUserInterests загружает интересы для нескольких пользователей одним запросом.
func (bl *BatchLoader) BatchLoadUserInterests(ctx context.Context, userIDs []int) (map[int][]int, error) <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[int][]int), nil
        }</span>

        // Создаем placeholders для SQLite: ?, ?, ?
        <span class="cov0" title="0">placeholders := make([]string, len(userIDs))
        args := make([]interface{}, len(userIDs))
        for i, id := range userIDs </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                args[i] = id
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT user_id, interest_id
                FROM user_interests
                WHERE user_id IN (%s)
                ORDER BY user_id, interest_id
        `, strings.Join(placeholders, ","))

        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        rows, err := bl.db.conn.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to batch load user interests: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bl.handleRowsError(rows, "BatchLoadUserInterests"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = rows.Close() }</span>()
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadUserInterests")

        interests := make(map[int][]int)

        for rows.Next() </span><span class="cov0" title="0">{
                var userID, interestID int

                err := rows.Scan(&amp;userID, &amp;interestID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning user interest row: %v", err)

                        continue</span>
                }

                <span class="cov0" title="0">if interests[userID] == nil </span><span class="cov0" title="0">{
                        interests[userID] = make([]int, 0)
                }</span>

                <span class="cov0" title="0">interests[userID] = append(interests[userID], interestID)</span>
        }

        <span class="cov0" title="0">return interests, nil</span>
}

// BatchLoadUsers загружает пользователей по Telegram ID одним запросом.
func (bl *BatchLoader) BatchLoadUsers(ctx context.Context, telegramIDs []int64) (map[int64]*models.User, error) <span class="cov0" title="0">{
        if len(telegramIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]*models.User), nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, telegram_id, username, first_name,
                       COALESCE(native_language_code, '') as native_language_code,
                       COALESCE(target_language_code, '') as target_language_code,
                       COALESCE(target_language_level, '') as target_language_level,
                       interface_language_code, created_at, updated_at, state,
                       profile_completion_level, status
                FROM users
                WHERE telegram_id = ANY($1)
        `

        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        rows, err := bl.db.conn.QueryContext(ctx, query, telegramIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to batch load users: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bl.handleRowsError(rows, "BatchLoadUsers"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = rows.Close() }</span>()
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadUsers")

        users := make(map[int64]*models.User)

        for rows.Next() </span><span class="cov0" title="0">{
                var user models.User

                err := rows.Scan(
                        &amp;user.ID, &amp;user.TelegramID, &amp;user.Username, &amp;user.FirstName,
                        &amp;user.NativeLanguageCode, &amp;user.TargetLanguageCode, &amp;user.TargetLanguageLevel,
                        &amp;user.InterfaceLanguageCode, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                        &amp;user.State, &amp;user.ProfileCompletionLevel, &amp;user.Status,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning user row: %v", err)

                        continue</span>
                }

                <span class="cov0" title="0">users[user.TelegramID] = &amp;user</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

// GetUserWithAllData загружает пользователя со всеми связанными данными одним запросом.
func (bl *BatchLoader) GetUserWithAllData(ctx context.Context, telegramID int64) (*UserWithAllData, error) <span class="cov0" title="0">{
        query := getUserWithAllDataQuery()

        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        rows, err := bl.db.conn.QueryContext(ctx, query, telegramID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user with all data: %w", err)
        }</span>

        <span class="cov0" title="0">if err := bl.handleRowsError(rows, "GetUserWithAllData"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "GetUserWithAllData")

        userData, interests, translations, languages := bl.processUserDataRows(rows)

        if userData == nil </span><span class="cov0" title="0">{
                return nil, errorsPkg.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">userData.Interests = interests
        userData.Translations = translations
        userData.Languages = languages

        return userData, nil</span>
}

// getUserWithAllDataQuery возвращает SQL запрос для получения пользователя со всеми данными.
func getUserWithAllDataQuery() string <span class="cov0" title="0">{
        return `
                SELECT 
                        u.id, u.telegram_id, u.username, u.first_name,
                        COALESCE(u.native_language_code, '') as native_language_code,
                        COALESCE(u.target_language_code, '') as target_language_code,
                        COALESCE(u.target_language_level, '') as target_language_level,
                        u.interface_language_code, u.created_at, u.updated_at, u.state,
                        u.profile_completion_level, u.status,
                        ui.interest_id,
                        it.name as interest_name,
                        l.id as lang_id, l.code as lang_code, l.name_native, l.name_en
                FROM users u
                LEFT JOIN user_interests ui ON u.id = ui.user_id
                LEFT JOIN interest_translations it ON ui.interest_id = it.interest_id 
                        AND it.language_code = u.interface_language_code
                LEFT JOIN languages l ON l.code = u.interface_language_code
                WHERE u.telegram_id = $1
                ORDER BY ui.interest_id
        `
}</span>

// processUserDataRows обрабатывает строки результата запроса.
func (bl *BatchLoader) processUserDataRows(
        rows *sql.Rows,
) (*UserWithAllData, []int, map[int]string, []*models.Language) <span class="cov0" title="0">{
        var userData *UserWithAllData

        interests := make([]int, 0)
        translations := make(map[int]string)
        languages := make([]*models.Language, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                user, interestID, interestName, langID, langCode, langNameNative, langNameEn, err := bl.scanUserDataRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning user data row: %v", err)

                        continue</span>
                }

                // Инициализируем userData только один раз
                <span class="cov0" title="0">if userData == nil </span><span class="cov0" title="0">{
                        userData = &amp;UserWithAllData{
                                User:         &amp;user,
                                Interests:    make([]int, 0),
                                Translations: make(map[int]string),
                                Languages:    make([]*models.Language, 0),
                        }
                }</span>

                // Добавляем интерес, если он есть
                <span class="cov0" title="0">if interestID.Valid </span><span class="cov0" title="0">{
                        interests = append(interests, int(interestID.Int64))
                        if interestName.Valid </span><span class="cov0" title="0">{
                                translations[int(interestID.Int64)] = interestName.String
                        }</span>
                }

                // Добавляем язык, если он есть
                <span class="cov0" title="0">if langID.Valid &amp;&amp; langCode.Valid </span><span class="cov0" title="0">{
                        lang := &amp;models.Language{
                                ID:                  int(langID.Int64),
                                Code:                langCode.String,
                                NameNative:          langNameNative.String,
                                NameEn:              langNameEn.String,
                                IsInterfaceLanguage: false,
                                CreatedAt:           time.Now(),
                        }
                        languages = append(languages, lang)
                }</span>
        }

        <span class="cov0" title="0">return userData, interests, translations, languages</span>
}

// scanUserDataRow сканирует одну строку результата запроса.
func (bl *BatchLoader) scanUserDataRow(
        rows *sql.Rows,
) (models.User, sql.NullInt64, sql.NullString, sql.NullInt64, sql.NullString, sql.NullString, sql.NullString, error) <span class="cov0" title="0">{
        var (
                user                                 models.User
                interestID                           sql.NullInt64
                interestName                         sql.NullString
                langID                               sql.NullInt64
                langCode, langNameNative, langNameEn sql.NullString
        )

        err := rows.Scan(
                &amp;user.ID, &amp;user.TelegramID, &amp;user.Username, &amp;user.FirstName,
                &amp;user.NativeLanguageCode, &amp;user.TargetLanguageCode, &amp;user.TargetLanguageLevel,
                &amp;user.InterfaceLanguageCode, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;user.State, &amp;user.ProfileCompletionLevel, &amp;user.Status,
                &amp;interestID, &amp;interestName,
                &amp;langID, &amp;langCode, &amp;langNameNative, &amp;langNameEn,
        )

        return user, interestID, interestName, langID, langCode, langNameNative, langNameEn,
                fmt.Errorf("operation failed: %w", err)
}</span>

// BatchLoadStats загружает статистику для нескольких типов одним запросом.
func (bl *BatchLoader) BatchLoadStats(statTypes []string) (map[string]map[string]interface{}, error) <span class="cov0" title="0">{
        if len(statTypes) == 0 </span><span class="cov0" title="0">{
                return make(map[string]map[string]interface{}), nil
        }</span>

        <span class="cov0" title="0">stats := make(map[string]map[string]interface{})

        for _, statType := range statTypes </span><span class="cov0" title="0">{
                switch statType </span>{
                case "users":<span class="cov0" title="0">
                        stats[statType] = bl.loadUserStats()</span>
                case "interests":<span class="cov0" title="0">
                        stats[statType] = bl.loadInterestStats()</span>
                case "feedbacks":<span class="cov0" title="0">
                        stats[statType] = bl.loadFeedbackStats()</span>
                }
        }

        <span class="cov0" title="0">return stats, nil</span>
}

func (bl *BatchLoader) loadUserStats() map[string]interface{} <span class="cov0" title="0">{
        var totalUsers, activeUsers int

        err := bl.db.conn.QueryRowContext(context.Background(), "SELECT COUNT(*) FROM users").Scan(&amp;totalUsers)
        if err != nil </span><span class="cov0" title="0">{
                bl.logger.ErrorWithContext(
                        "Failed to get total users count",
                        "", 0, 0, "LoadUserStats",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">query := "SELECT COUNT(*) FROM users WHERE status = 'active'"

        err = bl.db.conn.QueryRowContext(context.Background(), query).Scan(&amp;activeUsers)
        if err != nil </span><span class="cov0" title="0">{
                bl.logger.ErrorWithContext(
                        "Failed to get active users count",
                        "", 0, 0, "LoadUserStats",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_users":  totalUsers,
                "active_users": activeUsers,
                "timestamp":    time.Now(),
        }</span>
}

func (bl *BatchLoader) loadInterestStats() map[string]interface{} <span class="cov0" title="0">{
        var totalInterests, popularInterests int

        err := bl.db.conn.QueryRowContext(context.Background(), "SELECT COUNT(*) FROM interests").Scan(&amp;totalInterests)
        if err != nil </span><span class="cov0" title="0">{
                bl.logger.ErrorWithContext(
                        "Failed to get total interests count",
                        "", 0, 0, "LoadInterestStats",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">err = bl.db.conn.QueryRowContext(context.Background(), `
                SELECT COUNT(*) FROM user_interests ui 
                JOIN interests i ON ui.interest_id = i.id 
                GROUP BY ui.interest_id 
                ORDER BY COUNT(*) DESC 
                LIMIT 1
        `).Scan(&amp;popularInterests)
        if err != nil </span><span class="cov0" title="0">{
                bl.logger.ErrorWithContext(
                        "Failed to get popular interests count",
                        "", 0, 0, "LoadInterestStats",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_interests":   totalInterests,
                "popular_interests": popularInterests,
                "timestamp":         time.Now(),
        }</span>
}

func (bl *BatchLoader) loadFeedbackStats() map[string]interface{} <span class="cov0" title="0">{
        var totalFeedbacks, processedFeedbacks int

        err := bl.db.conn.QueryRowContext(context.Background(), "SELECT COUNT(*) FROM user_feedback").Scan(&amp;totalFeedbacks)
        if err != nil </span><span class="cov0" title="0">{
                bl.logger.ErrorWithContext(
                        "Failed to get total feedbacks count",
                        "", 0, 0, "LoadFeedbackStats",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">query := "SELECT COUNT(*) FROM user_feedback WHERE is_processed = true"

        err = bl.db.conn.QueryRowContext(context.Background(), query).Scan(&amp;processedFeedbacks)
        if err != nil </span><span class="cov0" title="0">{
                bl.logger.ErrorWithContext(
                        "Failed to get processed feedbacks count",
                        "", 0, 0, "LoadFeedbackStats",
                        map[string]interface{}{
                                "error": err.Error(),
                        },
                )
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_feedbacks":     totalFeedbacks,
                "processed_feedbacks": processedFeedbacks,
                "timestamp":           time.Now(),
        }</span>
}

// ===== НОВЫЕ МЕТОДЫ БАТЧИНГА =====

// BatchUpdateUserInterests обновляет интересы пользователя батчем.
func (bl *BatchLoader) BatchUpdateUserInterests(ctx context.Context, userID int, interests []int, primaryInterests []int) error <span class="cov0" title="0">{
        if len(interests) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Создаем контекст с таймаутом если не передан
        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        // Начинаем транзакцию
        tx, err := bl.db.conn.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = tx.Rollback() }</span>()

        // Удаляем старые интересы
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, "DELETE FROM user_interest_selections WHERE user_id = $1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete old interests: %w", err)
        }</span>

        // Подготавливаем данные для вставки
        <span class="cov0" title="0">stmt, err := tx.PrepareContext(ctx, `
                INSERT INTO user_interest_selections (user_id, interest_id, is_primary, created_at)
                VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := stmt.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        bl.logger.Error("Failed to close prepared statement in batch loader", map[string]interface{}{
                                "error":     closeErr.Error(),
                                "operation": "BatchUpdateUserInterests",
                        })
                }</span>
        }()

        // Вставляем новые интересы
        <span class="cov0" title="0">for _, interestID := range interests </span><span class="cov0" title="0">{
                isPrimary := false
                for _, primaryID := range primaryInterests </span><span class="cov0" title="0">{
                        if interestID == primaryID </span><span class="cov0" title="0">{
                                isPrimary = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, userID, interestID, isPrimary)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert interest %d: %w", interestID, err)
                }</span>
        }

        // Коммитим транзакцию
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">bl.logger.InfoWithContext(
                "Batch updated user interests",
                "", int64(userID), 0, "BatchUpdateUserInterests",
                map[string]interface{}{
                        "user_id":         userID,
                        "interests_count": len(interests),
                        "primary_count":   len(primaryInterests),
                },
        )

        return nil</span>
}

// BatchLoadInterestCategories загружает категории интересов батчем.
func (bl *BatchLoader) BatchLoadInterestCategories(ctx context.Context, lang string) ([]*models.InterestCategory, error) <span class="cov0" title="0">{
        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        query := `
                SELECT ic.id, ic.key_name, ic.display_order,
                       COALESCE(ict.name, ic.key_name) as name,
                       COALESCE(ict.description, '') as description
                FROM interest_categories ic
                LEFT JOIN interest_category_translations ict ON ic.id = ict.category_id 
                        AND ict.language_code = $1
                ORDER BY ic.display_order, ic.id
        `

        rows, err := bl.db.conn.QueryContext(ctx, query, lang)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load interest categories: %w", err)
        }</span>
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadInterestCategories")

        var categories []*models.InterestCategory
        for rows.Next() </span><span class="cov0" title="0">{
                var category models.InterestCategory
                err := rows.Scan(
                        &amp;category.ID,
                        &amp;category.KeyName,
                        &amp;category.DisplayOrder,
                        &amp;category.Name,
                        &amp;category.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning interest category row: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">categories = append(categories, &amp;category)</span>
        }

        <span class="cov0" title="0">return categories, nil</span>
}

// BatchLoadUserStatistics загружает статистику пользователей батчем.
func (bl *BatchLoader) BatchLoadUserStatistics(ctx context.Context, userIDs []int64) (map[int64]map[string]interface{}, error) <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]map[string]interface{}), nil
        }</span>

        // Создаем контекст с таймаутом если не передан
        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        query := `
                SELECT 
                        u.telegram_id,
                        COUNT(DISTINCT ui.interest_id) as interests_count,
                        COUNT(DISTINCT CASE WHEN ui.is_primary = true THEN ui.interest_id END) as primary_interests_count,
                        u.profile_completion_level,
                        u.status,
                        u.created_at
                FROM users u
                LEFT JOIN user_interest_selections ui ON u.id = ui.user_id
                WHERE u.telegram_id = ANY($1)
                GROUP BY u.telegram_id, u.profile_completion_level, u.status, u.created_at
        `

        rows, err := bl.db.conn.QueryContext(ctx, query, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load user statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadUserStatistics")

        stats := make(map[int64]map[string]interface{})
        for rows.Next() </span><span class="cov0" title="0">{
                var telegramID int64
                var interestsCount, primaryInterestsCount int
                var profileCompletionLevel, status string
                var createdAt time.Time

                err := rows.Scan(
                        &amp;telegramID,
                        &amp;interestsCount,
                        &amp;primaryInterestsCount,
                        &amp;profileCompletionLevel,
                        &amp;status,
                        &amp;createdAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning user statistics row: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">stats[telegramID] = map[string]interface{}{
                        "interests_count":          interestsCount,
                        "primary_interests_count":  primaryInterestsCount,
                        "profile_completion_level": profileCompletionLevel,
                        "status":                   status,
                        "created_at":               createdAt,
                        "timestamp":                time.Now(),
                }</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

// BatchLoadPopularInterests загружает популярные интересы батчем.
func (bl *BatchLoader) BatchLoadPopularInterests(ctx context.Context, limit int) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Создаем контекст с таймаутом если не передан
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, localization.DefaultQueryTimeout)
        defer cancel()

        query := `
                SELECT 
                        i.id, i.key_name,
                        COUNT(ui.user_id) as user_count,
                        COUNT(CASE WHEN ui.is_primary = true THEN 1 END) as primary_count
                FROM interests i
                LEFT JOIN user_interest_selections ui ON i.id = ui.interest_id
                GROUP BY i.id, i.key_name
                ORDER BY user_count DESC, primary_count DESC
                LIMIT $1
        `

        rows, err := bl.db.conn.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load popular interests: %w", err)
        }</span>
        <span class="cov0" title="0">defer bl.closeRowsSafely(rows, "BatchLoadPopularInterests")

        var interests []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id int
                var keyName string
                var userCount, primaryCount int

                err := rows.Scan(&amp;id, &amp;keyName, &amp;userCount, &amp;primaryCount)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning popular interest row: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">interests = append(interests, map[string]interface{}{
                        "id":            id,
                        "key_name":      keyName,
                        "user_count":    userCount,
                        "primary_count": primaryCount,
                })</span>
        }

        <span class="cov0" title="0">return interests, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package database

import (
        "context"
        "fmt"
        "language-exchange-bot/internal/models"
        "log"
        "strings"
        "time"
)

// BatchOperations предоставляет методы для массовых операций с базой данных.
type BatchOperations struct {
        db *DB
}

// NewBatchOperations создает новый экземпляр BatchOperations.
func NewBatchOperations(db *DB) *BatchOperations <span class="cov0" title="0">{
        return &amp;BatchOperations{db: db}
}</span>

// BatchInsertUsers выполняет массовую вставку пользователей.
func (bo *BatchOperations) BatchInsertUsers(ctx context.Context, users []*models.User) error <span class="cov0" title="0">{
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Используем COPY для максимальной производительности
        <span class="cov0" title="0">query := `
                COPY users (telegram_id, username, first_name, native_language_code, 
                           target_language_code, target_language_level, interface_language_code, 
                           state, status, profile_completion_level, created_at, updated_at)
                FROM STDIN WITH (FORMAT csv, HEADER false)`

        tx, err := bo.db.conn.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to rollback transaction in BatchInsertUsers: %v", rollbackErr)
                }</span>
        }()

        <span class="cov0" title="0">stmt, err := tx.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := stmt.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to close prepared statement in BatchInsertUsers: %v", closeErr)
                }</span>
        }()

        // Подготавливаем данные для COPY
        <span class="cov0" title="0">var rows []string
        for _, user := range users </span><span class="cov0" title="0">{
                row := fmt.Sprintf("%d,%s,%s,%s,%s,%s,%s,%s,%s,%d,%s,%s",
                        user.TelegramID,
                        escapeCSV(user.Username),
                        escapeCSV(user.FirstName),
                        escapeCSV(user.NativeLanguageCode),
                        escapeCSV(user.TargetLanguageCode),
                        escapeCSV(user.TargetLanguageLevel),
                        escapeCSV(user.InterfaceLanguageCode),
                        escapeCSV(user.State),
                        escapeCSV(user.Status),
                        user.ProfileCompletionLevel,
                        user.CreatedAt.Format(time.RFC3339),
                        user.UpdatedAt.Format(time.RFC3339),
                )
                rows = append(rows, row)
        }</span>

        // Выполняем COPY операцию
        <span class="cov0" title="0">_, err = stmt.ExecContext(ctx, strings.Join(rows, "\n"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute COPY: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch inserted %d users", len(users))
        return nil</span>
}

// BatchUpdateUsers выполняет массовое обновление пользователей.
func (bo *BatchOperations) BatchUpdateUsers(ctx context.Context, users []*models.User) error <span class="cov0" title="0">{
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Используем VALUES для массового обновления
        <span class="cov0" title="0">query := `
                UPDATE users SET 
                        username = data.username,
                        first_name = data.first_name,
                        native_language_code = data.native_language_code,
                        target_language_code = data.target_language_code,
                        target_language_level = data.target_language_level,
                        interface_language_code = data.interface_language_code,
                        state = data.state,
                        status = data.status,
                        profile_completion_level = data.profile_completion_level,
                        updated_at = data.updated_at
                FROM (VALUES %s) AS data(id, username, first_name, native_language_code, 
                                        target_language_code, target_language_level, 
                                        interface_language_code, state, status, 
                                        profile_completion_level, updated_at)
                WHERE users.id = data.id`

        // Подготавливаем VALUES
        var values []string
        for _, user := range users </span><span class="cov0" title="0">{
                value := fmt.Sprintf("(%d, %s, %s, %s, %s, %s, %s, %s, %s, %d, %s)",
                        user.ID,
                        escapeSQL(user.Username),
                        escapeSQL(user.FirstName),
                        escapeSQL(user.NativeLanguageCode),
                        escapeSQL(user.TargetLanguageCode),
                        escapeSQL(user.TargetLanguageLevel),
                        escapeSQL(user.InterfaceLanguageCode),
                        escapeSQL(user.State),
                        escapeSQL(user.Status),
                        user.ProfileCompletionLevel,
                        escapeSQL(user.UpdatedAt.Format(time.RFC3339)),
                )
                values = append(values, value)
        }</span>

        // Выполняем обновление
        <span class="cov0" title="0">finalQuery := fmt.Sprintf(query, strings.Join(values, ","))
        _, err := bo.db.conn.ExecContext(ctx, finalQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch update: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch updated %d users", len(users))
        return nil</span>
}

// BatchInsertInterests выполняет массовую вставку интересов.
func (bo *BatchOperations) BatchInsertInterests(ctx context.Context, interests []*models.Interest) error <span class="cov0" title="0">{
        if len(interests) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO interests (key_name, category_id, display_order, type, created_at)
                VALUES %s
                ON CONFLICT (key_name) DO NOTHING`

        // Подготавливаем VALUES
        var values []string
        for _, interest := range interests </span><span class="cov0" title="0">{
                value := fmt.Sprintf("(%s, %d, %d, %s, %s)",
                        escapeSQL(interest.KeyName),
                        interest.CategoryID,
                        interest.DisplayOrder,
                        escapeSQL(interest.Type),
                        escapeSQL(interest.CreatedAt.Format(time.RFC3339)),
                )
                values = append(values, value)
        }</span>

        <span class="cov0" title="0">finalQuery := fmt.Sprintf(query, strings.Join(values, ","))
        _, err := bo.db.conn.ExecContext(ctx, finalQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch insert interests: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch inserted %d interests", len(interests))
        return nil</span>
}

// BatchInsertUserInterests выполняет массовую вставку связей пользователь-интерес.
func (bo *BatchOperations) BatchInsertUserInterests(ctx context.Context, userID int, interestIDs []int) error <span class="cov0" title="0">{
        if len(interestIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO user_interests (user_id, interest_id, created_at)
                VALUES %s
                ON CONFLICT (user_id, interest_id) DO NOTHING`

        // Подготавливаем VALUES
        var values []string
        now := time.Now().Format(time.RFC3339)
        for _, interestID := range interestIDs </span><span class="cov0" title="0">{
                value := fmt.Sprintf("(%d, %d, %s)",
                        userID,
                        interestID,
                        escapeSQL(now),
                )
                values = append(values, value)
        }</span>

        <span class="cov0" title="0">finalQuery := fmt.Sprintf(query, strings.Join(values, ","))
        _, err := bo.db.conn.ExecContext(ctx, finalQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch insert user interests: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch inserted %d user interests for user %d", len(interestIDs), userID)
        return nil</span>
}

// BatchDeleteUserInterests выполняет массовое удаление связей пользователь-интерес.
func (bo *BatchOperations) BatchDeleteUserInterests(ctx context.Context, userID int, interestIDs []int) error <span class="cov0" title="0">{
        if len(interestIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Создаем плейсхолдеры для IN clause
        <span class="cov0" title="0">placeholders := make([]string, len(interestIDs))
        args := make([]interface{}, len(interestIDs)+1)
        args[0] = userID

        for i, interestID := range interestIDs </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+2)
                args[i+1] = interestID
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                DELETE FROM user_interests 
                WHERE user_id = $1 AND interest_id IN (%s)`,
                strings.Join(placeholders, ","))

        _, err := bo.db.conn.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch delete user interests: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch deleted %d user interests for user %d", len(interestIDs), userID)
        return nil</span>
}

// BatchInsertLanguages выполняет массовую вставку языков.
func (bo *BatchOperations) BatchInsertLanguages(ctx context.Context, languages []*models.Language) error <span class="cov0" title="0">{
        if len(languages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO languages (code, name, native_name, created_at)
                VALUES %s
                ON CONFLICT (code) DO NOTHING`

        // Подготавливаем VALUES
        var values []string
        for _, language := range languages </span><span class="cov0" title="0">{
                value := fmt.Sprintf("(%s, %s, %s, %s)",
                        escapeSQL(language.Code),
                        escapeSQL(language.NameEn),
                        escapeSQL(language.NameNative),
                        escapeSQL(language.CreatedAt.Format(time.RFC3339)),
                )
                values = append(values, value)
        }</span>

        <span class="cov0" title="0">finalQuery := fmt.Sprintf(query, strings.Join(values, ","))
        _, err := bo.db.conn.ExecContext(ctx, finalQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch insert languages: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch inserted %d languages", len(languages))
        return nil</span>
}

// BatchUpdateUserStats выполняет массовое обновление статистики пользователей.
func (bo *BatchOperations) BatchUpdateUserStats(ctx context.Context, userStats []UserStats) error <span class="cov0" title="0">{
        if len(userStats) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE users SET 
                        profile_completion_level = data.profile_completion_level,
                        updated_at = data.updated_at
                FROM (VALUES %s) AS data(id, profile_completion_level, updated_at)
                WHERE users.id = data.id`

        // Подготавливаем VALUES
        var values []string
        for _, stats := range userStats </span><span class="cov0" title="0">{
                value := fmt.Sprintf("(%d, %d, %s)",
                        stats.UserID,
                        stats.ProfileCompletionLevel,
                        escapeSQL(stats.UpdatedAt.Format(time.RFC3339)),
                )
                values = append(values, value)
        }</span>

        <span class="cov0" title="0">finalQuery := fmt.Sprintf(query, strings.Join(values, ","))
        _, err := bo.db.conn.ExecContext(ctx, finalQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute batch update user stats: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch updated stats for %d users", len(userStats))
        return nil</span>
}

// BatchGetUsers выполняет массовое получение пользователей по ID.
func (bo *BatchOperations) BatchGetUsers(ctx context.Context, userIDs []int) ([]*models.User, error) <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Создаем плейсхолдеры для IN clause
        <span class="cov0" title="0">placeholders := make([]string, len(userIDs))
        args := make([]interface{}, len(userIDs))

        for i, userID := range userIDs </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+1)
                args[i] = userID
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, telegram_id, username, first_name, native_language_code,
                       target_language_code, target_language_level, interface_language_code,
                       state, status, profile_completion_level, created_at, updated_at
                FROM users 
                WHERE id IN (%s)`,
                strings.Join(placeholders, ","))

        rows, err := bo.db.conn.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute batch get users: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to close rows in BatchGetUsers: %v", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">var users []*models.User
        for rows.Next() </span><span class="cov0" title="0">{
                user := &amp;models.User{}
                err := rows.Scan(
                        &amp;user.ID,
                        &amp;user.TelegramID,
                        &amp;user.Username,
                        &amp;user.FirstName,
                        &amp;user.NativeLanguageCode,
                        &amp;user.TargetLanguageCode,
                        &amp;user.TargetLanguageLevel,
                        &amp;user.InterfaceLanguageCode,
                        &amp;user.State,
                        &amp;user.Status,
                        &amp;user.ProfileCompletionLevel,
                        &amp;user.CreatedAt,
                        &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate users: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Batch retrieved %d users", len(users))
        return users, nil</span>
}

// UserStats представляет статистику пользователя для batch операций.
type UserStats struct {
        UserID                 int
        ProfileCompletionLevel int
        UpdatedAt              time.Time
}

// Helper functions

// escapeSQL экранирует строку для SQL запроса.
func escapeSQL(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return "NULL"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("'%s'", strings.ReplaceAll(s, "'", "''"))</span>
}

// escapeCSV экранирует строку для CSV формата.
func escapeCSV(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        // Экранируем кавычки и запятые
        <span class="cov0" title="0">s = strings.ReplaceAll(s, "\"", "\"\"")
        if strings.Contains(s, ",") || strings.Contains(s, "\"") || strings.Contains(s, "\n") </span><span class="cov0" title="0">{
                return fmt.Sprintf("\"%s\"", s)
        }</span>
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package database provides database operations and connection management.
package database

import (
        "context"
        "database/sql"
        "fmt"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"
        "language-exchange-bot/internal/models"
        "time"

        _ "github.com/lib/pq" // PostgreSQL driver
)

// Константы для fallback данных.
const (
        fallbackLanguageID1 = 1
        fallbackLanguageID2 = 2
        fallbackLanguageID3 = 3
        fallbackLanguageID4 = 4

        fallbackInterestID1 = 1
        fallbackInterestID2 = 2
        fallbackInterestID3 = 3
        fallbackInterestID4 = 4
)

// DB представляет подключение к базе данных.
type DB struct {
        conn         *sql.DB
        logger       *logging.DatabaseLogger
        errorHandler *errors.ErrorHandler
        batchOps     *BatchOperations
}

// NewDB создает новое подключение к базе данных.
func NewDB(databaseURL string) (*DB, error) <span class="cov8" title="1">{
        conn, err := sql.Open("postgres", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Настройка connection pool для оптимизации производительности
        <span class="cov8" title="1">conn.SetMaxOpenConns(25)                  // Максимум 25 открытых соединений
        conn.SetMaxIdleConns(10)                  // Максимум 10 idle соединений
        conn.SetConnMaxLifetime(5 * time.Minute)  // Максимальное время жизни соединения
        conn.SetConnMaxIdleTime(10 * time.Minute) // Максимальное время idle соединения

        if err := conn.PingContext(context.Background()); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">db := &amp;DB{
                conn:         conn,
                logger:       logging.NewDatabaseLogger(),
                errorHandler: errors.NewErrorHandler(nil),
        }

        db.batchOps = NewBatchOperations(db)
        db.logger.LogConnectionEstablished("")

        return db, nil</span>
}

// NewDBWithConfig создает новое подключение к базе данных с конфигурацией.
func NewDBWithConfig(databaseURL string, maxOpenConns, maxIdleConns int) (*DB, error) <span class="cov0" title="0">{
        conn, err := sql.Open("postgres", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Настройка connection pool с переданными параметрами
        <span class="cov0" title="0">conn.SetMaxOpenConns(maxOpenConns)
        conn.SetMaxIdleConns(maxIdleConns)
        conn.SetConnMaxLifetime(5 * time.Minute)  // Максимальное время жизни соединения
        conn.SetConnMaxIdleTime(10 * time.Minute) // Максимальное время idle соединения

        if err := conn.PingContext(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">db := &amp;DB{
                conn:         conn,
                logger:       logging.NewDatabaseLogger(),
                errorHandler: errors.NewErrorHandler(nil),
        }

        db.batchOps = NewBatchOperations(db)
        db.logger.LogConnectionEstablished("")

        return db, nil</span>
}

// Close закрывает подключение к базе данных.
func (db *DB) Close() error <span class="cov8" title="1">{
        err := db.conn.Close()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close database connection: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetConnection возвращает подключение к базе данных.
func (db *DB) GetConnection() *sql.DB <span class="cov8" title="1">{
        return db.conn
}</span>

// GetLanguages возвращает список всех языков.
//
//nolint:funlen
func (db *DB) GetLanguages() ([]*models.Language, error) <span class="cov8" title="1">{
        query := `
                SELECT id, code, name_native, name_en, is_interface_language
                FROM languages
                ORDER BY id
        `

        rows, err := db.conn.QueryContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get languages: %w", err)
        }</span>

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        db.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "DatabaseOperation",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov8" title="1">var languages []*models.Language

        for rows.Next() </span><span class="cov8" title="1">{
                lang := &amp;models.Language{
                        ID:                  0,
                        Code:                "",
                        NameNative:          "",
                        NameEn:              "",
                        IsInterfaceLanguage: false,
                        CreatedAt:           time.Now(),
                }

                err := rows.Scan(&amp;lang.ID, &amp;lang.Code, &amp;lang.NameNative, &amp;lang.NameEn, &amp;lang.IsInterfaceLanguage)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">languages = append(languages, lang)</span>
        }

        // Fallback если нет данных в БД (для тестов)
        <span class="cov8" title="1">if len(languages) == 0 </span><span class="cov0" title="0">{
                return []*models.Language{
                        {ID: fallbackLanguageID1, Code: "en", NameNative: "English", NameEn: "English"},
                        {ID: fallbackLanguageID2, Code: "ru", NameNative: "Русский", NameEn: "Russian"},
                        {ID: fallbackLanguageID3, Code: "es", NameNative: "Español", NameEn: "Spanish"},
                        {ID: fallbackLanguageID4, Code: "zh", NameNative: "中文", NameEn: "Chinese"},
                }, nil
        }</span>

        <span class="cov8" title="1">return languages, nil</span>
}

// GetLanguageByCode возвращает язык по его коду.
func (db *DB) GetLanguageByCode(code string) (*models.Language, error) <span class="cov8" title="1">{
        query := `
                SELECT id, code, name_native, name_en, is_interface_language
                FROM languages
                WHERE code = $1
        `
        lang := &amp;models.Language{
                ID:                  0,
                Code:                "",
                NameNative:          "",
                NameEn:              "",
                IsInterfaceLanguage: false,
                CreatedAt:           time.Now(),
        }

        err := db.conn.QueryRowContext(context.Background(), query, code).Scan(
                &amp;lang.ID, &amp;lang.Code, &amp;lang.NameNative, &amp;lang.NameEn, &amp;lang.IsInterfaceLanguage,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return lang, nil</span>
}

// GetInterests возвращает список всех интересов.
//
//nolint:funlen
func (db *DB) GetInterests() ([]*models.Interest, error) <span class="cov8" title="1">{
        query := `
                SELECT id, key_name, type
                FROM interests
                ORDER BY id
        `

        rows, err := db.conn.QueryContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get interests: %w", err)
        }</span>

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        db.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "DatabaseOperation",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov8" title="1">var interests []*models.Interest

        for rows.Next() </span><span class="cov8" title="1">{
                interest := &amp;models.Interest{
                        ID:           0,
                        KeyName:      "",
                        CategoryID:   0,
                        DisplayOrder: 0,
                        Type:         "",
                        CreatedAt:    time.Now(),
                }

                err := rows.Scan(&amp;interest.ID, &amp;interest.KeyName, &amp;interest.Type)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">interests = append(interests, interest)</span>
        }

        // Fallback если нет данных в БД (для тестов)
        <span class="cov8" title="1">if len(interests) == 0 </span><span class="cov0" title="0">{
                return []*models.Interest{
                        {ID: fallbackInterestID1, KeyName: "movies", Type: "entertainment"},
                        {ID: fallbackInterestID2, KeyName: "music", Type: "entertainment"},
                        {ID: fallbackInterestID3, KeyName: "sports", Type: "activity"},
                        {ID: fallbackInterestID4, KeyName: "travel", Type: "activity"},
                }, nil
        }</span>

        <span class="cov8" title="1">return interests, nil</span>
}

// GetUserByTelegramID возвращает пользователя по Telegram ID.
func (db *DB) GetUserByTelegramID(telegramID int64) (*models.User, error) <span class="cov8" title="1">{
        user := &amp;models.User{
                ID:                     0,
                TelegramID:             0,
                Username:               "",
                FirstName:              "",
                NativeLanguageCode:     "",
                TargetLanguageCode:     "",
                TargetLanguageLevel:    "",
                InterfaceLanguageCode:  "",
                State:                  "",
                Status:                 "",
                ProfileCompletionLevel: 0,
                CreatedAt:              time.Now(),
                UpdatedAt:              time.Now(),
                Interests:              []int{},
                TimeAvailability: &amp;models.TimeAvailability{
                        DayType:      "any",
                        SpecificDays: []string{},
                        TimeSlot:     "any",
                },
                FriendshipPreferences: &amp;models.FriendshipPreferences{
                        ActivityType:       "casual_chat",
                        CommunicationStyle: "text",
                        CommunicationFreq:  "weekly",
                },
        }

        err := db.conn.QueryRowContext(context.Background(), `
                SELECT id, telegram_id, username, first_name,
                       COALESCE(native_language_code, '') as native_language_code,
                       COALESCE(target_language_code, '') as target_language_code,
                       COALESCE(target_language_level, '') as target_language_level,
                       interface_language_code, created_at, updated_at, state,
                       profile_completion_level, status
                FROM users
                WHERE telegram_id = $1
        `, telegramID).Scan(
                &amp;user.ID, &amp;user.TelegramID, &amp;user.Username, &amp;user.FirstName,
                &amp;user.NativeLanguageCode, &amp;user.TargetLanguageCode, &amp;user.TargetLanguageLevel,
                &amp;user.InterfaceLanguageCode, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;user.State, &amp;user.ProfileCompletionLevel, &amp;user.Status,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// UpdateUser обновляет данные пользователя.
func (db *DB) UpdateUser(user *models.User) error <span class="cov0" title="0">{
        _, err := db.conn.ExecContext(context.Background(), `
                UPDATE users
                SET username = $1, first_name = $2, native_language_code = $3,
                    target_language_code = $4, target_language_level = $5,
                    interface_language_code = $6, state = $7, status = $8,
                    profile_completion_level = $9, updated_at = CURRENT_TIMESTAMP
                WHERE id = $10
        `, user.Username, user.FirstName, user.NativeLanguageCode,
                user.TargetLanguageCode, user.TargetLanguageLevel,
                user.InterfaceLanguageCode, user.State, user.Status,
                user.ProfileCompletionLevel, user.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SaveUserInterests сохраняет интересы пользователя.
func (db *DB) SaveUserInterests(userID int, interestIDs []int) error <span class="cov8" title="1">{
        // Сначала удаляем все интересы пользователя
        err := db.ClearUserInterests(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        // Затем добавляем новые
        <span class="cov8" title="1">for _, interestID := range interestIDs </span><span class="cov8" title="1">{
                err := db.SaveUserInterest(userID, interestID, false)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation failed: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// FindOrCreateUser находит или создает пользователя.
func (db *DB) FindOrCreateUser(telegramID int64, username, firstName string) (*models.User, error) <span class="cov8" title="1">{
        user := &amp;models.User{
                ID:                     0,
                TelegramID:             0,
                Username:               "",
                FirstName:              "",
                NativeLanguageCode:     "",
                TargetLanguageCode:     "",
                TargetLanguageLevel:    "",
                InterfaceLanguageCode:  "",
                State:                  "",
                Status:                 "",
                ProfileCompletionLevel: 0,
                CreatedAt:              time.Now(),
                UpdatedAt:              time.Now(),
                Interests:              []int{},
                TimeAvailability: &amp;models.TimeAvailability{
                        DayType:      "any",
                        SpecificDays: []string{},
                        TimeSlot:     "any",
                },
                FriendshipPreferences: &amp;models.FriendshipPreferences{
                        ActivityType:       "casual_chat",
                        CommunicationStyle: "text",
                        CommunicationFreq:  "weekly",
                },
        }

        err := db.conn.QueryRowContext(context.Background(), `
        INSERT INTO users (telegram_id, username, first_name, interface_language_code)
        VALUES ($1, $2, $3, 'en')
        ON CONFLICT (telegram_id) DO UPDATE SET
            username = EXCLUDED.username,
            first_name = EXCLUDED.first_name,
            updated_at = CURRENT_TIMESTAMP
        RETURNING id, telegram_id, username, first_name,
        COALESCE(native_language_code, '') as native_language_code,
        COALESCE(target_language_code, '') as target_language_code,
        COALESCE(target_language_level, '') as target_language_level,
        interface_language_code, created_at, updated_at, state,
        profile_completion_level, status
    `, telegramID, username, firstName).Scan(
                &amp;user.ID, &amp;user.TelegramID, &amp;user.Username, &amp;user.FirstName,
                &amp;user.NativeLanguageCode, &amp;user.TargetLanguageCode, &amp;user.TargetLanguageLevel,
                &amp;user.InterfaceLanguageCode, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;user.State, &amp;user.ProfileCompletionLevel, &amp;user.Status,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// UpdateUserState обновляет состояние пользователя.
func (db *DB) UpdateUserState(userID int, state string) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(), `
        UPDATE users SET state = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
    `, state, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateUserStatus обновляет статус пользователя.
func (db *DB) UpdateUserStatus(userID int, status string) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(), `
        UPDATE users SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
    `, status, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateUserProfileCompletionLevel обновляет уровень завершения профиля пользователя.
func (db *DB) UpdateUserProfileCompletionLevel(userID int, level int) error <span class="cov0" title="0">{
        _, err := db.conn.ExecContext(context.Background(), `
        UPDATE users SET profile_completion_level = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
    `, level, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserInterfaceLanguage обновляет язык интерфейса пользователя.
func (db *DB) UpdateUserInterfaceLanguage(userID int, langCode string) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(), `
        UPDATE users SET interface_language_code = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
    `, langCode, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateUserNativeLanguage обновляет родной язык пользователя.
func (db *DB) UpdateUserNativeLanguage(userID int, langCode string) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(),
                "UPDATE users SET native_language_code = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
                langCode, userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateUserTargetLanguage обновляет целевой язык пользователя.
func (db *DB) UpdateUserTargetLanguage(userID int, langCode string) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(),
                "UPDATE users SET target_language_code = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
                langCode, userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateUserTargetLanguageLevel обновляет уровень целевого языка пользователя.
func (db *DB) UpdateUserTargetLanguageLevel(userID int, level string) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(),
                "UPDATE users SET target_language_level = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
                level, userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveNativeLanguage сохраняет родной язык пользователя.
func (db *DB) SaveNativeLanguage(userID int, langCode string) error <span class="cov8" title="1">{
        return db.UpdateUserNativeLanguage(userID, langCode)
}</span>

// SaveTargetLanguage сохраняет целевой язык пользователя.
func (db *DB) SaveTargetLanguage(userID int, langCode string) error <span class="cov8" title="1">{
        return db.UpdateUserTargetLanguage(userID, langCode)
}</span>

// SaveUserInterest сохраняет интерес пользователя.
func (db *DB) SaveUserInterest(userID, interestID int, isPrimary bool) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(), `
        INSERT INTO user_interests (user_id, interest_id, is_primary, created_at) 
        VALUES ($1, $2, $3, CURRENT_TIMESTAMP) 
        ON CONFLICT (user_id, interest_id) DO NOTHING
    `, userID, interestID, isPrimary)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetUserSelectedInterests возвращает выбранные пользователем интересы.
func (db *DB) GetUserSelectedInterests(userID int) ([]int, error) <span class="cov8" title="1">{
        rows, err := db.conn.QueryContext(context.Background(), `
        SELECT interest_id FROM user_interests 
        WHERE user_id = $1
    `, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        db.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "DatabaseOperation",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov8" title="1">var interests []int

        for rows.Next() </span><span class="cov8" title="1">{
                var interestID int

                err := rows.Scan(&amp;interestID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">interests = append(interests, interestID)</span>
        }

        <span class="cov8" title="1">return interests, nil</span>
}

// RemoveUserInterest удаляет интерес пользователя.
func (db *DB) RemoveUserInterest(userID, interestID int) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(), `
        DELETE FROM user_interests
        WHERE user_id = $1 AND interest_id = $2
    `, userID, interestID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ClearUserInterests удаляет все интересы пользователя.
func (db *DB) ClearUserInterests(userID int) error <span class="cov8" title="1">{
        _, err := db.conn.ExecContext(context.Background(), `
        DELETE FROM user_interests WHERE user_id = $1
    `, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetUserInterestSelections получает выборы интересов пользователя.
func (db *DB) GetUserInterestSelections(userID int) ([]models.InterestSelection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, interest_id, is_primary, selection_order, created_at
                FROM user_interest_selections 
                WHERE user_id = $1 
                ORDER BY is_primary DESC, selection_order ASC
        `

        rows, err := db.conn.QueryContext(context.Background(), query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        db.logger.Error("Failed to close database rows", map[string]interface{}{
                                "error":     closeErr.Error(),
                                "operation": "GetUserInterestSelections",
                        })
                }</span>
        }()

        <span class="cov0" title="0">var selections []models.InterestSelection
        for rows.Next() </span><span class="cov0" title="0">{
                var selection models.InterestSelection
                err := rows.Scan(
                        &amp;selection.ID,
                        &amp;selection.UserID,
                        &amp;selection.InterestID,
                        &amp;selection.IsPrimary,
                        &amp;selection.SelectionOrder,
                        &amp;selection.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("operation failed: %w", err)
                }</span>
                <span class="cov0" title="0">selections = append(selections, selection)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return selections, nil</span>
}

// GetInterestByID получает интерес по ID.
func (db *DB) GetInterestByID(interestID int) (*models.Interest, error) <span class="cov8" title="1">{
        query := `
                SELECT id, key_name, category_id, display_order, type, created_at
                FROM interests 
                WHERE id = $1
        `

        var interest models.Interest
        err := db.conn.QueryRowContext(context.Background(), query, interestID).Scan(
                &amp;interest.ID,
                &amp;interest.KeyName,
                &amp;interest.CategoryID,
                &amp;interest.DisplayOrder,
                &amp;interest.Type,
                &amp;interest.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;interest, nil</span>
}

// ResetUserProfile очищает языки и интересы, переводит пользователя в начало онбординга.
func (db *DB) ResetUserProfile(userID int) error <span class="cov8" title="1">{
        transaction, err := db.conn.BeginTx(context.Background(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = transaction.Rollback()
        }</span>()

        // Удаляем интересы
        <span class="cov8" title="1">query := `DELETE FROM user_interests WHERE user_id = $1`
        if _, err := transaction.ExecContext(context.Background(), query, userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        // Сбрасываем языки и состояние (интерфейсный язык не трогаем)
        <span class="cov8" title="1">if _, err := transaction.ExecContext(context.Background(), `
                UPDATE users
                SET native_language_code = NULL,
                    target_language_code = NULL,
                    target_language_level = '',
                    state = $1,
                    status = $2,
                    profile_completion_level = 0,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $3
        `, models.StateWaitingLanguage, models.StatusFilling, userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := transaction.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Методы работы с отзывами пользователей

// SaveUserFeedback сохраняет отзыв пользователя в базу данных.
func (db *DB) SaveUserFeedback(userID int, feedbackText string, contactInfo *string) error <span class="cov8" title="1">{
        query := `
        INSERT INTO user_feedback (user_id, feedback_text, contact_info, created_at, is_processed)
        VALUES ($1, $2, $3, CURRENT_TIMESTAMP, false)
    `

        _, err := db.conn.ExecContext(context.Background(), query, userID, feedbackText, contactInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetUserFeedbackByUserID получает отзывы пользователя.
func (db *DB) GetUserFeedbackByUserID(userID int) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        query := `
        SELECT id, user_id, feedback_text, contact_info, created_at, is_processed, admin_response
        FROM user_feedback
        WHERE user_id = $1
        ORDER BY created_at DESC
    `

        rows, err := db.conn.QueryContext(context.Background(), query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        db.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "DatabaseOperation",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov8" title="1">return db.processUserFeedbackRows(rows), nil</span>
}

// processUserFeedbackRows обрабатывает строки результата запроса отзывов пользователя.
func (db *DB) processUserFeedbackRows(rows *sql.Rows) []map[string]interface{} <span class="cov8" title="1">{
        var feedbacks []map[string]interface{}

        for rows.Next() </span><span class="cov8" title="1">{
                feedback := db.scanUserFeedbackRow(rows)
                if feedback != nil </span><span class="cov8" title="1">{
                        feedbacks = append(feedbacks, feedback)
                }</span>
        }

        <span class="cov8" title="1">return feedbacks</span>
}

// scanUserFeedbackRow сканирует одну строку результата запроса отзывов пользователя.
func (db *DB) scanUserFeedbackRow(rows *sql.Rows) map[string]interface{} <span class="cov8" title="1">{
        var (
                feedbackID    int
                userID        int
                feedbackText  string
                contactInfo   sql.NullString
                createdAt     sql.NullTime
                isProcessed   bool
                adminResponse sql.NullString
        )

        err := rows.Scan(&amp;feedbackID, &amp;userID, &amp;feedbackText, &amp;contactInfo, &amp;createdAt, &amp;isProcessed, &amp;adminResponse)
        if err != nil </span><span class="cov0" title="0">{
                return nil // Пропускаем ошибочные записи
        }</span>

        <span class="cov8" title="1">feedback := map[string]interface{}{
                "id":            feedbackID,
                "user_id":       userID,
                "feedback_text": feedbackText,
                "created_at":    createdAt.Time,
                "is_processed":  isProcessed,
        }

        if contactInfo.Valid </span><span class="cov8" title="1">{
                feedback["contact_info"] = contactInfo.String
        }</span> else<span class="cov0" title="0"> {
                feedback["contact_info"] = nil
        }</span>

        <span class="cov8" title="1">if adminResponse.Valid </span><span class="cov8" title="1">{
                feedback["admin_response"] = adminResponse.String
        }</span> else<span class="cov8" title="1"> {
                feedback["admin_response"] = nil
        }</span>

        <span class="cov8" title="1">return feedback</span>
}

// GetUnprocessedFeedback получает все необработанные отзывы для администрирования.
func (db *DB) GetUnprocessedFeedback() ([]map[string]interface{}, error) <span class="cov8" title="1">{
        query := getUnprocessedFeedbackQuery()

        rows, err := db.conn.QueryContext(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close rows after error: %w (original error: %w)", closeErr, err)
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("rows error: %w", err)</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        db.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "DatabaseOperation",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov8" title="1">return db.processFeedbackRows(rows), nil</span>
}

// getUnprocessedFeedbackQuery возвращает SQL запрос для получения необработанных отзывов.
func getUnprocessedFeedbackQuery() string <span class="cov8" title="1">{
        return `
        SELECT uf.id, uf.user_id, uf.feedback_text, uf.contact_info, uf.created_at,
               u.username, u.telegram_id, u.first_name
        FROM user_feedback uf
        JOIN users u ON uf.user_id = u.id
        WHERE uf.is_processed = false
        ORDER BY uf.created_at ASC
    `
}</span>

// processFeedbackRows обрабатывает строки результата запроса отзывов.
func (db *DB) processFeedbackRows(rows *sql.Rows) []map[string]interface{} <span class="cov8" title="1">{
        var feedbacks []map[string]interface{}

        for rows.Next() </span><span class="cov8" title="1">{
                feedback, err := db.scanFeedbackRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Пропускаем ошибочные записи
                }

                <span class="cov8" title="1">feedbacks = append(feedbacks, feedback)</span>
        }

        <span class="cov8" title="1">return feedbacks</span>
}

// scanFeedbackRow сканирует одну строку результата запроса отзывов.
func (db *DB) scanFeedbackRow(rows *sql.Rows) (map[string]interface{}, error) <span class="cov8" title="1">{
        var (
                feedbackID   int
                userID       int
                feedbackText string
                contactInfo  sql.NullString
                createdAt    sql.NullTime
                username     sql.NullString
                telegramID   int64
                firstName    string
        )

        err := rows.Scan(&amp;feedbackID, &amp;userID, &amp;feedbackText, &amp;contactInfo, &amp;createdAt, &amp;username, &amp;telegramID, &amp;firstName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">feedback := map[string]interface{}{
                "id":            feedbackID,
                "user_id":       userID,
                "feedback_text": feedbackText,
                "created_at":    createdAt.Time,
                "telegram_id":   telegramID,
                "first_name":    firstName,
        }

        // Добавляем опциональные поля
        feedback["username"] = getStringValue(username)
        feedback["contact_info"] = getStringValue(contactInfo)

        return feedback, nil</span>
}

// getStringValue возвращает строковое значение из sql.NullString.
func getStringValue(nullStr sql.NullString) interface{} <span class="cov8" title="1">{
        if nullStr.Valid </span><span class="cov8" title="1">{
                return nullStr.String
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkFeedbackProcessed помечает отзыв как обработанный и добавляет ответ администратора.
func (db *DB) MarkFeedbackProcessed(feedbackID int, adminResponse string) error <span class="cov8" title="1">{
        query := `
        UPDATE user_feedback
        SET is_processed = true, admin_response = $1, updated_at = CURRENT_TIMESTAMP
        WHERE id = $2
    `

        _, err := db.conn.ExecContext(context.Background(), query, adminResponse, feedbackID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveTimeAvailability сохраняет временную доступность пользователя
func (db *DB) SaveTimeAvailability(userID int, availability *models.TimeAvailability) error <span class="cov0" title="0">{
        query := `
                INSERT INTO user_time_availability (user_id, day_type, specific_days, time_slot)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT (user_id) DO UPDATE SET
                        day_type = EXCLUDED.day_type,
                        specific_days = EXCLUDED.specific_days,
                        time_slot = EXCLUDED.time_slot,
                        created_at = CURRENT_TIMESTAMP
        `

        _, err := db.conn.ExecContext(context.Background(), query,
                userID,
                availability.DayType,
                availability.SpecificDays,
                availability.TimeSlot,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save time availability: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTimeAvailability получает временную доступность пользователя
func (db *DB) GetTimeAvailability(userID int) (*models.TimeAvailability, error) <span class="cov0" title="0">{
        query := `
                SELECT day_type, specific_days, time_slot
                FROM user_time_availability
                WHERE user_id = $1
        `

        var availability models.TimeAvailability
        err := db.conn.QueryRowContext(context.Background(), query, userID).Scan(
                &amp;availability.DayType,
                &amp;availability.SpecificDays,
                &amp;availability.TimeSlot,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // Возвращаем значения по умолчанию, если данных нет
                        return &amp;models.TimeAvailability{
                                DayType:      "any",
                                SpecificDays: []string{},
                                TimeSlot:     "any",
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get time availability: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;availability, nil</span>
}

// SaveFriendshipPreferences сохраняет предпочтения общения пользователя
func (db *DB) SaveFriendshipPreferences(userID int, preferences *models.FriendshipPreferences) error <span class="cov0" title="0">{
        query := `
                INSERT INTO friendship_preferences (user_id, activity_type, communication_style, communication_frequency)
                VALUES ($1, $2, $3, $4)
                ON CONFLICT (user_id) DO UPDATE SET
                        activity_type = EXCLUDED.activity_type,
                        communication_style = EXCLUDED.communication_style,
                        communication_frequency = EXCLUDED.communication_frequency,
                        created_at = CURRENT_TIMESTAMP
        `

        _, err := db.conn.ExecContext(context.Background(), query,
                userID,
                preferences.ActivityType,
                preferences.CommunicationStyle,
                preferences.CommunicationFreq,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save friendship preferences: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFriendshipPreferences получает предпочтения общения пользователя
func (db *DB) GetFriendshipPreferences(userID int) (*models.FriendshipPreferences, error) <span class="cov0" title="0">{
        query := `
                SELECT activity_type, communication_style, communication_frequency
                FROM friendship_preferences
                WHERE user_id = $1
        `

        var preferences models.FriendshipPreferences
        err := db.conn.QueryRowContext(context.Background(), query, userID).Scan(
                &amp;preferences.ActivityType,
                &amp;preferences.CommunicationStyle,
                &amp;preferences.CommunicationFreq,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // Возвращаем значения по умолчанию, если данных нет
                        return &amp;models.FriendshipPreferences{
                                ActivityType:       "casual_chat",
                                CommunicationStyle: "text",
                                CommunicationFreq:  "weekly",
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get friendship preferences: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;preferences, nil</span>
}

// ===== BATCH OPERATIONS METHODS =====

// GetBatchOperations возвращает экземпляр BatchOperations для массовых операций.
func (db *DB) GetBatchOperations() *BatchOperations <span class="cov0" title="0">{
        return db.batchOps
}</span>

// BatchInsertUsers выполняет массовую вставку пользователей.
func (db *DB) BatchInsertUsers(ctx context.Context, users []*models.User) error <span class="cov0" title="0">{
        return db.batchOps.BatchInsertUsers(ctx, users)
}</span>

// BatchUpdateUsers выполняет массовое обновление пользователей.
func (db *DB) BatchUpdateUsers(ctx context.Context, users []*models.User) error <span class="cov0" title="0">{
        return db.batchOps.BatchUpdateUsers(ctx, users)
}</span>

// BatchInsertInterests выполняет массовую вставку интересов.
func (db *DB) BatchInsertInterests(ctx context.Context, interests []*models.Interest) error <span class="cov0" title="0">{
        return db.batchOps.BatchInsertInterests(ctx, interests)
}</span>

// BatchInsertUserInterests выполняет массовую вставку связей пользователь-интерес.
func (db *DB) BatchInsertUserInterests(ctx context.Context, userID int, interestIDs []int) error <span class="cov0" title="0">{
        return db.batchOps.BatchInsertUserInterests(ctx, userID, interestIDs)
}</span>

// BatchDeleteUserInterests выполняет массовое удаление связей пользователь-интерес.
func (db *DB) BatchDeleteUserInterests(ctx context.Context, userID int, interestIDs []int) error <span class="cov0" title="0">{
        return db.batchOps.BatchDeleteUserInterests(ctx, userID, interestIDs)
}</span>

// BatchInsertLanguages выполняет массовую вставку языков.
func (db *DB) BatchInsertLanguages(ctx context.Context, languages []*models.Language) error <span class="cov0" title="0">{
        return db.batchOps.BatchInsertLanguages(ctx, languages)
}</span>

// BatchUpdateUserStats выполняет массовое обновление статистики пользователей.
func (db *DB) BatchUpdateUserStats(ctx context.Context, userStats []UserStats) error <span class="cov0" title="0">{
        return db.batchOps.BatchUpdateUserStats(ctx, userStats)
}</span>

// BatchGetUsers выполняет массовое получение пользователей по ID.
func (db *DB) BatchGetUsers(ctx context.Context, userIDs []int) ([]*models.User, error) <span class="cov0" title="0">{
        return db.batchOps.BatchGetUsers(ctx, userIDs)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package errors

import (
        "fmt"
        "log"
)

// AdminNotifierImpl реализует уведомления администраторов.
type AdminNotifierImpl struct {
        adminChatIDs []int64
        botAPI       interface{} // Telegram Bot API для отправки уведомлений
}

// NewAdminNotifier создает новый уведомитель администраторов.
func NewAdminNotifier(adminChatIDs []int64, botAPI interface{}) *AdminNotifierImpl <span class="cov8" title="1">{
        return &amp;AdminNotifierImpl{
                adminChatIDs: adminChatIDs,
                botAPI:       botAPI,
        }
}</span>

// NotifyCriticalError уведомляет администраторов о критической ошибке.
func (n *AdminNotifierImpl) NotifyCriticalError(err *CustomError) <span class="cov8" title="1">{
        message := fmt.Sprintf(`
🚨 **КРИТИЧЕСКАЯ ОШИБКА**

**Тип:** %s
**Время:** %s
**RequestID:** %s
**Сообщение:** %s

**Контекст:**
- User ID: %v
- Chat ID: %v
- Операция: %v

**Дополнительная информация:**
%s
`,
                err.Type.String(),
                err.Timestamp.Format("2006-01-02 15:04:05"),
                err.RequestID,
                err.Message,
                err.Context["user_id"],
                err.Context["chat_id"],
                err.Context["operation"],
                n.formatContext(err.Context),
        )

        n.sendToAdmins(message)
}</span>

// NotifyTelegramAPIError уведомляет администраторов об ошибке Telegram API.
func (n *AdminNotifierImpl) NotifyTelegramAPIError(err *CustomError, chatID int64) <span class="cov8" title="1">{
        message := fmt.Sprintf(`
⚠️ **ОШИБКА TELEGRAM API**

**Время:** %s
**RequestID:** %s
**Chat ID:** %d
**Сообщение:** %s

**Контекст:**
- User ID: %v
- Операция: %v
`,
                err.Timestamp.Format("2006-01-02 15:04:05"),
                err.RequestID,
                chatID,
                err.Message,
                err.Context["user_id"],
                err.Context["operation"],
        )

        n.sendToAdmins(message)
}</span>

// sendToAdmins отправляет сообщение всем администраторам.
func (n *AdminNotifierImpl) sendToAdmins(message string) <span class="cov8" title="1">{
        for _, chatID := range n.adminChatIDs </span><span class="cov8" title="1">{
                n.sendMessage(chatID, message)
        }</span>
}

// sendMessage отправляет сообщение (заглушка для интеграции с Telegram API).
func (n *AdminNotifierImpl) sendMessage(chatID int64, message string) <span class="cov8" title="1">{
        // Здесь должна быть интеграция с Telegram Bot API
        // Интегрировать с реальным Telegram Bot API
        // Пример:
        // if botAPI, ok := n.botAPI.(*tgbotapi.BotAPI); ok {
        //     msg := tgbotapi.NewMessage(chatID, message)
        //     msg.ParseMode = tgbotapi.ModeMarkdown
        //     botAPI.Send(msg)
        // }
        // Пока что просто логируем
        log.Printf("Admin notification to chat %d: %s", chatID, message)
}</span>

// formatContext форматирует контекст для отображения.
func (n *AdminNotifierImpl) formatContext(context map[string]interface{}) string <span class="cov8" title="1">{
        result := ""

        for key, value := range context </span><span class="cov8" title="1">{
                if key != "user_id" &amp;&amp; key != "chat_id" &amp;&amp;
                        key != "operation" </span><span class="cov0" title="0">{
                        result += fmt.Sprintf("- %s: %v\n", key, value)
                }</span>
        }

        <span class="cov8" title="1">if result == "" </span><span class="cov8" title="1">{
                return "Нет дополнительной информации"
        }</span>

        <span class="cov0" title="0">return result</span>
}

// SetAdminChatIDs обновляет список Chat ID администраторов.
func (n *AdminNotifierImpl) SetAdminChatIDs(chatIDs []int64) <span class="cov0" title="0">{
        n.adminChatIDs = chatIDs
}</span>

// GetAdminChatIDs возвращает список Chat ID администраторов.
func (n *AdminNotifierImpl) GetAdminChatIDs() []int64 <span class="cov8" title="1">{
        return n.adminChatIDs
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package errors provides centralized error handling and alerting.
package errors

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"
)

// AlertLevel определяет уровень алерта.
type AlertLevel int

const (
        AlertLevelInfo AlertLevel = iota
        AlertLevelWarning
        AlertLevelCritical
        AlertLevelEmergency
)

// String возвращает строковое представление уровня алерта.
func (al AlertLevel) String() string <span class="cov0" title="0">{
        switch al </span>{
        case AlertLevelInfo:<span class="cov0" title="0">
                return "INFO"</span>
        case AlertLevelWarning:<span class="cov0" title="0">
                return "WARNING"</span>
        case AlertLevelCritical:<span class="cov0" title="0">
                return "CRITICAL"</span>
        case AlertLevelEmergency:<span class="cov0" title="0">
                return "EMERGENCY"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// Alert представляет алерт для администраторов.
type Alert struct {
        ID         string                 `json:"id"`
        Level      AlertLevel             `json:"level"`
        Title      string                 `json:"title"`
        Message    string                 `json:"message"`
        Error      *CustomError           `json:"error"`
        Context    map[string]interface{} `json:"context"`
        Timestamp  time.Time              `json:"timestamp"`
        Resolved   bool                   `json:"resolved"`
        ResolvedAt *time.Time             `json:"resolved_at,omitempty"`
}

// CentralizedErrorHandler предоставляет централизованную обработку ошибок.
type CentralizedErrorHandler struct {
        alerts       map[string]*Alert
        notifiers    []AlertNotifier
        logger       *log.Logger
        alertCounter int
        mutex        chan struct{} // Семафор для потокобезопасности
}

// AlertNotifier интерфейс для уведомления об алертах.
type AlertNotifier interface {
        NotifyAlert(alert *Alert) error
        GetName() string
}

// NewCentralizedErrorHandler создает новый централизованный обработчик ошибок.
func NewCentralizedErrorHandler() *CentralizedErrorHandler <span class="cov0" title="0">{
        return &amp;CentralizedErrorHandler{
                alerts:    make(map[string]*Alert),
                notifiers: make([]AlertNotifier, 0),
                logger:    log.New(os.Stdout, "[ERROR_HANDLER] ", log.LstdFlags),
                mutex:     make(chan struct{}, 1),
        }
}</span>

// RegisterNotifier регистрирует уведомитель алертов.
func (ceh *CentralizedErrorHandler) RegisterNotifier(notifier AlertNotifier) <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        <span class="cov0" title="0">ceh.notifiers = append(ceh.notifiers, notifier)
        ceh.logger.Printf("Registered alert notifier: %s", notifier.GetName())</span>
}

// HandleError обрабатывает ошибку централизованно.
func (ceh *CentralizedErrorHandler) HandleError(ctx context.Context, err error, requestID string, userID, chatID int64, operation string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Логируем ошибку
        <span class="cov0" title="0">ceh.logError(err, requestID, userID, chatID, operation)

        // Создаем алерт если это критическая ошибка
        if ceh.isCriticalError(err) </span><span class="cov0" title="0">{
                alert := ceh.createAlert(err, requestID, userID, chatID, operation)
                ceh.sendAlert(alert)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// HandleCustomError обрабатывает кастомную ошибку.
func (ceh *CentralizedErrorHandler) HandleCustomError(ctx context.Context, customErr *CustomError, requestID string, userID, chatID int64, operation string) error <span class="cov0" title="0">{
        if customErr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Логируем ошибку
        <span class="cov0" title="0">ceh.logCustomError(customErr, requestID, userID, chatID, operation)

        // Создаем алерт если это критическая ошибка
        if ceh.isCriticalCustomError(customErr) </span><span class="cov0" title="0">{
                alert := ceh.createAlertFromCustomError(customErr, requestID, userID, chatID, operation)
                ceh.sendAlert(alert)
        }</span>

        <span class="cov0" title="0">return customErr</span>
}

// logError логирует обычную ошибку.
func (ceh *CentralizedErrorHandler) logError(err error, requestID string, userID, chatID int64, operation string) <span class="cov0" title="0">{
        logData := map[string]interface{}{
                "error":      err.Error(),
                "request_id": requestID,
                "user_id":    userID,
                "chat_id":    chatID,
                "operation":  operation,
                "timestamp":  time.Now().Format(time.RFC3339),
        }

        jsonData, err := json.Marshal(logData)
        if err != nil </span><span class="cov0" title="0">{
                ceh.logger.Printf("Failed to marshal error log: %v", err)
                return
        }</span>

        <span class="cov0" title="0">ceh.logger.Printf("ERROR: %s", string(jsonData))</span>
}

// logCustomError логирует кастомную ошибку.
func (ceh *CentralizedErrorHandler) logCustomError(customErr *CustomError, requestID string, userID, chatID int64, operation string) <span class="cov0" title="0">{
        logData := map[string]interface{}{
                "error_type":    customErr.Type.String(),
                "error_message": customErr.Message,
                "user_message":  customErr.UserMessage,
                "request_id":    requestID,
                "user_id":       userID,
                "chat_id":       chatID,
                "operation":     operation,
                "context":       customErr.Context,
                "timestamp":     time.Now().Format(time.RFC3339),
        }

        jsonData, err := json.Marshal(logData)
        if err != nil </span><span class="cov0" title="0">{
                ceh.logger.Printf("Failed to marshal custom error log: %v", err)
                return
        }</span>

        <span class="cov0" title="0">ceh.logger.Printf("CUSTOM_ERROR: %s", string(jsonData))</span>
}

// isCriticalError определяет, является ли ошибка критической.
func (ceh *CentralizedErrorHandler) isCriticalError(err error) bool <span class="cov0" title="0">{
        // Простая проверка по тексту ошибки
        errorText := err.Error()

        criticalKeywords := []string{
                "database connection failed",
                "redis connection failed",
                "telegram api rate limit",
                "critical error",
                "fatal error",
                "out of memory",
                "disk full",
                "network unreachable",
        }

        for _, keyword := range criticalKeywords </span><span class="cov0" title="0">{
                if contains(errorText, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// isCriticalCustomError определяет, является ли кастомная ошибка критической.
func (ceh *CentralizedErrorHandler) isCriticalCustomError(customErr *CustomError) bool <span class="cov0" title="0">{
        // Критические типы ошибок
        criticalTypes := []ErrorType{
                ErrorTypeDatabase,
                ErrorTypeNetwork,
                ErrorTypeInternal,
        }

        for _, errorType := range criticalTypes </span><span class="cov0" title="0">{
                if customErr.Type == errorType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// createAlert создает алерт из обычной ошибки.
func (ceh *CentralizedErrorHandler) createAlert(err error, requestID string, userID, chatID int64, operation string) *Alert <span class="cov0" title="0">{
        ceh.alertCounter++
        alertID := fmt.Sprintf("alert_%d_%d", time.Now().Unix(), ceh.alertCounter)

        alert := &amp;Alert{
                ID:      alertID,
                Level:   ceh.determineAlertLevel(err),
                Title:   "Critical Error Alert",
                Message: err.Error(),
                Context: map[string]interface{}{
                        "request_id": requestID,
                        "user_id":    userID,
                        "chat_id":    chatID,
                        "operation":  operation,
                        "timestamp":  time.Now().Format(time.RFC3339),
                },
                Timestamp: time.Now(),
                Resolved:  false,
        }

        return alert
}</span>

// createAlertFromCustomError создает алерт из кастомной ошибки.
func (ceh *CentralizedErrorHandler) createAlertFromCustomError(customErr *CustomError, requestID string, userID, chatID int64, operation string) *Alert <span class="cov0" title="0">{
        ceh.alertCounter++
        alertID := fmt.Sprintf("alert_%d_%d", time.Now().Unix(), ceh.alertCounter)

        alert := &amp;Alert{
                ID:      alertID,
                Level:   ceh.determineCustomErrorAlertLevel(customErr),
                Title:   fmt.Sprintf("%s Error Alert", customErr.Type.String()),
                Message: customErr.Message,
                Error:   customErr,
                Context: map[string]interface{}{
                        "request_id":   requestID,
                        "user_id":      userID,
                        "chat_id":      chatID,
                        "operation":    operation,
                        "error_type":   customErr.Type.String(),
                        "user_message": customErr.UserMessage,
                        "timestamp":    time.Now().Format(time.RFC3339),
                },
                Timestamp: time.Now(),
                Resolved:  false,
        }

        return alert
}</span>

// determineAlertLevel определяет уровень алерта для обычной ошибки.
func (ceh *CentralizedErrorHandler) determineAlertLevel(err error) AlertLevel <span class="cov0" title="0">{
        errorText := err.Error()

        if contains(errorText, "database connection failed") || contains(errorText, "redis connection failed") </span><span class="cov0" title="0">{
                return AlertLevelEmergency
        }</span>

        <span class="cov0" title="0">if contains(errorText, "telegram api rate limit") </span><span class="cov0" title="0">{
                return AlertLevelCritical
        }</span>

        <span class="cov0" title="0">if contains(errorText, "critical error") || contains(errorText, "fatal error") </span><span class="cov0" title="0">{
                return AlertLevelCritical
        }</span>

        <span class="cov0" title="0">return AlertLevelWarning</span>
}

// determineCustomErrorAlertLevel определяет уровень алерта для кастомной ошибки.
func (ceh *CentralizedErrorHandler) determineCustomErrorAlertLevel(customErr *CustomError) AlertLevel <span class="cov0" title="0">{
        switch customErr.Type </span>{
        case ErrorTypeDatabase:<span class="cov0" title="0">
                return AlertLevelEmergency</span>
        case ErrorTypeNetwork:<span class="cov0" title="0">
                return AlertLevelCritical</span>
        case ErrorTypeInternal:<span class="cov0" title="0">
                return AlertLevelCritical</span>
        case ErrorTypeTelegramAPI:<span class="cov0" title="0">
                return AlertLevelWarning</span>
        case ErrorTypeCache:<span class="cov0" title="0">
                return AlertLevelWarning</span>
        case ErrorTypeValidation:<span class="cov0" title="0">
                return AlertLevelInfo</span>
        default:<span class="cov0" title="0">
                return AlertLevelWarning</span>
        }
}

// sendAlert отправляет алерт всем зарегистрированным уведомителям.
func (ceh *CentralizedErrorHandler) sendAlert(alert *Alert) <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        // Сохраняем алерт
        <span class="cov0" title="0">ceh.alerts[alert.ID] = alert

        // Отправляем всем уведомителям
        for _, notifier := range ceh.notifiers </span><span class="cov0" title="0">{
                go func(n AlertNotifier) </span><span class="cov0" title="0">{
                        if err := n.NotifyAlert(alert); err != nil </span><span class="cov0" title="0">{
                                ceh.logger.Printf("Failed to send alert via %s: %v", n.GetName(), err)
                        }</span>
                }(notifier)
        }

        <span class="cov0" title="0">ceh.logger.Printf("Alert sent: %s (Level: %s)", alert.ID, alert.Level.String())</span>
}

// ResolveAlert разрешает алерт.
func (ceh *CentralizedErrorHandler) ResolveAlert(alertID string) error <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        <span class="cov0" title="0">alert, exists := ceh.alerts[alertID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("alert not found: %s", alertID)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        alert.Resolved = true
        alert.ResolvedAt = &amp;now

        ceh.logger.Printf("Alert resolved: %s", alertID)
        return nil</span>
}

// GetAlerts возвращает все алерты.
func (ceh *CentralizedErrorHandler) GetAlerts() map[string]*Alert <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        // Создаем копию для безопасности
        <span class="cov0" title="0">result := make(map[string]*Alert)
        for key, alert := range ceh.alerts </span><span class="cov0" title="0">{
                result[key] = alert
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetActiveAlerts возвращает активные алерты.
func (ceh *CentralizedErrorHandler) GetActiveAlerts() map[string]*Alert <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        <span class="cov0" title="0">result := make(map[string]*Alert)
        for key, alert := range ceh.alerts </span><span class="cov0" title="0">{
                if !alert.Resolved </span><span class="cov0" title="0">{
                        result[key] = alert
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// GetAlertsByLevel возвращает алерты по уровню.
func (ceh *CentralizedErrorHandler) GetAlertsByLevel(level AlertLevel) map[string]*Alert <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        <span class="cov0" title="0">result := make(map[string]*Alert)
        for key, alert := range ceh.alerts </span><span class="cov0" title="0">{
                if alert.Level == level </span><span class="cov0" title="0">{
                        result[key] = alert
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// ClearResolvedAlerts очищает разрешенные алерты.
func (ceh *CentralizedErrorHandler) ClearResolvedAlerts() <span class="cov0" title="0">{
        ceh.mutex &lt;- struct{}{}        // Блокируем
        defer func() </span><span class="cov0" title="0">{ &lt;-ceh.mutex }</span>() // Разблокируем

        <span class="cov0" title="0">for key, alert := range ceh.alerts </span><span class="cov0" title="0">{
                if alert.Resolved </span><span class="cov0" title="0">{
                        delete(ceh.alerts, key)
                }</span>
        }

        <span class="cov0" title="0">ceh.logger.Printf("Cleared resolved alerts")</span>
}

// contains проверяет, содержит ли строка подстроку (case-insensitive).
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (s == substr ||
                        len(s) &gt; len(substr) &amp;&amp;
                                (s[:len(substr)] == substr ||
                                        s[len(s)-len(substr):] == substr ||
                                        containsSubstring(s, substr)))
}</span>

// containsSubstring проверяет наличие подстроки в строке.
func containsSubstring(s, substr string) bool <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package errors provides error handling and alerting functionality.
package errors

import (
        "errors"
        "log"
)

// ErrorHandler обрабатывает ошибки централизованно.
type ErrorHandler struct {
        notifier AdminNotifier
}

// AdminNotifier интерфейс для уведомления администраторов.
type AdminNotifier interface {
        NotifyCriticalError(err *CustomError)
        NotifyTelegramAPIError(err *CustomError, chatID int64)
}

// NewErrorHandler создает новый обработчик ошибок.
func NewErrorHandler(notifier AdminNotifier) *ErrorHandler <span class="cov8" title="1">{
        return &amp;ErrorHandler{
                notifier: notifier,
        }
}</span>

// Handle обрабатывает ошибку с контекстом.
func (h *ErrorHandler) Handle(err error, ctx *RequestContext) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Логируем ошибку
        <span class="cov8" title="1">h.logError(err, ctx)

        // Если это критическая ошибка, уведомляем администраторов
        if h.isCriticalError(err) </span><span class="cov8" title="1">{
                var customErr *CustomError
                if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                        h.notifier.NotifyCriticalError(customErr)
                }</span>
        }

        // Если это ошибка Telegram API, уведомляем администраторов
        <span class="cov8" title="1">if IsTelegramAPIError(err) </span><span class="cov8" title="1">{
                var customErr *CustomError
                if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                        h.notifier.NotifyTelegramAPIError(customErr, ctx.ChatID)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// HandleTelegramError обрабатывает ошибки Telegram API.
func (h *ErrorHandler) HandleTelegramError(err error, chatID, userID int64, operation string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx := NewRequestContext(userID, chatID, operation)

        // Создаем типизированную ошибку
        customErr := NewTelegramError(
                err.Error(),
                "Произошла ошибка при обработке запроса. Попробуйте позже.",
                ctx,
        ).WithCause(err)

        return h.Handle(customErr, ctx)</span>
}

// HandleDatabaseError обрабатывает ошибки базы данных.
func (h *ErrorHandler) HandleDatabaseError(err error, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx := NewRequestContext(userID, chatID, operation)

        // Создаем типизированную ошибку
        customErr := NewDatabaseError(
                err.Error(),
                "Временные проблемы с базой данных. Попробуйте позже.",
                ctx,
        ).WithCause(err)

        return h.Handle(customErr, ctx)</span>
}

// HandleValidationError обрабатывает ошибки валидации.
func (h *ErrorHandler) HandleValidationError(err error, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx := NewRequestContext(userID, chatID, operation)

        // Создаем типизированную ошибку
        customErr := NewValidationError(
                err.Error(),
                "Некорректные данные. Проверьте введенную информацию.",
                ctx,
        ).WithCause(err)

        return h.Handle(customErr, ctx)</span>
}

// HandleCacheError обрабатывает ошибки кэша.
func (h *ErrorHandler) HandleCacheError(err error, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx := NewRequestContext(userID, chatID, operation)

        // Создаем типизированную ошибку
        customErr := NewCacheError(
                err.Error(),
                "Временные проблемы с кэшем. Попробуйте позже.",
                ctx,
        ).WithCause(err)

        return h.Handle(customErr, ctx)</span>
}

// logError логирует ошибку с контекстом.
func (h *ErrorHandler) logError(err error, ctx *RequestContext) <span class="cov8" title="1">{
        var customErr *CustomError
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                log.Printf("[%s] %s: %s (User: %d, Chat: %d, Operation: %s)",
                        customErr.RequestID,
                        customErr.Type.String(),
                        customErr.Message,
                        ctx.UserID,
                        ctx.ChatID,
                        ctx.Operation,
                )
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[%s] Error: %v (User: %d, Chat: %d, Operation: %s)",
                        ctx.RequestID,
                        err,
                        ctx.UserID,
                        ctx.ChatID,
                        ctx.Operation,
                )
        }</span>
}

// isCriticalError определяет, является ли ошибка критической.
func (h *ErrorHandler) isCriticalError(err error) bool <span class="cov8" title="1">{
        var customErr *CustomError
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                // Критические ошибки: Database, Network, Internal
                return customErr.Type == ErrorTypeDatabase ||
                        customErr.Type == ErrorTypeNetwork ||
                        customErr.Type == ErrorTypeInternal
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package errors

import (
        "errors"
        "fmt"
        "time"
)

// Константы для трассировки.
const (
        // maxRandomValue - максимальное значение для генерации случайной части RequestID.
        maxRandomValue = 10000
)

// RequestContext содержит контекст запроса.
type RequestContext struct {
        RequestID string
        UserID    int64
        ChatID    int64
        Operation string
        Timestamp time.Time
}

// NewRequestContext создает новый контекст запроса.
func NewRequestContext(userID, chatID int64, operation string) *RequestContext <span class="cov8" title="1">{
        return &amp;RequestContext{
                RequestID: generateRequestID(),
                UserID:    userID,
                ChatID:    chatID,
                Operation: operation,
                Timestamp: time.Now(),
        }
}</span>

// generateRequestID генерирует уникальный RequestID.
func generateRequestID() string <span class="cov8" title="1">{
        // Используем timestamp + случайные символы для уникальности
        timestamp := time.Now().UnixNano()
        randomPart := time.Now().UnixNano() % maxRandomValue

        return fmt.Sprintf("req_%d_%d", timestamp, randomPart)
}</span>

// WithContext создает ошибку с контекстом.
func WithContext(err error, ctx *RequestContext) *CustomError <span class="cov0" title="0">{
        customErr := &amp;CustomError{
                Type:        ErrorTypeInternal,
                Message:     "context error",
                UserMessage: "internal error",
                Context:     map[string]interface{}{},
                RequestID:   "",
                Timestamp:   time.Now(),
                Cause:       nil,
        }
        if errors.As(err, &amp;customErr) </span><span class="cov0" title="0">{
                customErr.RequestID = ctx.RequestID
                customErr.Context["user_id"] = ctx.UserID
                customErr.Context["chat_id"] = ctx.ChatID
                customErr.Context["operation"] = ctx.Operation

                return customErr
        }</span>

        // Если ошибка не CustomError, оборачиваем её
        <span class="cov0" title="0">return &amp;CustomError{
                Type:        ErrorTypeInternal,
                Message:     err.Error(),
                UserMessage: "internal error",
                RequestID:   ctx.RequestID,
                Context: map[string]interface{}{
                        "user_id":   ctx.UserID,
                        "chat_id":   ctx.ChatID,
                        "operation": ctx.Operation,
                },
                Timestamp: time.Now(),
                Cause:     err,
        }</span>
}

// NewTelegramError создает ошибку Telegram API с контекстом.
func NewTelegramError(message, userMessage string, ctx *RequestContext) *CustomError <span class="cov8" title="1">{
        return &amp;CustomError{
                Type:        ErrorTypeTelegramAPI,
                Message:     message,
                UserMessage: userMessage,
                RequestID:   ctx.RequestID,
                Context: map[string]interface{}{
                        "user_id":   ctx.UserID,
                        "chat_id":   ctx.ChatID,
                        "operation": ctx.Operation,
                },
                Timestamp: time.Now(),
                Cause:     nil,
        }
}</span>

// NewDatabaseError создает ошибку базы данных с контекстом.
func NewDatabaseError(message, userMessage string, ctx *RequestContext) *CustomError <span class="cov8" title="1">{
        return &amp;CustomError{
                Type:        ErrorTypeDatabase,
                Message:     message,
                UserMessage: userMessage,
                RequestID:   ctx.RequestID,
                Context: map[string]interface{}{
                        "user_id":   ctx.UserID,
                        "chat_id":   ctx.ChatID,
                        "operation": ctx.Operation,
                },
                Timestamp: time.Now(),
                Cause:     nil,
        }
}</span>

// NewValidationError создает ошибку валидации с контекстом.
func NewValidationError(message, userMessage string, ctx *RequestContext) *CustomError <span class="cov8" title="1">{
        return &amp;CustomError{
                Type:        ErrorTypeValidation,
                Message:     message,
                UserMessage: userMessage,
                RequestID:   ctx.RequestID,
                Context: map[string]interface{}{
                        "user_id":   ctx.UserID,
                        "chat_id":   ctx.ChatID,
                        "operation": ctx.Operation,
                },
                Timestamp: time.Now(),
                Cause:     nil,
        }
}</span>

// NewCacheError создает ошибку кэша с контекстом.
func NewCacheError(message, userMessage string, ctx *RequestContext) *CustomError <span class="cov8" title="1">{
        return &amp;CustomError{
                Type:        ErrorTypeCache,
                Message:     message,
                UserMessage: userMessage,
                RequestID:   ctx.RequestID,
                Context: map[string]interface{}{
                        "user_id":   ctx.UserID,
                        "chat_id":   ctx.ChatID,
                        "operation": ctx.Operation,
                },
                Timestamp: time.Now(),
                Cause:     nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package errors

import (
        "errors"
        "fmt"
        "time"
)

// ErrorType определяет категорию ошибки.
type ErrorType int

// Типы ошибок для категоризации.
const (
        ErrorTypeTelegramAPI ErrorType = iota
        ErrorTypeDatabase
        ErrorTypeValidation
        ErrorTypeCache
        ErrorTypeNetwork
        ErrorTypeInternal
)

// String возвращает строковое представление типа ошибки.
func (et ErrorType) String() string <span class="cov8" title="1">{
        switch et </span>{
        case ErrorTypeTelegramAPI:<span class="cov8" title="1">
                return "TelegramAPI"</span>
        case ErrorTypeDatabase:<span class="cov8" title="1">
                return "Database"</span>
        case ErrorTypeValidation:<span class="cov8" title="1">
                return "Validation"</span>
        case ErrorTypeCache:<span class="cov8" title="1">
                return "Cache"</span>
        case ErrorTypeNetwork:<span class="cov0" title="0">
                return "Network"</span>
        case ErrorTypeInternal:<span class="cov0" title="0">
                return "Internal"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// CustomError представляет типизированную ошибку с контекстом.
type CustomError struct {
        Type        ErrorType
        Message     string
        UserMessage string
        Context     map[string]interface{}
        RequestID   string
        Timestamp   time.Time
        Cause       error
}

// Error реализует интерфейс error.
func (e *CustomError) Error() string <span class="cov8" title="1">{
        if e.Cause != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("[%s] %s (caused by: %v)", e.Type.String(), e.Message, e.Cause.Error())
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("[%s] %s", e.Type.String(), e.Message)</span>
}

// Unwrap возвращает причину ошибки для error wrapping.
func (e *CustomError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// NewCustomError создает новую типизированную ошибку.
func NewCustomError(errorType ErrorType, message, userMessage, requestID string) *CustomError <span class="cov8" title="1">{
        return &amp;CustomError{
                Type:        errorType,
                Message:     message,
                UserMessage: userMessage,
                Context:     make(map[string]interface{}),
                RequestID:   requestID,
                Timestamp:   time.Now(),
                Cause:       nil,
        }
}</span>

// WithContext добавляет контекст к ошибке.
func (e *CustomError) WithContext(key string, value interface{}) *CustomError <span class="cov0" title="0">{
        e.Context[key] = value

        return e
}</span>

// WithCause добавляет причину ошибки.
func (e *CustomError) WithCause(cause error) *CustomError <span class="cov8" title="1">{
        e.Cause = cause

        return e
}</span>

// IsTelegramAPIError проверяет, является ли ошибка ошибкой Telegram API.
func IsTelegramAPIError(err error) bool <span class="cov8" title="1">{
        customErr := &amp;CustomError{
                Type:        ErrorTypeInternal,
                Message:     "check error",
                UserMessage: "internal error",
                Context:     map[string]interface{}{},
                RequestID:   "",
                Timestamp:   time.Now(),
                Cause:       nil,
        }
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                return customErr.Type == ErrorTypeTelegramAPI
        }</span>

        <span class="cov0" title="0">return false</span>
}

// IsDatabaseError проверяет, является ли ошибка ошибкой базы данных.
func IsDatabaseError(err error) bool <span class="cov8" title="1">{
        customErr := &amp;CustomError{
                Type:        ErrorTypeInternal,
                Message:     "check error",
                UserMessage: "internal error",
                Context:     map[string]interface{}{},
                RequestID:   "",
                Timestamp:   time.Now(),
                Cause:       nil,
        }
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                return customErr.Type == ErrorTypeDatabase
        }</span>

        <span class="cov0" title="0">return false</span>
}

// IsValidationError проверяет, является ли ошибка ошибкой валидации.
func IsValidationError(err error) bool <span class="cov8" title="1">{
        customErr := &amp;CustomError{
                Type:        ErrorTypeInternal,
                Message:     "check error",
                UserMessage: "internal error",
                Context:     map[string]interface{}{},
                RequestID:   "",
                Timestamp:   time.Now(),
                Cause:       nil,
        }
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                return customErr.Type == ErrorTypeValidation
        }</span>

        <span class="cov0" title="0">return false</span>
}

// IsCacheError проверяет, является ли ошибка ошибкой кэша.
func IsCacheError(err error) bool <span class="cov8" title="1">{
        customErr := &amp;CustomError{
                Type:        ErrorTypeInternal,
                Message:     "check error",
                UserMessage: "internal error",
                Context:     map[string]interface{}{},
                RequestID:   "",
                Timestamp:   time.Now(),
                Cause:       nil,
        }
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                return customErr.Type == ErrorTypeCache
        }</span>

        <span class="cov0" title="0">return false</span>
}

// Статические ошибки для замены динамических.
var (
        // ErrInterestAlreadySelected - ошибка валидации.
        ErrInterestAlreadySelected = NewCustomError(
                ErrorTypeValidation, "интерес уже выбран", "Этот интерес уже выбран", "",
        )
        // ErrMaxPrimaryInterestsReached - ошибка валидации.
        ErrMaxPrimaryInterestsReached = NewCustomError(
                ErrorTypeValidation, "достигнут максимум основных интересов",
                "Достигнут максимум основных интересов", "",
        )
        // ErrMinPrimaryInterestsRequired - ошибка валидации.
        ErrMinPrimaryInterestsRequired = NewCustomError(
                ErrorTypeValidation, "необходимо выбрать минимум основных интересов",
                "Необходимо выбрать минимум основных интересов", "",
        )

        // ErrUnsafeFilePath - ошибка файловой системы.
        ErrUnsafeFilePath = NewCustomError(ErrorTypeInternal, "небезопасный путь к файлу", "Ошибка доступа к файлу", "")

        // ErrFeedbackTooShort - ошибка отзывов.
        ErrFeedbackTooShort = NewCustomError(
                ErrorTypeValidation, "отзыв слишком короткий", "Отзыв должен содержать минимум символов", "",
        )
        // ErrFeedbackTooLong - ошибка отзывов.
        ErrFeedbackTooLong = NewCustomError(
                ErrorTypeValidation, "отзыв слишком длинный", "Отзыв превышает максимальную длину", "",
        )
        // ErrFeedbackNotFound - ошибка отзывов.
        ErrFeedbackNotFound = NewCustomError(ErrorTypeDatabase, "отзыв не найден", "Отзыв не найден в базе данных", "")

        // ErrUserNotFound - ошибка пользователей.
        ErrUserNotFound = NewCustomError(ErrorTypeDatabase, "пользователь не найден", "Пользователь не найден", "")

        // ErrTelegramAPIRateLimit - ошибка тестов.
        ErrTelegramAPIRateLimit = NewCustomError(
                ErrorTypeTelegramAPI, "превышен лимит запросов Telegram API", "Превышен лимит запросов", "",
        )
        // ErrRateLimitExceeded - превышен лимит запросов пользователя.
        ErrRateLimitExceeded = NewCustomError(
                ErrorTypeValidation, "превышен лимит запросов пользователя", "Слишком много запросов. Попробуйте позже", "",
        )
        // ErrDatabaseConnectionFailed - ошибка тестов.
        ErrDatabaseConnectionFailed = NewCustomError(
                ErrorTypeDatabase, "ошибка подключения к базе данных", "Ошибка подключения к базе данных", "",
        )
        // ErrInvalidUserInput - ошибка тестов.
        ErrInvalidUserInput = NewCustomError(
                ErrorTypeValidation, "некорректные данные пользователя", "Некорректные данные", "",
        )
        // ErrRedisConnectionFailed - ошибка тестов.
        ErrRedisConnectionFailed = NewCustomError(
                ErrorTypeCache, "ошибка подключения к Redis", "Ошибка подключения к кэшу", "",
        )

        // ===== НОВЫЕ ТИПЫ ОШИБОК =====

        // Ошибки изолированного редактирования
        ErrEditSessionNotFound = NewCustomError(
                ErrorTypeInternal, "сессия редактирования не найдена", "Сессия редактирования не найдена", "",
        )
        ErrEditSessionExpired = NewCustomError(
                ErrorTypeInternal, "сессия редактирования истекла", "Сессия редактирования истекла", "",
        )
        ErrEditSessionInvalid = NewCustomError(
                ErrorTypeValidation, "некорректная сессия редактирования", "Некорректная сессия редактирования", "",
        )

        // Ошибки батчинга
        ErrBatchOperationFailed = NewCustomError(
                ErrorTypeDatabase, "ошибка батчевой операции", "Ошибка при выполнении батчевой операции", "",
        )
        ErrBatchSizeExceeded = NewCustomError(
                ErrorTypeValidation, "превышен размер батча", "Превышен максимальный размер батча", "",
        )
        ErrBatchTimeout = NewCustomError(
                ErrorTypeDatabase, "таймаут батчевой операции", "Превышено время выполнения батчевой операции", "",
        )

        // Ошибки кеширования
        ErrCacheOperationFailed = NewCustomError(
                ErrorTypeCache, "ошибка операции с кэшем", "Ошибка при работе с кэшем", "",
        )
        ErrCacheSerializationFailed = NewCustomError(
                ErrorTypeCache, "ошибка сериализации кэша", "Ошибка сериализации данных кэша", "",
        )
        ErrCacheDeserializationFailed = NewCustomError(
                ErrorTypeCache, "ошибка десериализации кэша", "Ошибка десериализации данных кэша", "",
        )

        // Ошибки трейсинга
        ErrTraceNotFound = NewCustomError(
                ErrorTypeInternal, "трейс не найден", "Трейс запроса не найден", "",
        )
        ErrTraceExpired = NewCustomError(
                ErrorTypeInternal, "трейс истек", "Трейс запроса истек", "",
        )

        // Ошибки метрик
        ErrMetricCollectionFailed = NewCustomError(
                ErrorTypeInternal, "ошибка сбора метрик", "Ошибка при сборе метрик производительности", "",
        )
        ErrMetricExportFailed = NewCustomError(
                ErrorTypeInternal, "ошибка экспорта метрик", "Ошибка при экспорте метрик", "",
        )

        // Ошибки конфигурации
        ErrConfigNotFound = NewCustomError(
                ErrorTypeInternal, "конфигурация не найдена", "Конфигурация не найдена", "",
        )
        ErrConfigInvalid = NewCustomError(
                ErrorTypeValidation, "некорректная конфигурация", "Некорректная конфигурация", "",
        )

        // Ошибки локализации
        ErrLocalizationNotFound = NewCustomError(
                ErrorTypeInternal, "локализация не найдена", "Перевод не найден", "",
        )
        ErrLocalizationInvalid = NewCustomError(
                ErrorTypeValidation, "некорректная локализация", "Некорректная локализация", "",
        )

        // Ошибки уведомлений
        ErrNotificationFailed = NewCustomError(
                ErrorTypeTelegramAPI, "ошибка отправки уведомления", "Ошибка отправки уведомления", "",
        )
        ErrNotificationRateLimit = NewCustomError(
                ErrorTypeTelegramAPI, "превышен лимит уведомлений", "Превышен лимит отправки уведомлений", "",
        )
)
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package localization provides internationalization and translation functionality.
package localization

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"
)

// Localizer предоставляет функциональность локализации.
type Localizer struct {
        db           *sql.DB
        translations map[string]map[string]string
        logger       *logging.ComponentLogger
        errorHandler *errors.ErrorHandler
}

// NewLocalizer создает новый экземпляр Localizer.
func NewLocalizer(db *sql.DB) *Localizer <span class="cov0" title="0">{
        localizer := &amp;Localizer{
                db:           db,
                translations: make(map[string]map[string]string),
                logger:       logging.NewComponentLogger("localization"),
                errorHandler: errors.NewErrorHandler(nil),
        }
        localizer.loadTranslations()

        return localizer
}</span>

func (l *Localizer) loadTranslations() <span class="cov0" title="0">{
        localesPath := l.getLocalesPath()

        if !l.localesDirectoryExists(localesPath) </span><span class="cov0" title="0">{
                l.loadFallbackTranslations()

                return
        }</span>

        <span class="cov0" title="0">l.walkLocalesDirectory(localesPath)</span>
}

// getLocalesPath возвращает путь к директории с переводами.
func (l *Localizer) getLocalesPath() string <span class="cov0" title="0">{
        localesPath := os.Getenv("LOCALES_DIR")
        if localesPath == "" </span><span class="cov0" title="0">{
                localesPath = "./locales"
        }</span>

        <span class="cov0" title="0">return localesPath</span>
}

// localesDirectoryExists проверяет существование директории с переводами.
func (l *Localizer) localesDirectoryExists(localesPath string) bool <span class="cov0" title="0">{
        if _, err := os.Stat(localesPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                l.logger.WarnWithContext(
                        "Locales directory not found, using fallback translations",
                        "", 0, 0, "LoadTranslations",
                        map[string]interface{}{
                                "locales_path": localesPath,
                                "error":        err.Error(),
                        },
                )

                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// walkLocalesDirectory обходит директорию с переводами.
func (l *Localizer) walkLocalesDirectory(localesPath string) <span class="cov0" title="0">{
        err := filepath.WalkDir(localesPath, l.processLocaleFile)
        if err != nil </span><span class="cov0" title="0">{
                l.logger.ErrorWithContext(
                        "Failed to walk locales directory, using fallback translations",
                        "", 0, 0, "LoadTranslations",
                        map[string]interface{}{
                                "locales_path": localesPath,
                                "error":        err.Error(),
                        },
                )
                l.loadFallbackTranslations()
        }</span>
}

// processLocaleFile обрабатывает один файл перевода.
func (l *Localizer) processLocaleFile(path string, d os.DirEntry, err error) error <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.IsDir() || !strings.HasSuffix(strings.ToLower(d.Name()), ".json") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">lang := strings.TrimSuffix(d.Name(), ".json")
        cleanPath := filepath.Clean(path)

        if !l.isPathSafe(cleanPath) </span><span class="cov0" title="0">{
                l.logger.WarnWithContext(
                        "Unsafe file path detected, skipping file",
                        "", 0, 0, "ProcessLocaleFile",
                        map[string]interface{}{
                                "file_path": cleanPath,
                                "language":  lang,
                        },
                )

                return nil
        }</span>

        <span class="cov0" title="0">return l.loadLocaleFile(cleanPath, lang)</span>
}

// isPathSafe проверяет безопасность пути.
func (l *Localizer) isPathSafe(cleanPath string) bool <span class="cov0" title="0">{
        return !strings.Contains(cleanPath, "..") &amp;&amp; !strings.Contains(cleanPath, "~")
}</span>

// loadLocaleFile загружает файл перевода.
func (l *Localizer) loadLocaleFile(cleanPath, lang string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(cleanPath) // #nosec G304 - путь проверен на безопасность
        if err != nil </span><span class="cov0" title="0">{
                l.logger.ErrorWithContext(
                        "Failed to read locale file",
                        "", 0, 0, "LoadLocaleFile",
                        map[string]interface{}{
                                "file_path": cleanPath,
                                "language":  lang,
                                "error":     err.Error(),
                        },
                )

                return fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">var dict map[string]string
        if err := json.Unmarshal(data, &amp;dict); err != nil </span><span class="cov0" title="0">{
                l.logger.ErrorWithContext(
                        "Failed to parse locale file JSON",
                        "", 0, 0, "LoadLocaleFile",
                        map[string]interface{}{
                                "file_path": cleanPath,
                                "language":  lang,
                                "error":     err.Error(),
                        },
                )

                return fmt.Errorf("failed to unmarshal file: %w", err)
        }</span>

        <span class="cov0" title="0">l.translations[lang] = dict
        l.logger.InfoWithContext(
                "Locale file loaded successfully",
                "", 0, 0, "LoadLocaleFile",
                map[string]interface{}{
                        "language":   lang,
                        "keys_count": len(dict),
                        "file_path":  cleanPath,
                },
        )

        return nil</span>
}

// Get возвращает локализованную строку по ключу.
func (l *Localizer) Get(lang, key string) string <span class="cov0" title="0">{
        if dict, ok := l.translations[lang]; ok </span><span class="cov0" title="0">{
                if val, found := dict[key]; found </span><span class="cov0" title="0">{
                        return val
                }</span>
        }
        // Fallback на en
        <span class="cov0" title="0">if dict, ok := l.translations["en"]; ok </span><span class="cov0" title="0">{
                if val, found := dict[key]; found </span><span class="cov0" title="0">{
                        return val
                }</span>
        }
        // Последний fallback - вернуть ключ (чтобы видеть отсутствующие переводы)
        <span class="cov0" title="0">return key</span>
}

// GetWithParams возвращает локализованную строку с подстановкой параметров.
func (l *Localizer) GetWithParams(lang, key string, params map[string]string) string <span class="cov0" title="0">{
        text := l.Get(lang, key)

        for k, v := range params </span><span class="cov0" title="0">{
                placeholder := "{" + k + "}"
                text = strings.ReplaceAll(text, placeholder, v)
        }</span>

        <span class="cov0" title="0">return text</span>
}

// GetLanguageName возвращает локализованное название языка.
func (l *Localizer) GetLanguageName(lang, interfaceLang string) string <span class="cov0" title="0">{
        // Используем ключи типа "language_ru", "language_en" в JSON
        key := "language_" + lang

        return l.Get(interfaceLang, key)
}</span>

// GetInterests возвращает локализованные интересы для указанного языка.
func (l *Localizer) GetInterests(lang string) (map[int]string, error) <span class="cov0" title="0">{
        // Если БД не инициализирована (тесты), возвращаем заглушки
        if l.db == nil </span><span class="cov0" title="0">{
                return l.getFallbackInterests(lang), nil
        }</span>

        <span class="cov0" title="0">return l.loadInterestsFromDB(lang)</span>
}

// getFallbackInterests возвращает заглушки для тестов.
func (l *Localizer) getFallbackInterests(lang string) map[int]string <span class="cov0" title="0">{
        interests := map[int]string{
                1: "Movies",
                2: "Music",
                3: "Sports",
                4: "Travel",
        }

        // Для русского языка используем русские переводы
        if lang == "ru" </span><span class="cov0" title="0">{
                interests = map[int]string{
                        1: "Фильмы",
                        2: "Музыка",
                        3: "Спорт",
                        4: "Путешествия",
                }
        }</span>

        // Для испанского языка
        <span class="cov0" title="0">if lang == "es" </span><span class="cov0" title="0">{
                interests = map[int]string{
                        1: "Películas",
                        2: "Música",
                        3: "Deportes",
                        4: "Viajes",
                }
        }</span>

        // Для китайского языка
        <span class="cov0" title="0">if lang == "zh" </span><span class="cov0" title="0">{
                interests = map[int]string{
                        1: "电影",
                        2: "音乐",
                        3: "运动",
                        4: "旅行",
                }
        }</span>

        <span class="cov0" title="0">return interests</span>
}

// loadInterestsFromDB загружает интересы из базы данных.
func (l *Localizer) loadInterestsFromDB(lang string) (map[int]string, error) <span class="cov0" title="0">{
        interests := make(map[int]string)
        query := l.getInterestsQuery()

        rows, err := l.db.QueryContext(context.Background(), query, lang)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback на английский при ошибке
                rows, err = l.db.QueryContext(context.Background(), query, "en")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load interests: %w", err)
                }</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        l.logger.ErrorWithContext(
                                "Failed to close database rows",
                                "", 0, 0, "LoadInterestsFromDB",
                                map[string]interface{}{
                                        "error": closeErr.Error(),
                                },
                        )
                }</span>
        }()

        <span class="cov0" title="0">l.scanInterestsRows(rows, interests)

        return interests, nil</span>
}

// getInterestsQuery возвращает SQL запрос для получения интересов.
func (l *Localizer) getInterestsQuery() string <span class="cov0" title="0">{
        return `
                SELECT i.id,
                           CASE
                                   WHEN it.name IS NOT NULL AND TRIM(it.name) != '' THEN it.name
                                   ELSE i.key_name
                           END as name
                FROM interests i
                LEFT JOIN interest_translations it ON i.id = it.interest_id AND it.language_code = $1
                ORDER BY i.id
        `
}</span>

// scanInterestsRows сканирует строки результата запроса интересов.
func (l *Localizer) scanInterestsRows(rows *sql.Rows, interests map[int]string) <span class="cov0" title="0">{
        for rows.Next() </span><span class="cov0" title="0">{
                var interestID int

                var name string

                err := rows.Scan(&amp;interestID, &amp;name)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">interests[interestID] = name</span>
        }

        <span class="cov0" title="0">l.logger.DebugWithContext(
                "Interests loaded from database",
                "", 0, 0, "ScanInterestsRows",
                map[string]interface{}{
                        "interests_count": len(interests),
                },
        )</span>
}

// loadFallbackTranslations загружает базовые переводы для тестов.
func (l *Localizer) loadFallbackTranslations() <span class="cov0" title="0">{
        // Английский
        l.translations["en"] = map[string]string{
                "welcome_message":         "👋 Hi, {name}! Welcome to Language Exchange Bot!",
                "choose_native_language":  "🌍 Choose your native language:",
                "choose_target_language":  "📚 What language are you learning?",
                "profile_summary_title":   "👤 Your profile",
                "profile_field_native":    "Native language",
                "profile_field_target":    "Learning language",
                "profile_field_interests": "Interests",
                "unknown_command":         "❓ Unknown command. Use /start to begin",
        }

        // Русский
        // Инициализация базовых переводов для всех языков
        l.translations["ru"] = map[string]string{
                "welcome_message":         "👋 Привет, {name}! Добро пожаловать в Language Exchange Bot!",
                "choose_native_language":  "🌍 Выбери свой родной язык:",
                "choose_target_language":  "📚 Какой язык ты изучаешь?",
                "profile_summary_title":   "👤 Твой профиль",
                "profile_field_native":    "Родной язык",
                "profile_field_target":    "Изучаемый язык",
                "profile_field_interests": "Интересы",
                "unknown_command":         "❓ Неизвестная команда. Используй /start для начала",
        }

        l.translations["en"] = map[string]string{
                "welcome_message":         "👋 Hi, {name}! Welcome to Language Exchange Bot!",
                "choose_native_language":  "🌍 Choose your native language:",
                "choose_target_language":  "📚 What language are you learning?",
                "profile_summary_title":   "👤 Your profile",
                "profile_field_native":    "Native language",
                "profile_field_target":    "Target language",
                "profile_field_interests": "Interests",
                "unknown_command":         "❓ Unknown command. Use /start to begin",
        }

        l.translations["es"] = map[string]string{
                "welcome_message":         "👋 ¡Hola, {name}! ¡Bienvenido a Language Exchange Bot!",
                "choose_native_language":  "🌍 Elige tu idioma nativo:",
                "choose_target_language":  "📚 ¿Qué idioma estás aprendiendo?",
                "profile_summary_title":   "👤 Tu perfil",
                "profile_field_native":    "Idioma nativo",
                "profile_field_target":    "Idioma de aprendizaje",
                "profile_field_interests": "Intereses",
                "unknown_command":         "❓ Comando desconocido. Usa /start para comenzar",
        }

        l.translations["zh"] = map[string]string{
                "welcome_message":         "👋 你好，{name}！欢迎使用语言交换机器人！",
                "choose_native_language":  "🌍 选择你的母语：",
                "choose_target_language":  "📚 你正在学习什么语言？",
                "profile_summary_title":   "👤 你的个人资料",
                "profile_field_native":    "母语",
                "profile_field_target":    "学习语言",
                "profile_field_interests": "兴趣",
                "unknown_command":         "❓ 未知命令。使用 /start 开始",
        }
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package logging

import (
        "errors"
        customErrors "language-exchange-bot/internal/errors"
        "time"
)

// ComponentLogger предоставляет специализированное логирование для компонентов.
type ComponentLogger struct {
        *Logger
}

// NewComponentLogger создает логгер для компонента.
func NewComponentLogger(component string) *ComponentLogger <span class="cov8" title="1">{
        return &amp;ComponentLogger{
                Logger: NewLoggerFromEnv(component),
        }
}</span>

// TelegramLogger предоставляет логирование для Telegram бота.
type TelegramLogger struct {
        *ComponentLogger
}

// NewTelegramLogger создает логгер для Telegram бота.
func NewTelegramLogger() *TelegramLogger <span class="cov8" title="1">{
        return &amp;TelegramLogger{
                ComponentLogger: NewComponentLogger("telegram"),
        }
}</span>

// LogMessageReceived логирует получение сообщения.
func (tl *TelegramLogger) LogMessageReceived(chatID, userID int64, text, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Message received",
                requestID,
                userID,
                chatID,
                "HandleMessage",
                map[string]interface{}{
                        "text_length": len(text),
                        "has_text":    text != "",
                },
        )
}</span>

// LogMessageSent логирует отправку сообщения.
func (tl *TelegramLogger) LogMessageSent(chatID, userID int64, text, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Message sent",
                requestID,
                userID,
                chatID,
                "SendMessage",
                map[string]interface{}{
                        "text_length": len(text),
                },
        )
}</span>

// LogCallbackReceived логирует получение callback query.
func (tl *TelegramLogger) LogCallbackReceived(chatID, userID int64, data, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Callback received",
                requestID,
                userID,
                chatID,
                "HandleCallback",
                map[string]interface{}{
                        "callback_data": data,
                },
        )
}</span>

// LogCommandExecuted логирует выполнение команды.
func (tl *TelegramLogger) LogCommandExecuted(chatID, userID int64, command, requestID string) <span class="cov8" title="1">{
        tl.InfoWithContext(
                "Command executed",
                requestID,
                userID,
                chatID,
                "ExecuteCommand",
                map[string]interface{}{
                        "command": command,
                },
        )
}</span>

// LogError логирует ошибку с контекстом.
func (tl *TelegramLogger) LogError(err error, chatID, userID int64, operation, requestID string) <span class="cov8" title="1">{
        customErr := &amp;customErrors.CustomError{}
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                tl.ErrorWithContext(
                        "Error occurred",
                        requestID,
                        userID,
                        chatID,
                        operation,
                        map[string]interface{}{
                                "error_type": customErr.Type.String(),
                                "error_msg":  customErr.Message,
                                "user_msg":   customErr.UserMessage,
                        },
                )
        }</span> else<span class="cov0" title="0"> {
                tl.ErrorWithContext(
                        "Error occurred",
                        requestID,
                        userID,
                        chatID,
                        operation,
                        map[string]interface{}{
                                "error_msg": err.Error(),
                        },
                )
        }</span>
}

// DatabaseLogger предоставляет логирование для базы данных.
type DatabaseLogger struct {
        *ComponentLogger
}

// NewDatabaseLogger создает логгер для базы данных.
func NewDatabaseLogger() *DatabaseLogger <span class="cov8" title="1">{
        return &amp;DatabaseLogger{
                ComponentLogger: NewComponentLogger("database"),
        }
}</span>

// LogQueryExecuted логирует выполнение запроса.
func (dl *DatabaseLogger) LogQueryExecuted(query string, duration time.Duration, requestID string) <span class="cov8" title="1">{
        dl.DebugWithContext(
                "Query executed",
                requestID,
                0,
                0,
                "ExecuteQuery",
                map[string]interface{}{
                        "query":    query,
                        "duration": duration.String(),
                },
        )
}</span>

// LogConnectionEstablished логирует установление соединения.
func (dl *DatabaseLogger) LogConnectionEstablished(requestID string) <span class="cov8" title="1">{
        dl.InfoWithContext(
                "Database connection established",
                requestID,
                0,
                0,
                "Connect",
        )
}</span>

// LogConnectionFailed логирует ошибку соединения.
func (dl *DatabaseLogger) LogConnectionFailed(err error, requestID string) <span class="cov8" title="1">{
        dl.ErrorWithContext(
                "Database connection failed",
                requestID,
                0,
                0,
                "Connect",
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>

// LogTransactionStarted логирует начало транзакции.
func (dl *DatabaseLogger) LogTransactionStarted(requestID string) <span class="cov8" title="1">{
        dl.DebugWithContext(
                "Transaction started",
                requestID,
                0,
                0,
                "BeginTransaction",
        )
}</span>

// LogTransactionCommitted логирует коммит транзакции.
func (dl *DatabaseLogger) LogTransactionCommitted(requestID string) <span class="cov8" title="1">{
        dl.DebugWithContext(
                "Transaction committed",
                requestID,
                0,
                0,
                "CommitTransaction",
        )
}</span>

// LogTransactionRolledBack логирует откат транзакции.
func (dl *DatabaseLogger) LogTransactionRolledBack(err error, requestID string) <span class="cov0" title="0">{
        dl.WarnWithContext(
                "Transaction rolled back",
                requestID,
                0,
                0,
                "RollbackTransaction",
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>

// CacheLogger предоставляет логирование для кэша.
type CacheLogger struct {
        *ComponentLogger
}

// NewCacheLogger создает логгер для кэша.
func NewCacheLogger() *CacheLogger <span class="cov8" title="1">{
        return &amp;CacheLogger{
                ComponentLogger: NewComponentLogger("cache"),
        }
}</span>

// LogCacheHit логирует попадание в кэш.
func (cl *CacheLogger) LogCacheHit(key string, requestID string) <span class="cov8" title="1">{
        cl.DebugWithContext(
                "Cache hit",
                requestID,
                0,
                0,
                "GetFromCache",
                map[string]interface{}{
                        "key": key,
                },
        )
}</span>

// LogCacheMiss логирует промах кэша.
func (cl *CacheLogger) LogCacheMiss(key string, requestID string) <span class="cov8" title="1">{
        cl.DebugWithContext(
                "Cache miss",
                requestID,
                0,
                0,
                "GetFromCache",
                map[string]interface{}{
                        "key": key,
                },
        )
}</span>

// LogCacheSet логирует установку значения в кэш.
func (cl *CacheLogger) LogCacheSet(key string, ttl time.Duration, requestID string) <span class="cov8" title="1">{
        cl.DebugWithContext(
                "Cache set",
                requestID,
                0,
                0,
                "SetToCache",
                map[string]interface{}{
                        "key": key,
                        "ttl": ttl.String(),
                },
        )
}</span>

// LogCacheInvalidated логирует инвалидацию кэша.
func (cl *CacheLogger) LogCacheInvalidated(pattern string, requestID string) <span class="cov8" title="1">{
        cl.InfoWithContext(
                "Cache invalidated",
                requestID,
                0,
                0,
                "InvalidateCache",
                map[string]interface{}{
                        "pattern": pattern,
                },
        )
}</span>

// LogCacheError логирует ошибку кэша.
func (cl *CacheLogger) LogCacheError(err error, operation, requestID string) <span class="cov8" title="1">{
        cl.ErrorWithContext(
                "Cache error",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>

// ValidationLogger предоставляет логирование для валидации.
type ValidationLogger struct {
        *ComponentLogger
}

// NewValidationLogger создает логгер для валидации.
func NewValidationLogger() *ValidationLogger <span class="cov8" title="1">{
        return &amp;ValidationLogger{
                ComponentLogger: NewComponentLogger("validation"),
        }
}</span>

// LogValidationPassed логирует успешную валидацию.
func (vl *ValidationLogger) LogValidationPassed(operation string, requestID string) <span class="cov8" title="1">{
        vl.DebugWithContext(
                "Validation passed",
                requestID,
                0,
                0,
                operation,
        )
}</span>

// LogValidationFailed логирует неудачную валидацию.
func (vl *ValidationLogger) LogValidationFailed(operation string, errors map[string][]string, requestID string) <span class="cov8" title="1">{
        vl.WarnWithContext(
                "Validation failed",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "validation_errors": errors,
                },
        )
}</span>

// LogValidationError логирует ошибку валидации.
func (vl *ValidationLogger) LogValidationError(err error, operation, requestID string) <span class="cov8" title="1">{
        vl.ErrorWithContext(
                "Validation error",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "error": err.Error(),
                },
        )
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package logging

import (
        "errors"
        customErrors "language-exchange-bot/internal/errors"
)

// LoggingService provides centralized logging for all components.
// The name includes "Logging" prefix for clarity, even though it may cause stuttering with the package name.
type LoggingService struct {
        telegramLogger   *TelegramLogger
        databaseLogger   *DatabaseLogger
        cacheLogger      *CacheLogger
        validationLogger *ValidationLogger
        errorHandler     *customErrors.ErrorHandler
}

// NewLoggingService создает новый сервис логирования.
func NewLoggingService(errorHandler *customErrors.ErrorHandler) *LoggingService <span class="cov8" title="1">{
        return &amp;LoggingService{
                telegramLogger:   NewTelegramLogger(),
                databaseLogger:   NewDatabaseLogger(),
                cacheLogger:      NewCacheLogger(),
                validationLogger: NewValidationLogger(),
                errorHandler:     errorHandler,
        }
}</span>

// Telegram возвращает логгер для Telegram.
func (ls *LoggingService) Telegram() *TelegramLogger <span class="cov0" title="0">{
        return ls.telegramLogger
}</span>

// Database возвращает логгер для базы данных.
func (ls *LoggingService) Database() *DatabaseLogger <span class="cov0" title="0">{
        return ls.databaseLogger
}</span>

// Cache возвращает логгер для кэша.
func (ls *LoggingService) Cache() *CacheLogger <span class="cov0" title="0">{
        return ls.cacheLogger
}</span>

// Validation возвращает логгер для валидации.
func (ls *LoggingService) Validation() *ValidationLogger <span class="cov0" title="0">{
        return ls.validationLogger
}</span>

// LogErrorWithContext логирует ошибку с полным контекстом.
func (ls *LoggingService) LogErrorWithContext(err error, requestID string, userID, chatID int64, operation, component string) <span class="cov8" title="1">{
        customErr := &amp;customErrors.CustomError{}
        if errors.As(err, &amp;customErr) </span><span class="cov8" title="1">{
                // Логируем в зависимости от типа ошибки
                switch customErr.Type </span>{
                case customErrors.ErrorTypeTelegramAPI:<span class="cov8" title="1">
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                case customErrors.ErrorTypeDatabase:<span class="cov0" title="0">
                        ls.databaseLogger.ErrorWithContext(
                                "Database error",
                                requestID,
                                userID,
                                chatID,
                                operation,
                                map[string]interface{}{
                                        "error_type": customErr.Type.String(),
                                        "error_msg":  customErr.Message,
                                        "user_msg":   customErr.UserMessage,
                                },
                        )</span>
                case customErrors.ErrorTypeCache:<span class="cov0" title="0">
                        ls.cacheLogger.LogCacheError(err, operation, requestID)</span>
                case customErrors.ErrorTypeValidation:<span class="cov0" title="0">
                        ls.validationLogger.LogValidationError(err, operation, requestID)</span>
                case customErrors.ErrorTypeNetwork:<span class="cov0" title="0">
                        // Сетевые ошибки логируем как database ошибки
                        ls.databaseLogger.ErrorWithContext(
                                "Network error",
                                requestID,
                                userID,
                                chatID,
                                operation,
                                map[string]interface{}{
                                        "error_type": customErr.Type.String(),
                                        "error_msg":  customErr.Message,
                                        "user_msg":   customErr.UserMessage,
                                },
                        )</span>
                case customErrors.ErrorTypeInternal:<span class="cov0" title="0">
                        // Внутренние ошибки логируем в общий логгер
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                default:<span class="cov0" title="0">
                        // Логируем в общий логгер
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                }
        } else<span class="cov0" title="0"> {
                // Логируем в зависимости от компонента
                switch component </span>{
                case "telegram":<span class="cov0" title="0">
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                case "database":<span class="cov0" title="0">
                        ls.databaseLogger.ErrorWithContext(
                                "Database error",
                                requestID,
                                userID,
                                chatID,
                                operation,
                                map[string]interface{}{
                                        "error": err.Error(),
                                },
                        )</span>
                case "cache":<span class="cov0" title="0">
                        ls.cacheLogger.LogCacheError(err, operation, requestID)</span>
                case "validation":<span class="cov0" title="0">
                        ls.validationLogger.LogValidationError(err, operation, requestID)</span>
                default:<span class="cov0" title="0">
                        ls.telegramLogger.LogError(err, chatID, userID, operation, requestID)</span>
                }
        }
}

// LogRequestStart логирует начало запроса.
func (ls *LoggingService) LogRequestStart(requestID string, userID, chatID int64, operation string) <span class="cov8" title="1">{
        ls.telegramLogger.InfoWithContext(
                "Request started",
                requestID,
                userID,
                chatID,
                operation,
        )
}</span>

// LogRequestEnd логирует завершение запроса.
func (ls *LoggingService) LogRequestEnd(requestID string, userID, chatID int64, operation string, success bool) <span class="cov8" title="1">{
        level := "completed"
        if !success </span><span class="cov8" title="1">{
                level = "failed"
        }</span>

        <span class="cov8" title="1">ls.telegramLogger.InfoWithContext(
                "Request "+level,
                requestID,
                userID,
                chatID,
                operation,
                map[string]interface{}{
                        "success": success,
                },
        )</span>
}

// LogPerformance логирует метрики производительности.
func (ls *LoggingService) LogPerformance(
        operation string,
        duration string,
        requestID string,
        fields map[string]interface{},
) <span class="cov8" title="1">{
        ls.telegramLogger.InfoWithContext(
                "Performance metric",
                requestID,
                0,
                0,
                operation,
                map[string]interface{}{
                        "duration": duration,
                        "fields":   fields,
                },
        )
}</span>

// LogSecurityEvent логирует события безопасности.
func (ls *LoggingService) LogSecurityEvent(event string, userID, chatID int64, requestID string, fields map[string]interface{}) <span class="cov8" title="1">{
        ls.telegramLogger.WarnWithContext(
                "Security event: "+event,
                requestID,
                userID,
                chatID,
                "SecurityEvent",
                fields,
        )
}</span>

// LogAdminAction логирует действия администратора.
func (ls *LoggingService) LogAdminAction(action string, adminID, targetUserID int64, requestID string, fields map[string]interface{}) <span class="cov8" title="1">{
        ls.telegramLogger.InfoWithContext(
                "Admin action: "+action,
                requestID,
                adminID,
                0,
                "AdminAction",
                map[string]interface{}{
                        "target_user_id": targetUserID,
                        "fields":         fields,
                },
        )
}</span>

// SetLogLevel устанавливает уровень логирования для всех компонентов.
func (ls *LoggingService) SetLogLevel(level LogLevel) <span class="cov8" title="1">{
        ls.telegramLogger.SetLevel(level)
        ls.databaseLogger.SetLevel(level)
        ls.cacheLogger.SetLevel(level)
        ls.validationLogger.SetLevel(level)
}</span>

// GetLogLevel возвращает текущий уровень логирования.
func (ls *LoggingService) GetLogLevel() LogLevel <span class="cov8" title="1">{
        return ls.telegramLogger.GetLevel()
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package logging provides structured logging functionality.
package logging

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"
)

// LogLevel определяет уровень логирования.
type LogLevel int

const (
        // DEBUG represents debug log level for detailed information.
        DEBUG LogLevel = iota
        // INFO represents info log level for general information.
        INFO
        // WARN represents warning log level for non-critical issues.
        WARN
        // ERROR represents error log level for critical issues.
        ERROR
)

// String возвращает строковое представление уровня логирования.
func (ll LogLevel) String() string <span class="cov8" title="1">{
        switch ll </span>{
        case DEBUG:<span class="cov8" title="1">
                return "DEBUG"</span>
        case INFO:<span class="cov8" title="1">
                return "INFO"</span>
        case WARN:<span class="cov8" title="1">
                return "WARN"</span>
        case ERROR:<span class="cov8" title="1">
                return "ERROR"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// ParseLogLevel парсит строку в LogLevel.
func ParseLogLevel(level string) LogLevel <span class="cov8" title="1">{
        switch level </span>{
        case "DEBUG":<span class="cov8" title="1">
                return DEBUG</span>
        case "INFO":<span class="cov8" title="1">
                return INFO</span>
        case "WARN":<span class="cov8" title="1">
                return WARN</span>
        case "ERROR":<span class="cov8" title="1">
                return ERROR</span>
        default:<span class="cov8" title="1">
                return INFO</span>
        }
}

// LogEntry представляет структурированную запись лога.
type LogEntry struct {
        Timestamp time.Time              `json:"timestamp"`
        Level     LogLevel               `json:"level"`
        Message   string                 `json:"message"`
        RequestID string                 `json:"requestId,omitempty"`
        UserID    int64                  `json:"userId,omitempty"`
        ChatID    int64                  `json:"chatId,omitempty"`
        Operation string                 `json:"operation,omitempty"`
        Component string                 `json:"component,omitempty"`
        Fields    map[string]interface{} `json:"fields,omitempty"`
        Error     string                 `json:"error,omitempty"`
}

// Logger предоставляет структурированное логирование.
type Logger struct {
        level     LogLevel
        component string
}

// NewLogger создает новый логгер.
func NewLogger(level LogLevel, component string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                level:     level,
                component: component,
        }
}</span>

// NewLoggerFromEnv создает логгер из переменных окружения.
func NewLoggerFromEnv(component string) *Logger <span class="cov8" title="1">{
        level := ParseLogLevel(os.Getenv("LOG_LEVEL"))

        return NewLogger(level, component)
}</span>

// Debug логирует сообщение уровня DEBUG.
func (l *Logger) Debug(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(DEBUG, message, fields...)
}</span>

// Info логирует сообщение уровня INFO.
func (l *Logger) Info(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(INFO, message, fields...)
}</span>

// Warn логирует сообщение уровня WARN.
func (l *Logger) Warn(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(WARN, message, fields...)
}</span>

// Error логирует сообщение уровня ERROR.
func (l *Logger) Error(message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        l.log(ERROR, message, fields...)
}</span>

// DebugWithContext логирует сообщение уровня DEBUG с контекстом.
func (l *Logger) DebugWithContext(
        message string,
        requestID string,
        userID,
        chatID int64,
        operation string,
        fields ...map[string]interface{},
) <span class="cov8" title="1">{
        entry := l.createLogEntry(DEBUG, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// InfoWithContext логирует сообщение уровня INFO с контекстом.
func (l *Logger) InfoWithContext(
        message string,
        requestID string,
        userID,
        chatID int64,
        operation string,
        fields ...map[string]interface{},
) <span class="cov8" title="1">{
        entry := l.createLogEntry(INFO, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// WarnWithContext логирует сообщение уровня WARN с контекстом.
func (l *Logger) WarnWithContext(
        message string,
        requestID string,
        userID,
        chatID int64,
        operation string,
        fields ...map[string]interface{},
) <span class="cov8" title="1">{
        entry := l.createLogEntry(WARN, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// ErrorWithContext логирует сообщение уровня ERROR с контекстом.
func (l *Logger) ErrorWithContext(
        message string,
        requestID string,
        userID,
        chatID int64,
        operation string,
        fields ...map[string]interface{},
) <span class="cov8" title="1">{
        entry := l.createLogEntry(ERROR, message, requestID, userID, chatID, operation, fields...)
        l.writeLog(entry)
}</span>

// log внутренний метод для логирования.
func (l *Logger) log(level LogLevel, message string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">entry := l.createLogEntry(level, message, "", 0, 0, "", fields...)
        l.writeLog(entry)</span>
}

// createLogEntry создает структурированную запись лога.
func (l *Logger) createLogEntry(level LogLevel, message string, requestID string, userID, chatID int64, operation string, fields ...map[string]interface{}) *LogEntry <span class="cov8" title="1">{
        entry := &amp;LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Message:   message,
                Component: l.component,
        }

        if requestID != "" </span><span class="cov8" title="1">{
                entry.RequestID = requestID
        }</span>

        <span class="cov8" title="1">if userID &gt; 0 </span><span class="cov8" title="1">{
                entry.UserID = userID
        }</span>

        <span class="cov8" title="1">if chatID &gt; 0 </span><span class="cov8" title="1">{
                entry.ChatID = chatID
        }</span>

        <span class="cov8" title="1">if operation != "" </span><span class="cov8" title="1">{
                entry.Operation = operation
        }</span>

        // Объединяем все поля
        <span class="cov8" title="1">if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                entry.Fields = make(map[string]interface{})

                for _, fieldMap := range fields </span><span class="cov8" title="1">{
                        for key, value := range fieldMap </span><span class="cov8" title="1">{
                                entry.Fields[key] = value
                        }</span>
                }
        }

        <span class="cov8" title="1">return entry</span>
}

// writeLog записывает лог в формате JSON.
func (l *Logger) writeLog(entry *LogEntry) <span class="cov8" title="1">{
        if entry.Level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">jsonData, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback на простое логирование
                log.Printf("[%s] %s: %s", entry.Level.String(), entry.Component, entry.Message)

                return
        }</span>

        // Выводим в stdout для структурированного логирования
        <span class="cov8" title="1">fmt.Println(string(jsonData))</span>
}

// SetLevel устанавливает уровень логирования.
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.level = level
}</span>

// GetLevel возвращает текущий уровень логирования.
func (l *Logger) GetLevel() LogLevel <span class="cov8" title="1">{
        return l.level
}</span>

// WithFields creates a new logger with additional fields.
func (l *Logger) WithFields(_ map[string]interface{}) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                level:     l.level,
                component: l.component,
        }
}</span>

// WithComponent создает новый логгер с указанным компонентом.
func (l *Logger) WithComponent(component string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                level:     l.level,
                component: component,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package logging provides performance metrics and monitoring.
package logging

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "sync"
        "time"
)

// MetricType определяет тип метрики.
type MetricType string

const (
        MetricTypeCounter   MetricType = "counter"
        MetricTypeGauge     MetricType = "gauge"
        MetricTypeHistogram MetricType = "histogram"
        MetricTypeTimer     MetricType = "timer"
)

// Metric представляет отдельную метрику.
type Metric struct {
        Name      string                 `json:"name"`
        Type      MetricType             `json:"type"`
        Value     float64                `json:"value"`
        Labels    map[string]string      `json:"labels"`
        Timestamp time.Time              `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata"`
}

// MetricCollector собирает и хранит метрики.
type MetricCollector struct {
        metrics map[string]*Metric
        mutex   sync.RWMutex
        logger  *log.Logger
}

// NewMetricCollector создает новый сборщик метрик.
func NewMetricCollector() *MetricCollector <span class="cov0" title="0">{
        return &amp;MetricCollector{
                metrics: make(map[string]*Metric),
                logger:  log.New(os.Stdout, "[METRICS] ", log.LstdFlags),
        }
}</span>

// IncrementCounter увеличивает счетчик.
func (mc *MetricCollector) IncrementCounter(name string, labels map[string]string) <span class="cov0" title="0">{
        mc.mutex.Lock()
        defer mc.mutex.Unlock()

        key := mc.getMetricKey(name, labels)
        metric, exists := mc.metrics[key]
        if !exists </span><span class="cov0" title="0">{
                metric = &amp;Metric{
                        Name:      name,
                        Type:      MetricTypeCounter,
                        Value:     0,
                        Labels:    labels,
                        Timestamp: time.Now(),
                        Metadata:  make(map[string]interface{}),
                }
                mc.metrics[key] = metric
        }</span>

        <span class="cov0" title="0">metric.Value++
        metric.Timestamp = time.Now()</span>
}

// SetGauge устанавливает значение gauge.
func (mc *MetricCollector) SetGauge(name string, value float64, labels map[string]string) <span class="cov0" title="0">{
        mc.mutex.Lock()
        defer mc.mutex.Unlock()

        key := mc.getMetricKey(name, labels)
        metric := &amp;Metric{
                Name:      name,
                Type:      MetricTypeGauge,
                Value:     value,
                Labels:    labels,
                Timestamp: time.Now(),
                Metadata:  make(map[string]interface{}),
        }
        mc.metrics[key] = metric
}</span>

// RecordHistogram записывает значение в гистограмму.
func (mc *MetricCollector) RecordHistogram(name string, value float64, labels map[string]string) <span class="cov0" title="0">{
        mc.mutex.Lock()
        defer mc.mutex.Unlock()

        key := mc.getMetricKey(name, labels)
        metric, exists := mc.metrics[key]
        if !exists </span><span class="cov0" title="0">{
                metric = &amp;Metric{
                        Name:      name,
                        Type:      MetricTypeHistogram,
                        Value:     0,
                        Labels:    labels,
                        Timestamp: time.Now(),
                        Metadata:  make(map[string]interface{}),
                }
                mc.metrics[key] = metric
        }</span>

        // Для гистограммы храним статистику
        <span class="cov0" title="0">if metric.Metadata["count"] == nil </span><span class="cov0" title="0">{
                metric.Metadata["count"] = 0
                metric.Metadata["sum"] = 0.0
                metric.Metadata["min"] = value
                metric.Metadata["max"] = value
        }</span>

        <span class="cov0" title="0">metric.Metadata["count"] = metric.Metadata["count"].(int) + 1
        metric.Metadata["sum"] = metric.Metadata["sum"].(float64) + value

        if value &lt; metric.Metadata["min"].(float64) </span><span class="cov0" title="0">{
                metric.Metadata["min"] = value
        }</span>
        <span class="cov0" title="0">if value &gt; metric.Metadata["max"].(float64) </span><span class="cov0" title="0">{
                metric.Metadata["max"] = value
        }</span>

        <span class="cov0" title="0">metric.Value = metric.Metadata["sum"].(float64) / float64(metric.Metadata["count"].(int))
        metric.Timestamp = time.Now()</span>
}

// RecordTimer записывает время выполнения операции.
func (mc *MetricCollector) RecordTimer(name string, duration time.Duration, labels map[string]string) <span class="cov0" title="0">{
        mc.RecordHistogram(name, float64(duration.Milliseconds()), labels)
}</span>

// GetMetric возвращает метрику по имени и лейблам.
func (mc *MetricCollector) GetMetric(name string, labels map[string]string) (*Metric, bool) <span class="cov0" title="0">{
        mc.mutex.RLock()
        defer mc.mutex.RUnlock()

        key := mc.getMetricKey(name, labels)
        metric, exists := mc.metrics[key]
        return metric, exists
}</span>

// GetAllMetrics возвращает все метрики.
func (mc *MetricCollector) GetAllMetrics() map[string]*Metric <span class="cov0" title="0">{
        mc.mutex.RLock()
        defer mc.mutex.RUnlock()

        // Создаем копию для безопасности
        result := make(map[string]*Metric)
        for key, metric := range mc.metrics </span><span class="cov0" title="0">{
                result[key] = metric
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetMetricsByType возвращает метрики определенного типа.
func (mc *MetricCollector) GetMetricsByType(metricType MetricType) map[string]*Metric <span class="cov0" title="0">{
        mc.mutex.RLock()
        defer mc.mutex.RUnlock()

        result := make(map[string]*Metric)
        for key, metric := range mc.metrics </span><span class="cov0" title="0">{
                if metric.Type == metricType </span><span class="cov0" title="0">{
                        result[key] = metric
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// ClearMetrics очищает все метрики.
func (mc *MetricCollector) ClearMetrics() <span class="cov0" title="0">{
        mc.mutex.Lock()
        defer mc.mutex.Unlock()

        mc.metrics = make(map[string]*Metric)
}</span>

// ExportMetrics экспортирует метрики в JSON.
func (mc *MetricCollector) ExportMetrics() ([]byte, error) <span class="cov0" title="0">{
        mc.mutex.RLock()
        defer mc.mutex.RUnlock()

        return json.Marshal(mc.metrics)
}</span>

// LogMetrics логирует все метрики.
func (mc *MetricCollector) LogMetrics() <span class="cov0" title="0">{
        mc.mutex.RLock()
        defer mc.mutex.RUnlock()

        for key, metric := range mc.metrics </span><span class="cov0" title="0">{
                metricData := map[string]interface{}{
                        "metric_key": key,
                        "metric":     metric,
                        "timestamp":  time.Now().Format(time.RFC3339),
                }

                jsonData, err := json.Marshal(metricData)
                if err != nil </span><span class="cov0" title="0">{
                        mc.logger.Printf("Failed to marshal metric data: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">mc.logger.Printf("%s", string(jsonData))</span>
        }
}

// getMetricKey создает ключ для метрики.
func (mc *MetricCollector) getMetricKey(name string, labels map[string]string) string <span class="cov0" title="0">{
        key := name
        for labelKey, labelValue := range labels </span><span class="cov0" title="0">{
                key += fmt.Sprintf("_%s_%s", labelKey, labelValue)
        }</span>
        <span class="cov0" title="0">return key</span>
}

// PerformanceMonitor предоставляет мониторинг производительности.
type PerformanceMonitor struct {
        collector *MetricCollector
        tracing   *TracingService
        logger    *log.Logger
}

// NewPerformanceMonitor создает новый монитор производительности.
func NewPerformanceMonitor() *PerformanceMonitor <span class="cov0" title="0">{
        return &amp;PerformanceMonitor{
                collector: NewMetricCollector(),
                tracing:   NewTracingService(),
                logger:    log.New(os.Stdout, "[PERFORMANCE] ", log.LstdFlags),
        }
}</span>

// StartOperation начинает мониторинг операции.
func (pm *PerformanceMonitor) StartOperation(requestID string, userID, chatID int64, operation, component string) *RequestTrace <span class="cov0" title="0">{
        return pm.tracing.StartTrace(requestID, userID, chatID, operation, component)
}</span>

// EndOperation завершает мониторинг операции.
func (pm *PerformanceMonitor) EndOperation(requestID string, status string, err error) <span class="cov0" title="0">{
        pm.tracing.EndTrace(requestID, status, err)
}</span>

// RecordDatabaseOperation записывает операцию с базой данных.
func (pm *PerformanceMonitor) RecordDatabaseOperation(requestID, operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        pm.tracing.RecordDatabaseOperation(requestID, operation, duration, err)

        labels := map[string]string{
                "operation": operation,
                "status":    "success",
        }
        if err != nil </span><span class="cov0" title="0">{
                labels["status"] = "error"
        }</span>

        <span class="cov0" title="0">pm.collector.RecordTimer("database_operation_duration", duration, labels)
        pm.collector.IncrementCounter("database_operations_total", labels)</span>
}

// RecordCacheOperation записывает операцию с кэшем.
func (pm *PerformanceMonitor) RecordCacheOperation(requestID, operation string, hit bool, duration time.Duration, err error) <span class="cov0" title="0">{
        pm.tracing.RecordCacheOperation(requestID, operation, hit, duration, err)

        labels := map[string]string{
                "operation": operation,
                "hit":       fmt.Sprintf("%t", hit),
                "status":    "success",
        }
        if err != nil </span><span class="cov0" title="0">{
                labels["status"] = "error"
        }</span>

        <span class="cov0" title="0">pm.collector.RecordTimer("cache_operation_duration", duration, labels)
        pm.collector.IncrementCounter("cache_operations_total", labels)</span>
}

// RecordTelegramOperation записывает операцию с Telegram API.
func (pm *PerformanceMonitor) RecordTelegramOperation(requestID, operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        pm.tracing.RecordTelegramOperation(requestID, operation, duration, err)

        labels := map[string]string{
                "operation": operation,
                "status":    "success",
        }
        if err != nil </span><span class="cov0" title="0">{
                labels["status"] = "error"
        }</span>

        <span class="cov0" title="0">pm.collector.RecordTimer("telegram_operation_duration", duration, labels)
        pm.collector.IncrementCounter("telegram_operations_total", labels)</span>
}

// GetPerformanceReport возвращает отчет о производительности.
func (pm *PerformanceMonitor) GetPerformanceReport() map[string]interface{} <span class="cov0" title="0">{
        summary := pm.tracing.GetPerformanceSummary()
        metrics := pm.collector.GetAllMetrics()

        return map[string]interface{}{
                "summary":   summary,
                "metrics":   metrics,
                "timestamp": time.Now().Format(time.RFC3339),
        }
}</span>

// LogPerformanceReport логирует отчет о производительности.
func (pm *PerformanceMonitor) LogPerformanceReport() <span class="cov0" title="0">{
        report := pm.GetPerformanceReport()

        jsonData, err := json.Marshal(report)
        if err != nil </span><span class="cov0" title="0">{
                pm.logger.Printf("Failed to marshal performance report: %v", err)
                return
        }</span>

        <span class="cov0" title="0">pm.logger.Printf("PERFORMANCE_REPORT: %s", string(jsonData))</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package logging provides request tracing and performance monitoring.
package logging

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"
)

// traceContextKey тип ключа для контекста трейса.
type traceContextKey string

// RequestTrace представляет трейс запроса.
type RequestTrace struct {
        RequestID string                 `json:"request_id"`
        UserID    int64                  `json:"user_id"`
        ChatID    int64                  `json:"chat_id"`
        Operation string                 `json:"operation"`
        Component string                 `json:"component"`
        StartTime time.Time              `json:"start_time"`
        EndTime   time.Time              `json:"end_time"`
        Duration  time.Duration          `json:"duration_ms"`
        Status    string                 `json:"status"`
        Error     string                 `json:"error,omitempty"`
        Metadata  map[string]interface{} `json:"metadata"`
        SubTraces []*RequestTrace        `json:"sub_traces,omitempty"`
}

// PerformanceMetrics представляет метрики производительности.
type PerformanceMetrics struct {
        Operation    string        `json:"operation"`
        Component    string        `json:"component"`
        Duration     time.Duration `json:"duration_ms"`
        MemoryUsage  int64         `json:"memory_bytes"`
        DatabaseHits int           `json:"database_hits"`
        CacheHits    int           `json:"cache_hits"`
        CacheMisses  int           `json:"cache_misses"`
        ErrorCount   int           `json:"error_count"`
        SuccessCount int           `json:"success_count"`
        Timestamp    time.Time     `json:"timestamp"`
}

// TracingService предоставляет функциональность трейсинга.
type TracingService struct {
        activeTraces map[string]*RequestTrace
        metrics      []PerformanceMetrics
        logger       *log.Logger
}

// NewTracingService создает новый сервис трейсинга.
func NewTracingService() *TracingService <span class="cov0" title="0">{
        return &amp;TracingService{
                activeTraces: make(map[string]*RequestTrace),
                metrics:      make([]PerformanceMetrics, 0),
                logger:       log.New(os.Stdout, "[TRACING] ", log.LstdFlags),
        }
}</span>

// StartTrace начинает новый трейс запроса.
func (ts *TracingService) StartTrace(requestID string, userID, chatID int64, operation, component string) *RequestTrace <span class="cov0" title="0">{
        trace := &amp;RequestTrace{
                RequestID: requestID,
                UserID:    userID,
                ChatID:    chatID,
                Operation: operation,
                Component: component,
                StartTime: time.Now(),
                Status:    "started",
                Metadata:  make(map[string]interface{}),
                SubTraces: make([]*RequestTrace, 0),
        }

        ts.activeTraces[requestID] = trace
        ts.logTrace(trace, "TRACE_START")

        return trace
}</span>

// EndTrace завершает трейс запроса.
func (ts *TracingService) EndTrace(requestID string, status string, err error) <span class="cov0" title="0">{
        trace, exists := ts.activeTraces[requestID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">trace.EndTime = time.Now()
        trace.Duration = trace.EndTime.Sub(trace.StartTime)
        trace.Status = status

        if err != nil </span><span class="cov0" title="0">{
                trace.Error = err.Error()
        }</span>

        <span class="cov0" title="0">ts.logTrace(trace, "TRACE_END")

        // Записываем метрики
        ts.recordMetrics(trace)

        // Удаляем из активных трейсов
        delete(ts.activeTraces, requestID)</span>
}

// AddSubTrace добавляет под-трейс к основному трейсу.
func (ts *TracingService) AddSubTrace(parentRequestID, subOperation, subComponent string) *RequestTrace <span class="cov0" title="0">{
        parentTrace, exists := ts.activeTraces[parentRequestID]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">subTrace := &amp;RequestTrace{
                RequestID: fmt.Sprintf("%s_%s", parentRequestID, subOperation),
                UserID:    parentTrace.UserID,
                ChatID:    parentTrace.ChatID,
                Operation: subOperation,
                Component: subComponent,
                StartTime: time.Now(),
                Status:    "started",
                Metadata:  make(map[string]interface{}),
                SubTraces: make([]*RequestTrace, 0),
        }

        parentTrace.SubTraces = append(parentTrace.SubTraces, subTrace)
        return subTrace</span>
}

// AddMetadata добавляет метаданные к трейсу.
func (ts *TracingService) AddMetadata(requestID string, key string, value interface{}) <span class="cov0" title="0">{
        trace, exists := ts.activeTraces[requestID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">trace.Metadata[key] = value</span>
}

// RecordDatabaseOperation записывает операцию с базой данных.
func (ts *TracingService) RecordDatabaseOperation(requestID, operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        ts.AddMetadata(requestID, "db_operation", operation)
        ts.AddMetadata(requestID, "db_duration_ms", duration.Milliseconds())

        if err != nil </span><span class="cov0" title="0">{
                ts.AddMetadata(requestID, "db_error", err.Error())
        }</span>
}

// RecordCacheOperation записывает операцию с кэшем.
func (ts *TracingService) RecordCacheOperation(requestID, operation string, hit bool, duration time.Duration, err error) <span class="cov0" title="0">{
        ts.AddMetadata(requestID, "cache_operation", operation)
        ts.AddMetadata(requestID, "cache_hit", hit)
        ts.AddMetadata(requestID, "cache_duration_ms", duration.Milliseconds())

        if err != nil </span><span class="cov0" title="0">{
                ts.AddMetadata(requestID, "cache_error", err.Error())
        }</span>
}

// RecordTelegramOperation записывает операцию с Telegram API.
func (ts *TracingService) RecordTelegramOperation(requestID, operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        ts.AddMetadata(requestID, "telegram_operation", operation)
        ts.AddMetadata(requestID, "telegram_duration_ms", duration.Milliseconds())

        if err != nil </span><span class="cov0" title="0">{
                ts.AddMetadata(requestID, "telegram_error", err.Error())
        }</span>
}

// logTrace логирует трейс в структурированном формате.
func (ts *TracingService) logTrace(trace *RequestTrace, event string) <span class="cov0" title="0">{
        traceData := map[string]interface{}{
                "event":     event,
                "trace":     trace,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        jsonData, err := json.Marshal(traceData)
        if err != nil </span><span class="cov0" title="0">{
                ts.logger.Printf("Failed to marshal trace data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">ts.logger.Printf("%s", string(jsonData))</span>
}

// recordMetrics записывает метрики производительности.
func (ts *TracingService) recordMetrics(trace *RequestTrace) <span class="cov0" title="0">{
        metrics := PerformanceMetrics{
                Operation:    trace.Operation,
                Component:    trace.Component,
                Duration:     trace.Duration,
                Timestamp:    time.Now(),
                SuccessCount: 1,
        }

        if trace.Error != "" </span><span class="cov0" title="0">{
                metrics.ErrorCount = 1
                metrics.SuccessCount = 0
        }</span>

        // Извлекаем метрики из метаданных
        <span class="cov0" title="0">if dbHits, ok := trace.Metadata["db_hits"].(int); ok </span><span class="cov0" title="0">{
                metrics.DatabaseHits = dbHits
        }</span>
        <span class="cov0" title="0">if cacheHits, ok := trace.Metadata["cache_hits"].(int); ok </span><span class="cov0" title="0">{
                metrics.CacheHits = cacheHits
        }</span>
        <span class="cov0" title="0">if cacheMisses, ok := trace.Metadata["cache_misses"].(int); ok </span><span class="cov0" title="0">{
                metrics.CacheMisses = cacheMisses
        }</span>

        <span class="cov0" title="0">ts.metrics = append(ts.metrics, metrics)

        // Ограничиваем размер массива метрик
        if len(ts.metrics) &gt; 1000 </span><span class="cov0" title="0">{
                ts.metrics = ts.metrics[len(ts.metrics)-1000:]
        }</span>
}

// GetMetrics возвращает метрики производительности.
func (ts *TracingService) GetMetrics() []PerformanceMetrics <span class="cov0" title="0">{
        return ts.metrics
}</span>

// GetActiveTraces возвращает активные трейсы.
func (ts *TracingService) GetActiveTraces() map[string]*RequestTrace <span class="cov0" title="0">{
        return ts.activeTraces
}</span>

// GetTraceByRequestID возвращает трейс по ID запроса.
func (ts *TracingService) GetTraceByRequestID(requestID string) (*RequestTrace, bool) <span class="cov0" title="0">{
        trace, exists := ts.activeTraces[requestID]
        return trace, exists
}</span>

// ClearMetrics очищает метрики.
func (ts *TracingService) ClearMetrics() <span class="cov0" title="0">{
        ts.metrics = make([]PerformanceMetrics, 0)
}</span>

// GetPerformanceSummary возвращает сводку по производительности.
func (ts *TracingService) GetPerformanceSummary() map[string]interface{} <span class="cov0" title="0">{
        if len(ts.metrics) == 0 </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "total_operations": 0,
                        "average_duration": 0,
                        "error_rate":       0,
                }
        }</span>

        <span class="cov0" title="0">var totalDuration time.Duration
        var errorCount, successCount int
        var totalDbHits, totalCacheHits, totalCacheMisses int

        for _, metric := range ts.metrics </span><span class="cov0" title="0">{
                totalDuration += metric.Duration
                errorCount += metric.ErrorCount
                successCount += metric.SuccessCount
                totalDbHits += metric.DatabaseHits
                totalCacheHits += metric.CacheHits
                totalCacheMisses += metric.CacheMisses
        }</span>

        <span class="cov0" title="0">totalOperations := len(ts.metrics)
        avgDuration := totalDuration / time.Duration(totalOperations)
        errorRate := float64(errorCount) / float64(totalOperations) * 100

        return map[string]interface{}{
                "total_operations":       totalOperations,
                "average_duration_ms":    avgDuration.Milliseconds(),
                "error_rate_percent":     errorRate,
                "total_db_hits":          totalDbHits,
                "total_cache_hits":       totalCacheHits,
                "total_cache_misses":     totalCacheMisses,
                "cache_hit_rate_percent": float64(totalCacheHits) / float64(totalCacheHits+totalCacheMisses) * 100,
        }</span>
}

// ContextWithTrace добавляет трейс в контекст.
func ContextWithTrace(ctx context.Context, trace *RequestTrace) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, traceContextKey("trace"), trace)
}</span>

// TraceFromContext извлекает трейс из контекста.
func TraceFromContext(ctx context.Context) (*RequestTrace, bool) <span class="cov0" title="0">{
        trace, ok := ctx.Value(traceContextKey("trace")).(*RequestTrace)
        return trace, ok
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package monitoring provides performance monitoring and dashboard functionality.
package monitoring

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "time"

        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"
)

// Dashboard представляет веб-дашборд для мониторинга.
type Dashboard struct {
        performanceMonitor *logging.PerformanceMonitor
        errorHandler       *errors.CentralizedErrorHandler
        server             *http.Server
        logger             *log.Logger
}

// NewDashboard создает новый дашборд мониторинга.
func NewDashboard(performanceMonitor *logging.PerformanceMonitor, errorHandler *errors.CentralizedErrorHandler) *Dashboard <span class="cov0" title="0">{
        return &amp;Dashboard{
                performanceMonitor: performanceMonitor,
                errorHandler:       errorHandler,
                logger:             log.New(os.Stdout, "[DASHBOARD] ", log.LstdFlags),
        }
}</span>

// Start запускает веб-сервер дашборда.
func (d *Dashboard) Start(port int) error <span class="cov0" title="0">{
        mux := http.NewServeMux()

        // API endpoints
        mux.HandleFunc("/api/metrics", d.handleMetrics)
        mux.HandleFunc("/api/errors", d.handleErrors)
        mux.HandleFunc("/api/alerts", d.handleAlerts)
        mux.HandleFunc("/api/performance", d.handlePerformance)
        mux.HandleFunc("/api/health", d.handleHealth)

        // Web interface
        mux.HandleFunc("/", d.handleIndex)
        mux.HandleFunc("/metrics", d.handleMetricsPage)
        mux.HandleFunc("/errors", d.handleErrorsPage)
        mux.HandleFunc("/alerts", d.handleAlertsPage)

        d.server = &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", port),
                Handler: mux,
        }

        d.logger.Printf("Starting monitoring dashboard on port %d", port)
        return d.server.ListenAndServe()
}</span>

// Stop останавливает веб-сервер дашборда.
func (d *Dashboard) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if d.server != nil </span><span class="cov0" title="0">{
                return d.server.Shutdown(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// handleIndex обрабатывает главную страницу дашборда.
func (d *Dashboard) handleIndex(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Language Exchange Bot - Monitoring Dashboard&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .nav { display: flex; gap: 20px; margin-bottom: 30px; }
        .nav a { padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        .nav a:hover { background: #0056b3; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: #f8f9fa; padding: 20px; border-radius: 4px; text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .stat-label { color: #666; margin-top: 5px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;🤖 Language Exchange Bot&lt;/h1&gt;
            &lt;h2&gt;Monitoring Dashboard&lt;/h2&gt;
        &lt;/div&gt;
        
        &lt;div class="nav"&gt;
            &lt;a href="/"&gt;🏠 Dashboard&lt;/a&gt;
            &lt;a href="/metrics"&gt;📊 Metrics&lt;/a&gt;
            &lt;a href="/errors"&gt;🚨 Errors&lt;/a&gt;
            &lt;a href="/alerts"&gt;⚠️ Alerts&lt;/a&gt;
        &lt;/div&gt;
        
        &lt;div class="stats"&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="active-traces"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Active Traces&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="total-errors"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Total Errors&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="active-alerts"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Active Alerts&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-value" id="avg-response-time"&gt;-&lt;/div&gt;
                &lt;div class="stat-label"&gt;Avg Response Time (ms)&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div id="status" style="text-align: center; padding: 20px; background: #d4edda; border-radius: 4px; color: #155724;"&gt;
            ✅ System Status: Healthy
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        // Auto-refresh every 5 seconds
        setInterval(function() {
            fetch('/api/performance')
                .then(response =&gt; response.json())
                .then(data =&gt; {
                    document.getElementById('active-traces').textContent = data.active_traces || 0;
                    document.getElementById('total-errors').textContent = data.total_errors || 0;
                    document.getElementById('active-alerts').textContent = data.active_alerts || 0;
                    document.getElementById('avg-response-time').textContent = data.avg_response_time || 0;
                })
                .catch(error =&gt; console.error('Error fetching data:', error));
        }, 5000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        w.Header().Set("Content-Type", "text/html")
        if _, err := fmt.Fprint(w, tmpl); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write dashboard template: %v", err)
                return
        }</span>
}

// handleMetrics обрабатывает API метрик.
func (d *Dashboard) handleMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        metrics := d.performanceMonitor.GetPerformanceReport()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(metrics); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode metrics", http.StatusInternalServerError)
                return
        }</span>
}

// handleErrors обрабатывает API ошибок.
func (d *Dashboard) handleErrors(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        alerts := d.errorHandler.GetAlerts()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(alerts); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode alerts", http.StatusInternalServerError)
                return
        }</span>
}

// handleAlerts обрабатывает API алертов.
func (d *Dashboard) handleAlerts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        activeAlerts := d.errorHandler.GetActiveAlerts()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(activeAlerts); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode active alerts", http.StatusInternalServerError)
                return
        }</span>
}

// handlePerformance обрабатывает API производительности.
func (d *Dashboard) handlePerformance(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        report := d.performanceMonitor.GetPerformanceReport()

        // Извлекаем основные метрики
        summary, ok := report["summary"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                summary = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "active_traces":     0, // TODO: Implement GetActiveTraces method
                "total_errors":      summary["total_operations"],
                "active_alerts":     len(d.errorHandler.GetActiveAlerts()),
                "avg_response_time": summary["average_duration_ms"],
                "error_rate":        summary["error_rate_percent"],
                "cache_hit_rate":    summary["cache_hit_rate_percent"],
                "timestamp":         time.Now().Format(time.RFC3339),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// handleHealth обрабатывает health check.
func (d *Dashboard) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().Format(time.RFC3339),
                "uptime":    time.Since(time.Now()).String(), // Placeholder
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// handleMetricsPage обрабатывает страницу метрик.
func (d *Dashboard) handleMetricsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Metrics - Language Exchange Bot&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .nav { display: flex; gap: 20px; margin-bottom: 30px; }
        .nav a { padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        .nav a:hover { background: #0056b3; }
        .metrics-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .metrics-table th, .metrics-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        .metrics-table th { background-color: #f8f9fa; }
        .refresh-btn { background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }
        .refresh-btn:hover { background: #218838; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;📊 Performance Metrics&lt;/h1&gt;
        &lt;/div&gt;
        
        &lt;div class="nav"&gt;
            &lt;a href="/"&gt;🏠 Dashboard&lt;/a&gt;
            &lt;a href="/metrics"&gt;📊 Metrics&lt;/a&gt;
            &lt;a href="/errors"&gt;🚨 Errors&lt;/a&gt;
            &lt;a href="/alerts"&gt;⚠️ Alerts&lt;/a&gt;
        &lt;/div&gt;
        
        &lt;button class="refresh-btn" onclick="loadMetrics()"&gt;🔄 Refresh&lt;/button&gt;
        
        &lt;table class="metrics-table" id="metrics-table"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;Metric&lt;/th&gt;
                    &lt;th&gt;Value&lt;/th&gt;
                    &lt;th&gt;Type&lt;/th&gt;
                    &lt;th&gt;Timestamp&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody id="metrics-body"&gt;
                &lt;tr&gt;&lt;td colspan="4"&gt;Loading...&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        function loadMetrics() {
            fetch('/api/metrics')
                .then(response =&gt; response.json())
                .then(data =&gt; {
                    const tbody = document.getElementById('metrics-body');
                    tbody.innerHTML = '';
                    
                    if (data.metrics) {
                        Object.entries(data.metrics).forEach(([key, metric]) =&gt; {
                            const row = document.createElement('tr');
                            row.innerHTML = 
                                '&lt;td&gt;' + key + '&lt;/td&gt;' +
                                '&lt;td&gt;' + (metric.value || 'N/A') + '&lt;/td&gt;' +
                                '&lt;td&gt;' + (metric.type || 'N/A') + '&lt;/td&gt;' +
                                '&lt;td&gt;' + new Date(metric.timestamp).toLocaleString() + '&lt;/td&gt;';
                            tbody.appendChild(row);
                        });
                    }
                })
                .catch(error =&gt; {
                    console.error('Error loading metrics:', error);
                    document.getElementById('metrics-body').innerHTML = '&lt;tr&gt;&lt;td colspan="4"&gt;Error loading metrics&lt;/td&gt;&lt;/tr&gt;';
                });
        }
        
        // Load metrics on page load
        loadMetrics();
        
        // Auto-refresh every 10 seconds
        setInterval(loadMetrics, 10000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        w.Header().Set("Content-Type", "text/html")
        if _, err := fmt.Fprint(w, tmpl); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write dashboard template: %v", err)
                return
        }</span>
}

// handleErrorsPage обрабатывает страницу ошибок.
func (d *Dashboard) handleErrorsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Errors - Language Exchange Bot&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .nav { display: flex; gap: 20px; margin-bottom: 30px; }
        .nav a { padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        .nav a:hover { background: #0056b3; }
        .error-card { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; margin-bottom: 15px; }
        .error-level { font-weight: bold; padding: 4px 8px; border-radius: 4px; color: white; }
        .error-level.critical { background: #dc3545; }
        .error-level.warning { background: #ffc107; color: #000; }
        .error-level.info { background: #17a2b8; }
        .refresh-btn { background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }
        .refresh-btn:hover { background: #218838; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;🚨 Error Logs&lt;/h1&gt;
        &lt;/div&gt;
        
        &lt;div class="nav"&gt;
            &lt;a href="/"&gt;🏠 Dashboard&lt;/a&gt;
            &lt;a href="/metrics"&gt;📊 Metrics&lt;/a&gt;
            &lt;a href="/errors"&gt;🚨 Errors&lt;/a&gt;
            &lt;a href="/alerts"&gt;⚠️ Alerts&lt;/a&gt;
        &lt;/div&gt;
        
        &lt;button class="refresh-btn" onclick="loadErrors()"&gt;🔄 Refresh&lt;/button&gt;
        
        &lt;div id="errors-container"&gt;
            &lt;div class="error-card"&gt;
                &lt;p&gt;Loading errors...&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        function loadErrors() {
            fetch('/api/errors')
                .then(response =&gt; response.json())
                .then(data =&gt; {
                    const container = document.getElementById('errors-container');
                    container.innerHTML = '';
                    
                    if (Object.keys(data).length === 0) {
                        container.innerHTML = '&lt;div class="error-card"&gt;&lt;p&gt;No errors found&lt;/p&gt;&lt;/div&gt;';
                        return;
                    }
                    
                    Object.entries(data).forEach(([id, error]) =&gt; {
                        const errorCard = document.createElement('div');
                        errorCard.className = 'error-card';
                        
                        const levelClass = error.level ? error.level.toLowerCase() : 'info';
                        const levelText = error.level || 'INFO';
                        
                        errorCard.innerHTML = 
                            '&lt;div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"&gt;' +
                                '&lt;h3&gt;' + (error.title || 'Error') + '&lt;/h3&gt;' +
                                '&lt;span class="error-level ' + levelClass + '"&gt;' + levelText + '&lt;/span&gt;' +
                            '&lt;/div&gt;' +
                            '&lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt; ' + (error.message || 'N/A') + '&lt;/p&gt;' +
                            '&lt;p&gt;&lt;strong&gt;Timestamp:&lt;/strong&gt; ' + new Date(error.timestamp).toLocaleString() + '&lt;/p&gt;' +
                            '&lt;p&gt;&lt;strong&gt;Resolved:&lt;/strong&gt; ' + (error.resolved ? 'Yes' : 'No') + '&lt;/p&gt;';
                        
                        container.appendChild(errorCard);
                    });
                })
                .catch(error =&gt; {
                    console.error('Error loading errors:', error);
                    document.getElementById('errors-container').innerHTML = '&lt;div class="error-card"&gt;&lt;p&gt;Error loading errors&lt;/p&gt;&lt;/div&gt;';
                });
        }
        
        // Load errors on page load
        loadErrors();
        
        // Auto-refresh every 15 seconds
        setInterval(loadErrors, 15000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        w.Header().Set("Content-Type", "text/html")
        if _, err := fmt.Fprint(w, tmpl); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write dashboard template: %v", err)
                return
        }</span>
}

// handleAlertsPage обрабатывает страницу алертов.
func (d *Dashboard) handleAlertsPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Alerts - Language Exchange Bot&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .nav { display: flex; gap: 20px; margin-bottom: 30px; }
        .nav a { padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; }
        .nav a:hover { background: #0056b3; }
        .alert-card { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; margin-bottom: 15px; }
        .alert-level { font-weight: bold; padding: 4px 8px; border-radius: 4px; color: white; }
        .alert-level.emergency { background: #dc3545; }
        .alert-level.critical { background: #fd7e14; }
        .alert-level.warning { background: #ffc107; color: #000; }
        .alert-level.info { background: #17a2b8; }
        .refresh-btn { background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }
        .refresh-btn:hover { background: #218838; }
        .resolve-btn { background: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; }
        .resolve-btn:hover { background: #5a6268; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;⚠️ Active Alerts&lt;/h1&gt;
        &lt;/div&gt;
        
        &lt;div class="nav"&gt;
            &lt;a href="/"&gt;🏠 Dashboard&lt;/a&gt;
            &lt;a href="/metrics"&gt;📊 Metrics&lt;/a&gt;
            &lt;a href="/errors"&gt;🚨 Errors&lt;/a&gt;
            &lt;a href="/alerts"&gt;⚠️ Alerts&lt;/a&gt;
        &lt;/div&gt;
        
        &lt;button class="refresh-btn" onclick="loadAlerts()"&gt;🔄 Refresh&lt;/button&gt;
        
        &lt;div id="alerts-container"&gt;
            &lt;div class="alert-card"&gt;
                &lt;p&gt;Loading alerts...&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        function loadAlerts() {
            fetch('/api/alerts')
                .then(response =&gt; response.json())
                .then(data =&gt; {
                    const container = document.getElementById('alerts-container');
                    container.innerHTML = '';
                    
                    if (Object.keys(data).length === 0) {
                        container.innerHTML = '&lt;div class="alert-card"&gt;&lt;p&gt;No active alerts&lt;/p&gt;&lt;/div&gt;';
                        return;
                    }
                    
                    Object.entries(data).forEach(([id, alert]) =&gt; {
                        const alertCard = document.createElement('div');
                        alertCard.className = 'alert-card';
                        
                        const levelClass = alert.level ? alert.level.toLowerCase() : 'info';
                        const levelText = alert.level || 'INFO';
                        
                        alertCard.innerHTML = 
                            '&lt;div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"&gt;' +
                                '&lt;h3&gt;' + (alert.title || 'Alert') + '&lt;/h3&gt;' +
                                '&lt;div&gt;' +
                                    '&lt;span class="alert-level ' + levelClass + '"&gt;' + levelText + '&lt;/span&gt;' +
                                    (!alert.resolved ? '&lt;button class="resolve-btn" onclick="resolveAlert(\'' + id + '\')"&gt;Resolve&lt;/button&gt;' : '') +
                                '&lt;/div&gt;' +
                            '&lt;/div&gt;' +
                            '&lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt; ' + (alert.message || 'N/A') + '&lt;/p&gt;' +
                            '&lt;p&gt;&lt;strong&gt;Timestamp:&lt;/strong&gt; ' + new Date(alert.timestamp).toLocaleString() + '&lt;/p&gt;' +
                            '&lt;p&gt;&lt;strong&gt;Resolved:&lt;/strong&gt; ' + (alert.resolved ? 'Yes' : 'No') + '&lt;/p&gt;';
                        
                        container.appendChild(alertCard);
                    });
                })
                .catch(error =&gt; {
                    console.error('Error loading alerts:', error);
                    document.getElementById('alerts-container').innerHTML = '&lt;div class="alert-card"&gt;&lt;p&gt;Error loading alerts&lt;/p&gt;&lt;/div&gt;';
                });
        }
        
        function resolveAlert(alertId) {
            // This would typically make a POST request to resolve the alert
            console.log('Resolving alert:', alertId);
            alert('Alert resolution not implemented in this demo');
        }
        
        // Load alerts on page load
        loadAlerts();
        
        // Auto-refresh every 20 seconds
        setInterval(loadAlerts, 20000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        w.Header().Set("Content-Type", "text/html")
        if _, err := fmt.Fprint(w, tmpl); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write dashboard template: %v", err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package monitoring provides integration of all monitoring components.
package monitoring

import (
        "context"
        "log"
        "os"
        "time"

        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/logging"
)

// MonitoringService интегрирует все компоненты мониторинга.
type MonitoringService struct {
        performanceMonitor *logging.PerformanceMonitor
        errorHandler       *errors.CentralizedErrorHandler
        dashboard          *Dashboard
        logger             *log.Logger
}

// NewMonitoringService создает новый сервис мониторинга.
func NewMonitoringService() *MonitoringService <span class="cov0" title="0">{
        performanceMonitor := logging.NewPerformanceMonitor()
        errorHandler := errors.NewCentralizedErrorHandler()
        dashboard := NewDashboard(performanceMonitor, errorHandler)

        return &amp;MonitoringService{
                performanceMonitor: performanceMonitor,
                errorHandler:       errorHandler,
                dashboard:          dashboard,
                logger:             log.New(os.Stdout, "[MONITORING] ", log.LstdFlags),
        }
}</span>

// Start запускает все компоненты мониторинга.
func (ms *MonitoringService) Start(ctx context.Context, dashboardPort int) error <span class="cov0" title="0">{
        ms.logger.Printf("Starting monitoring service...")

        // Запускаем дашборд в отдельной горутине
        go func() </span><span class="cov0" title="0">{
                if err := ms.dashboard.Start(dashboardPort); err != nil </span><span class="cov0" title="0">{
                        ms.logger.Printf("Dashboard error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">ms.logger.Printf("Monitoring service started successfully")
        ms.logger.Printf("Dashboard available at: http://localhost:%d", dashboardPort)

        return nil</span>
}

// Stop останавливает все компоненты мониторинга.
func (ms *MonitoringService) Stop(ctx context.Context) error <span class="cov0" title="0">{
        ms.logger.Printf("Stopping monitoring service...")

        // Останавливаем дашборд
        if err := ms.dashboard.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                ms.logger.Printf("Error stopping dashboard: %v", err)
        }</span>

        <span class="cov0" title="0">ms.logger.Printf("Monitoring service stopped")
        return nil</span>
}

// GetPerformanceMonitor возвращает монитор производительности.
func (ms *MonitoringService) GetPerformanceMonitor() *logging.PerformanceMonitor <span class="cov0" title="0">{
        return ms.performanceMonitor
}</span>

// GetErrorHandler возвращает обработчик ошибок.
func (ms *MonitoringService) GetErrorHandler() *errors.CentralizedErrorHandler <span class="cov0" title="0">{
        return ms.errorHandler
}</span>

// GetDashboard возвращает дашборд.
func (ms *MonitoringService) GetDashboard() *Dashboard <span class="cov0" title="0">{
        return ms.dashboard
}</span>

// RecordOperation записывает операцию в мониторинг.
func (ms *MonitoringService) RecordOperation(requestID string, userID, chatID int64, operation, component string) *logging.RequestTrace <span class="cov0" title="0">{
        return ms.performanceMonitor.StartOperation(requestID, userID, chatID, operation, component)
}</span>

// EndOperation завершает запись операции.
func (ms *MonitoringService) EndOperation(requestID string, status string, err error) <span class="cov0" title="0">{
        ms.performanceMonitor.EndOperation(requestID, status, err)
}</span>

// RecordDatabaseOperation записывает операцию с базой данных.
func (ms *MonitoringService) RecordDatabaseOperation(requestID, operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        ms.performanceMonitor.RecordDatabaseOperation(requestID, operation, duration, err)
}</span>

// RecordCacheOperation записывает операцию с кэшем.
func (ms *MonitoringService) RecordCacheOperation(requestID, operation string, hit bool, duration time.Duration, err error) <span class="cov0" title="0">{
        ms.performanceMonitor.RecordCacheOperation(requestID, operation, hit, duration, err)
}</span>

// RecordTelegramOperation записывает операцию с Telegram API.
func (ms *MonitoringService) RecordTelegramOperation(requestID, operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        ms.performanceMonitor.RecordTelegramOperation(requestID, operation, duration, err)
}</span>

// HandleError обрабатывает ошибку.
func (ms *MonitoringService) HandleError(ctx context.Context, err error, requestID string, userID, chatID int64, operation string) error <span class="cov0" title="0">{
        return ms.errorHandler.HandleError(ctx, err, requestID, userID, chatID, operation)
}</span>

// HandleCustomError обрабатывает кастомную ошибку.
func (ms *MonitoringService) HandleCustomError(ctx context.Context, customErr *errors.CustomError, requestID string, userID, chatID int64, operation string) error <span class="cov0" title="0">{
        return ms.errorHandler.HandleCustomError(ctx, customErr, requestID, userID, chatID, operation)
}</span>

// GetPerformanceReport возвращает отчет о производительности.
func (ms *MonitoringService) GetPerformanceReport() map[string]interface{} <span class="cov0" title="0">{
        return ms.performanceMonitor.GetPerformanceReport()
}</span>

// GetActiveAlerts возвращает активные алерты.
func (ms *MonitoringService) GetActiveAlerts() map[string]*errors.Alert <span class="cov0" title="0">{
        return ms.errorHandler.GetActiveAlerts()
}</span>

// LogPerformanceReport логирует отчет о производительности.
func (ms *MonitoringService) LogPerformanceReport() <span class="cov0" title="0">{
        ms.performanceMonitor.LogPerformanceReport()
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Language Exchange Bot Team",
            "url": "https://github.com/your-org/language-exchange-bot",
            "email": "support@language-exchange-bot.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/cache/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve cache performance statistics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "monitoring"
                ],
                "summary": "Get cache statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/feedback/unprocessed": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve all unprocessed user feedback",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "feedback"
                ],
                "summary": "Get unprocessed feedback",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "additionalProperties": true
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/feedback/{id}/process": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Mark feedback as processed with optional response",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "feedback"
                ],
                "summary": "Process feedback",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feedback ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Processing request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/rate-limits/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve rate limiting statistics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "monitoring"
                ],
                "summary": "Get rate limit statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/stats": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve general bot statistics",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "statistics"
                ],
                "summary": "Get general statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/users": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve paginated list of users",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get users list",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 50,
                        "description": "Number of users to return",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/users/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieve user information by Telegram ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Telegram User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/healthz": {
            "get": {
                "description": "Check if the service is healthy",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/readyz": {
            "get": {
                "description": "Check if the service is ready to serve requests",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Readiness check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.FriendshipPreferences": {
            "type": "object",
            "properties": {
                "activityType": {
                    "description": "movies, games, educational",
                    "type": "string"
                },
                "communicationFrequency": {
                    "description": "spontaneous, weekly, daily",
                    "type": "string"
                },
                "communicationStyle": {
                    "description": "text, voice_msg, meet_person",
                    "type": "string"
                }
            }
        },
        "models.TimeAvailability": {
            "type": "object",
            "properties": {
                "dayType": {
                    "description": "weekdays, weekends, any, specific",
                    "type": "string"
                },
                "specificDays": {
                    "description": "массив дней для specific",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "timeSlot": {
                    "description": "morning, day, evening, late",
                    "type": "string"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "friendshipPreferences": {
                    "description": "Предпочтения общения",
                    "allOf": [
                        {
                            "$ref": "#/definitions/models.FriendshipPreferences"
                        }
                    ]
                },
                "id": {
                    "type": "integer"
                },
                "interests": {
                    "description": "Не храним в БД, загружаем отдельно",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "interfaceLanguageCode": {
                    "type": "string"
                },
                "nativeLanguageCode": {
                    "type": "string"
                },
                "profileCompletionLevel": {
                    "type": "integer"
                },
                "state": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "targetLanguageCode": {
                    "type": "string"
                },
                "targetLanguageLevel": {
                    "type": "string"
                },
                "telegramId": {
                    "type": "integer"
                },
                "timeAvailability": {
                    "description": "Дополнительные поля для расширенного профиля",
                    "allOf": [
                        {
                            "$ref": "#/definitions/models.TimeAvailability"
                        }
                    ]
                },
                "updatedAt": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "description": "Admin API key for authentication",
            "type": "apiKey",
            "name": "X-Admin-Key",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "3.0.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Language Exchange Bot Admin API",
        Description:      "This is the administrative API for the Language Exchange Telegram Bot.\nIt provides endpoints for monitoring, user management, feedback processing, and system statistics.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package server provides HTTP server implementation for administrative API
package server

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "time"

        "language-exchange-bot/internal/adapters/telegram"
        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/models"
        docs "language-exchange-bot/internal/server/docs"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
        "github.com/gorilla/mux"
        httpSwagger "github.com/swaggo/http-swagger"
)

// AdminServer provides REST API for administrative operations and webhook handling
type AdminServer struct {
        port        string
        botService  *core.BotService
        handler     *telegram.TelegramHandler
        webhookMode bool
        server      *http.Server
}

// New creates a new admin HTTP server
func New(port string, botService *core.BotService, handler *telegram.TelegramHandler) *AdminServer <span class="cov8" title="1">{
        return NewWithWebhook(port, botService, handler, false)
}</span>

// SetTelegramHandler устанавливает Telegram handler для сервера
func (s *AdminServer) SetTelegramHandler(handler *telegram.TelegramHandler) <span class="cov0" title="0">{
        s.handler = handler
}</span>

// NewWithWebhook creates a new admin HTTP server with webhook support
func NewWithWebhook(port string, botService *core.BotService, handler *telegram.TelegramHandler, webhookMode bool) *AdminServer <span class="cov8" title="1">{
        r := mux.NewRouter()

        s := &amp;AdminServer{
                port:        port,
                botService:  botService,
                handler:     handler,
                webhookMode: webhookMode,
        }

        // Health check
        r.HandleFunc("/healthz", s.handleHealth).Methods("GET")
        r.HandleFunc("/readyz", s.handleReady).Methods("GET")

        // Swagger UI
        r.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

        // Static files and navigation page
        r.HandleFunc("/", s.handleNavigation).Methods("GET")
        r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", http.FileServer(http.Dir("./static/"))))

        // Telegram webhook endpoint (only if webhook mode is enabled)
        if webhookMode &amp;&amp; handler != nil </span><span class="cov0" title="0">{
                r.HandleFunc("/webhook/telegram/{token}", s.handleTelegramWebhook).Methods("POST")
        }</span>

        // API Version 1 - Current stable version
        <span class="cov8" title="1">s.setupAPIV1(r)

        // API Version 2 - Future version with enhanced features
        s.setupAPIV2(r)

        s.server = &amp;http.Server{
                Addr:              ":" + port,
                Handler:           r,
                ReadHeaderTimeout: 10 * time.Second,
                ReadTimeout:       30 * time.Second,
                WriteTimeout:      30 * time.Second,
        }

        return s</span>
}

// setupAPIV1 configures API version 1 routes (current stable version)
func (s *AdminServer) setupAPIV1(r *mux.Router) <span class="cov8" title="1">{
        // Initialize swagger docs for v1
        docs.SwaggerInfo.Host = "localhost:" + s.port
        docs.SwaggerInfo.BasePath = "/api/v1"
        docs.SwaggerInfo.Title = "Language Exchange Bot Admin API v1"
        docs.SwaggerInfo.Version = "1.0.0"

        // API v1 routes
        v1 := r.PathPrefix("/api/v1").Subrouter()
        v1.Use(s.corsMiddleware)
        v1.Use(s.authMiddleware)

        // API v1 endpoints (current stable API)
        v1.HandleFunc("/stats", s.handleGetStats).Methods("GET")
        v1.HandleFunc("/users/{id:[0-9]+}", s.handleGetUser).Methods("GET")
        v1.HandleFunc("/users", s.handleGetUsers).Methods("GET").Queries("limit", "{limit:[0-9]+}", "offset", "{offset:[0-9]+}")
        v1.HandleFunc("/feedback/unprocessed", s.handleGetUnprocessedFeedback).Methods("GET")
        v1.HandleFunc("/feedback/{id:[0-9]+}/process", s.handleProcessFeedback).Methods("POST")
        v1.HandleFunc("/rate-limits/stats", s.handleGetRateLimitStats).Methods("GET")
        v1.HandleFunc("/cache/stats", s.handleGetCacheStats).Methods("GET")
        v1.HandleFunc("/webhook/status", s.handleGetWebhookStatus).Methods("GET")
        v1.HandleFunc("/webhook/setup", s.handleSetupWebhook).Methods("POST")
        v1.HandleFunc("/webhook/remove", s.handleRemoveWebhook).Methods("POST")
}</span>

// setupAPIV2 configures API version 2 routes (future version with enhanced features)
func (s *AdminServer) setupAPIV2(r *mux.Router) <span class="cov8" title="1">{
        // API v2 routes
        v2 := r.PathPrefix("/api/v2").Subrouter()
        v2.Use(s.corsMiddleware)
        v2.Use(s.authMiddleware)

        // API v2 endpoints (enhanced version - currently same as v1 for compatibility)
        // TODO: Add new features and enhancements in v2
        v2.HandleFunc("/stats", s.handleGetStatsV2).Methods("GET")
        v2.HandleFunc("/users/{id:[0-9]+}", s.handleGetUser).Methods("GET")
        v2.HandleFunc("/users", s.handleGetUsers).Methods("GET").Queries("limit", "{limit:[0-9]+}", "offset", "{offset:[0-9]+}")
        v2.HandleFunc("/feedback/unprocessed", s.handleGetUnprocessedFeedback).Methods("GET")
        v2.HandleFunc("/feedback/{id:[0-9]+}/process", s.handleProcessFeedback).Methods("POST")
        v2.HandleFunc("/rate-limits/stats", s.handleGetRateLimitStats).Methods("GET")
        v2.HandleFunc("/cache/stats", s.handleGetCacheStats).Methods("GET")
        v2.HandleFunc("/webhook/status", s.handleGetWebhookStatus).Methods("GET")
        v2.HandleFunc("/webhook/setup", s.handleSetupWebhook).Methods("POST")
        v2.HandleFunc("/webhook/remove", s.handleRemoveWebhook).Methods("POST")

        // New v2 endpoints
        v2.HandleFunc("/system/health", s.handleGetSystemHealth).Methods("GET")
        v2.HandleFunc("/metrics/performance", s.handleGetPerformanceMetrics).Methods("GET")
}</span>

// Start starts the admin HTTP server
func (s *AdminServer) Start() error <span class="cov8" title="1">{
        fmt.Printf("Admin API server starting on port %s\n", s.port)
        return s.server.ListenAndServe()
}</span>

// Stop stops the admin HTTP server
func (s *AdminServer) Stop(ctx context.Context) error <span class="cov8" title="1">{
        return s.server.Shutdown(ctx)
}</span>

// corsMiddleware adds CORS headers
func (s *AdminServer) corsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// authMiddleware provides basic authentication for admin endpoints
func (s *AdminServer) authMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // TODO: Implement proper authentication
                // For now, just check for a simple header
                if auth := r.Header.Get("X-Admin-Key"); auth != "admin-secret-key" </span><span class="cov8" title="1">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// handleHealth provides health check endpoint
// @Summary Health check
// @Description Check if the service is healthy
// @Tags health
// @Produce json
// @Success 200 {object} map[string]string
// @Router /healthz [get]
func (s *AdminServer) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        response := map[string]string{
                "status": "healthy",
                "time":   time.Now().Format(time.RFC3339),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleReady provides readiness check endpoint
// @Summary Readiness check
// @Description Check if the service is ready to serve requests
// @Tags health
// @Produce json
// @Success 200 {object} map[string]string
// @Router /readyz [get]
func (s *AdminServer) handleReady(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        response := map[string]string{
                "status": "ready",
                "time":   time.Now().Format(time.RFC3339),
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetStats returns general statistics
// @Summary Get general statistics
// @Description Retrieve general bot statistics
// @Tags statistics
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/stats [get]
func (s *AdminServer) handleGetStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        stats := map[string]interface{}{
                "timestamp":    time.Now().Format(time.RFC3339),
                "version":      "3.0.0",
                "service":      "language-exchange-bot",
                "uptime":       "simulated uptime data", // TODO: Add real uptime tracking
                "active_users": 0,                       // TODO: Add real user count
                "total_users":  0,                       // TODO: Add real user count
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(stats); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetUser returns user information
// @Summary Get user by ID
// @Description Retrieve user information by Telegram ID
// @Tags users
// @Produce json
// @Security ApiKeyAuth
// @Param id path int true "Telegram User ID"
// @Success 200 {object} models.User
// @Failure 404 {object} map[string]string
// @Router /api/v1/users/{id} [get]
func (s *AdminServer) handleGetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        userIDStr := vars["id"]

        userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := s.botService.GetCachedUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                if customErr, ok := err.(*errors.CustomError); ok &amp;&amp; customErr.Type == errors.ErrorTypeDatabase </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Internal server error", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(user); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetUsers returns list of users with pagination
// @Summary Get users list
// @Description Retrieve paginated list of users
// @Tags users
// @Produce json
// @Security ApiKeyAuth
// @Param limit query int false "Number of users to return" default(50)
// @Param offset query int false "Offset for pagination" default(0)
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/users [get]
func (s *AdminServer) handleGetUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // TODO: Implement pagination
        // For now, return empty list
        response := map[string]interface{}{
                "users":  []models.User{},
                "total":  0,
                "limit":  50,
                "offset": 0,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetUnprocessedFeedback returns unprocessed feedback
// @Summary Get unprocessed feedback
// @Description Retrieve all unprocessed user feedback
// @Tags feedback
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {array} map[string]interface{}
// @Router /api/v1/feedback/unprocessed [get]
func (s *AdminServer) handleGetUnprocessedFeedback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        feedback, err := s.botService.GetAllUnprocessedFeedback()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get feedback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(feedback); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleProcessFeedback marks feedback as processed
// @Summary Process feedback
// @Description Mark feedback as processed with optional response
// @Tags feedback
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param id path int true "Feedback ID"
// @Param request body map[string]string true "Processing request"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /api/v1/feedback/{id}/process [post]
func (s *AdminServer) handleProcessFeedback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        feedbackIDStr := vars["id"]

        feedbackID, err := strconv.Atoi(feedbackIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid feedback ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req map[string]string
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">adminResponse, exists := req["admin_response"]
        if !exists </span><span class="cov0" title="0">{
                adminResponse = ""
        }</span>

        <span class="cov0" title="0">err = s.botService.MarkFeedbackProcessed(feedbackID, adminResponse)
        if err != nil </span><span class="cov0" title="0">{
                if customErr, ok := err.(*errors.CustomError); ok &amp;&amp; customErr.Type == errors.ErrorTypeDatabase </span><span class="cov0" title="0">{
                        http.Error(w, "Feedback not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to process feedback", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">response := map[string]string{
                "status": "processed",
                "id":     feedbackIDStr,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetRateLimitStats returns rate limiting statistics
// @Summary Get rate limit statistics
// @Description Retrieve rate limiting statistics
// @Tags monitoring
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/rate-limits/stats [get]
func (s *AdminServer) handleGetRateLimitStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if s.handler == nil </span><span class="cov0" title="0">{
                http.Error(w, "Handler not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">stats := s.handler.GetRateLimiterStats()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(stats); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetCacheStats returns cache statistics
// @Summary Get cache statistics
// @Description Retrieve cache performance statistics
// @Tags monitoring
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/cache/stats [get]
func (s *AdminServer) handleGetCacheStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stats := s.botService.GetCacheStats()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(stats); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleNavigation serves the main navigation page
// @Summary Get navigation page
// @Description Returns the main navigation dashboard
// @Tags navigation
// @Produce html
// @Success 200 {string} string "HTML page"
// @Router / [get]
func (s *AdminServer) handleNavigation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        http.ServeFile(w, r, "./static/index.html")
}</span>

// handleTelegramWebhook handles Telegram webhook requests
// @Summary Handle Telegram webhook
// @Description Receives and processes webhook updates from Telegram
// @Tags webhook
// @Accept json
// @Param token path string true "Bot token"
// @Param update body object true "Telegram update JSON"
// @Success 200 {string} string "OK"
// @Router /webhook/telegram/{token} [post]
func (s *AdminServer) handleTelegramWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        token := vars["token"]

        // Basic token validation (should be improved with proper secret)
        // In production, this should validate against a stored secret
        if token == "" </span><span class="cov0" title="0">{
                http.Error(w, "Invalid token", http.StatusUnauthorized)
                return
        }</span>

        // Parse Telegram update
        <span class="cov0" title="0">var update tgbotapi.Update
        if err := json.NewDecoder(r.Body).Decode(&amp;update); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to parse update", http.StatusBadRequest)
                return
        }</span>

        // Process update asynchronously to avoid blocking webhook response
        <span class="cov0" title="0">go func(upd tgbotapi.Update) </span><span class="cov0" title="0">{
                if s.handler != nil </span><span class="cov0" title="0">{
                        if err := s.handler.HandleUpdate(upd); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error handling webhook update: %v", err)
                        }</span>
                }
        }(update)

        // Respond immediately to acknowledge receipt
        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)
        if _, err := w.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to write response: %v", err)
        }</span>
}

// handleGetWebhookStatus returns webhook configuration status
// @Summary Get webhook status
// @Description Returns current webhook configuration and status
// @Tags webhook
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/webhook/status [get]
func (s *AdminServer) handleGetWebhookStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        status := map[string]interface{}{
                "webhook_mode_enabled": s.webhookMode,
                "handler_configured":   s.handler != nil,
                "service_available":    s.handler != nil &amp;&amp; s.handler.GetService() != nil,
                "bot_api_available":    s.handler != nil &amp;&amp; s.handler.GetBotAPI() != nil,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(status); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleSetupWebhook sets up webhook for the bot
// @Summary Setup webhook
// @Description Configures webhook for Telegram bot
// @Tags webhook
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param request body map[string]string true "Webhook setup parameters"
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/webhook/setup [post]
func (s *AdminServer) handleSetupWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req map[string]string
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">webhookURL, exists := req["webhook_url"]
        if !exists || webhookURL == "" </span><span class="cov0" title="0">{
                http.Error(w, "webhook_url is required", http.StatusBadRequest)
                return
        }</span>

        // This would need access to the bot instance to setup webhook
        // For now, return success with note
        <span class="cov0" title="0">result := map[string]interface{}{
                "status":      "webhook_setup_requested",
                "webhook_url": webhookURL,
                "note":        "Webhook setup requires bot instance access. Use environment variables for initial setup.",
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleRemoveWebhook removes webhook configuration
// @Summary Remove webhook
// @Description Removes webhook configuration from Telegram bot
// @Tags webhook
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/webhook/remove [post]
func (s *AdminServer) handleRemoveWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // This would need access to the bot instance to remove webhook
        result := map[string]interface{}{
                "status": "webhook_removal_requested",
                "note":   "Webhook removal requires bot instance access. Use environment variables to switch modes.",
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// ===== Helper Methods =====

// getStatsData returns basic statistics data
func (s *AdminServer) getStatsData() (map[string]interface{}, error) <span class="cov8" title="1">{
        stats := map[string]interface{}{
                "timestamp":    time.Now().Format(time.RFC3339),
                "version":      "3.0.0",
                "service":      "language-exchange-bot",
                "uptime":       "simulated uptime data", // TODO: Add real uptime tracking
                "active_users": 0,                       // TODO: Add real user count
                "total_users":  0,                       // TODO: Add real user count
        }

        return stats, nil
}</span>

// ===== API v2 Handlers =====

// handleGetStatsV2 returns enhanced statistics for API v2
// @Summary Get enhanced statistics
// @Description Returns comprehensive system statistics including performance metrics
// @Tags statistics
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v2/stats [get]
func (s *AdminServer) handleGetStatsV2(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get basic stats from v1 handler
        basicStats, err := s.getStatsData()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get statistics", http.StatusInternalServerError)
                return
        }</span>

        // Add enhanced v2 metrics
        <span class="cov0" title="0">enhancedStats := map[string]interface{}{
                "version":           "v2",
                "timestamp":         time.Now().Unix(),
                "basic_stats":       basicStats,
                "cache_performance": s.botService.GetCacheStats(),
                "circuit_breakers":  s.botService.GetCircuitBreakerStates(),
                "system_info": map[string]interface{}{
                        "go_version":    "1.25",
                        "server_uptime": "available", // TODO: implement uptime tracking
                        "memory_usage":  "available", // TODO: implement memory monitoring
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(enhancedStats); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetSystemHealth returns comprehensive system health information
// @Summary Get system health
// @Description Returns detailed health status of all system components
// @Tags health
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v2/system/health [get]
func (s *AdminServer) handleGetSystemHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        health := map[string]interface{}{
                "version":   "v2",
                "timestamp": time.Now().Unix(),
                "status":    "healthy",
                "components": map[string]interface{}{
                        "database": map[string]interface{}{
                                "status":     "healthy",
                                "last_check": time.Now().Unix(),
                        },
                        "redis": map[string]interface{}{
                                "status":     "healthy",
                                "last_check": time.Now().Unix(),
                        },
                        "telegram_bot": map[string]interface{}{
                                "status":       s.webhookMode &amp;&amp; s.handler != nil,
                                "webhook_mode": s.webhookMode,
                                "last_check":   time.Now().Unix(),
                        },
                        "circuit_breakers": s.botService.GetCircuitBreakerStates(),
                },
                "uptime": "available", // TODO: implement actual uptime tracking
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(health); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

// handleGetPerformanceMetrics returns detailed performance metrics
// @Summary Get performance metrics
// @Description Returns detailed performance and monitoring metrics
// @Tags metrics
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} map[string]interface{}
// @Router /api/v2/metrics/performance [get]
func (s *AdminServer) handleGetPerformanceMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        metrics := map[string]interface{}{
                "version":   "v2",
                "timestamp": time.Now().Unix(),
                "cache":     s.botService.GetCacheStats(),
                "rate_limits": map[string]interface{}{
                        "stats": "available", // TODO: integrate with rate limiting system
                },
                "database": map[string]interface{}{
                        "connection_pool": map[string]interface{}{
                                "status": "healthy",
                        },
                        "query_performance": map[string]interface{}{
                                "avg_query_time": "available", // TODO: implement query timing
                        },
                },
                "telegram": map[string]interface{}{
                        "api_calls": map[string]interface{}{
                                "total":  "available", // TODO: implement API call tracking
                                "errors": "available",
                        },
                },
                "system": map[string]interface{}{
                        "goroutines": "available", // TODO: implement goroutine monitoring
                        "memory":     "available",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package validation

import (
        "strings"

        "language-exchange-bot/internal/localization"
)

// MessageValidator валидирует сообщения и callback'и.
type MessageValidator struct {
        validator *Validator
}

// NewMessageValidator создает новый валидатор сообщений.
func NewMessageValidator() *MessageValidator <span class="cov8" title="1">{
        return &amp;MessageValidator{
                validator: NewValidator(),
        }
}</span>

// ValidateMessage валидирует входящее сообщение.
func (mv *MessageValidator) ValidateMessage(chatID, userID int64, text string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация текста сообщения
        <span class="cov8" title="1">if text != "" </span><span class="cov8" title="1">{
                if errors := mv.validator.ValidateString(text, []string{"max:4096"}); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                result.AddError("text", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateCallbackQuery валидирует callback query.
func (mv *MessageValidator) ValidateCallbackQuery(chatID, userID int64, data string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация данных callback
        <span class="cov8" title="1">if errors := mv.validator.ValidateCallbackData(data); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("callback_data", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateFeedbackMessage валидирует сообщение отзыва.
func (mv *MessageValidator) ValidateFeedbackMessage(chatID, userID int64, text string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация текста отзыва
        <span class="cov8" title="1">if errors := mv.validator.ValidateFeedbackText(text); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("feedback_text", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateCommand валидирует команду.
func (mv *MessageValidator) ValidateCommand(chatID, userID int64, command string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация команды
        <span class="cov8" title="1">if strings.TrimSpace(command) == "" </span><span class="cov8" title="1">{
                result.AddError("command", "Команда обязательна")

                return result
        }</span>

        // Проверяем, что команда начинается с /
        <span class="cov8" title="1">if !strings.HasPrefix(command, "/") </span><span class="cov0" title="0">{
                result.AddError("command", "Команда должна начинаться с /")
        }</span>

        // Проверяем длину команды
        <span class="cov8" title="1">if len(command) &gt; localization.MaxCommandLength </span><span class="cov8" title="1">{
                result.AddError("command", "Команда слишком длинная")
        }</span>

        // Проверяем, что команда содержит только разрешенные символы
        <span class="cov8" title="1">if errors := mv.validator.ValidateString(command, []string{"alphanumeric"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                result.AddError("command", "Команда содержит недопустимые символы")
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ValidateLanguageSelection валидирует выбор языка.
func (mv *MessageValidator) ValidateLanguageSelection(chatID, userID int64, languageCode string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация кода языка
        <span class="cov8" title="1">if errors := mv.validator.ValidateLanguageCode(languageCode); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("language_code", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateInterestSelection валидирует выбор интереса.
func (mv *MessageValidator) ValidateInterestSelection(chatID, userID int64, interestID int) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация ID интереса
        <span class="cov8" title="1">if errors := mv.validator.ValidateInterestID(interestID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("interest_id", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateLanguageLevelSelection валидирует выбор уровня языка.
func (mv *MessageValidator) ValidateLanguageLevelSelection(chatID, userID int64, level int) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov8" title="1">if errors := mv.validator.ValidateTelegramID(userID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация уровня языка
        <span class="cov8" title="1">if errors := mv.validator.ValidateLanguageLevel(level); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("language_level", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package validation

import (
        "fmt"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"
)

// UserValidator валидирует данные пользователя.
type UserValidator struct {
        validator *Validator
}

// NewUserValidator создает новый валидатор пользователей.
func NewUserValidator() *UserValidator <span class="cov8" title="1">{
        return &amp;UserValidator{
                validator: NewValidator(),
        }
}</span>

// ValidateUser валидирует данные пользователя.
func (uv *UserValidator) ValidateUser(user *models.User) *Result <span class="cov8" title="1">{
        result := NewResult()

        uv.validateTelegramID(user.TelegramID, result)
        uv.validateFirstName(user.FirstName, result)
        uv.validateUsername(user.Username, result)
        uv.validateInterfaceLanguage(user.InterfaceLanguageCode, result)
        uv.validateUserState(user.State, result)

        return result
}</span>

// validateTelegramID валидирует Telegram ID.
func (uv *UserValidator) validateTelegramID(telegramID int64, result *Result) <span class="cov8" title="1">{
        if errors := uv.validator.ValidateTelegramID(telegramID); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("telegram_id", err)
                }</span>
        }
}

// validateFirstName валидирует имя пользователя.
func (uv *UserValidator) validateFirstName(firstName string, result *Result) <span class="cov8" title="1">{
        if errors := uv.validator.ValidateString(firstName, []string{"required", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("first_name", err)
                }</span>
        }
}

// validateUsername валидирует username.
func (uv *UserValidator) validateUsername(username string, result *Result) <span class="cov8" title="1">{
        if username != "" </span><span class="cov8" title="1">{
                if errors := uv.validator.ValidateString(username, []string{"username", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        for _, err := range errors </span><span class="cov8" title="1">{
                                result.AddError("username", err)
                        }</span>
                }
        }
}

// validateInterfaceLanguage валидирует язык интерфейса.
func (uv *UserValidator) validateInterfaceLanguage(languageCode string, result *Result) <span class="cov8" title="1">{
        if errors := uv.validator.ValidateLanguageCode(languageCode); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("interface_language_code", err)
                }</span>
        }
}

// validateUserState валидирует состояние пользователя.
func (uv *UserValidator) validateUserState(state string, result *Result) <span class="cov8" title="1">{
        if errors := uv.validator.ValidateUserState(state); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("state", err)
                }</span>
        }
}

// ValidateUserRegistration валидирует данные при регистрации пользователя.
func (uv *UserValidator) ValidateUserRegistration(telegramID int, username, firstName, languageCode string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация Telegram ID
        if errors := uv.validator.ValidateTelegramID(int64(telegramID)); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("telegram_id", err)
                }</span>
        }

        // Валидация имени пользователя
        <span class="cov8" title="1">if errors := uv.validator.ValidateString(firstName, []string{"required", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("first_name", err)
                }</span>
        }

        // Валидация username (если есть)
        <span class="cov8" title="1">if username != "" </span><span class="cov8" title="1">{
                if errors := uv.validator.ValidateString(username, []string{"username", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        for _, err := range errors </span><span class="cov8" title="1">{
                                result.AddError("username", err)
                        }</span>
                }
        }

        // Валидация кода языка
        <span class="cov8" title="1">if errors := uv.validator.ValidateLanguageCode(languageCode); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("language_code", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateUserUpdate валидирует данные при обновлении пользователя.
func (uv *UserValidator) ValidateUserUpdate(user *models.User) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация имени пользователя
        if errors := uv.validator.ValidateString(user.FirstName, []string{"required", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("first_name", err)
                }</span>
        }

        // Валидация username (если есть)
        <span class="cov8" title="1">if user.Username != "" </span><span class="cov0" title="0">{
                if errors := uv.validator.ValidateString(user.Username, []string{"username", "max:50"}); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                result.AddError("username", err)
                        }</span>
                }
        }

        // Валидация кода языка интерфейса
        <span class="cov8" title="1">if errors := uv.validator.ValidateLanguageCode(user.InterfaceLanguageCode); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("interface_language_code", err)
                }</span>
        }

        // Валидация состояния пользователя
        <span class="cov8" title="1">if errors := uv.validator.ValidateUserState(user.State); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("state", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateUserInterests валидирует интересы пользователя.
func (uv *UserValidator) ValidateUserInterests(interestIDs []int) *Result <span class="cov8" title="1">{
        result := NewResult()

        if len(interestIDs) == 0 </span><span class="cov8" title="1">{
                result.AddError("interests", "Необходимо выбрать хотя бы один интерес")

                return result
        }</span>

        <span class="cov8" title="1">if len(interestIDs) &gt; localization.MaxInterestCount </span><span class="cov0" title="0">{
                result.AddError("interests", fmt.Sprintf("Максимум %d интересов", localization.MaxInterestCount))

                return result
        }</span>

        // Валидация каждого ID интереса
        <span class="cov8" title="1">for index, interestID := range interestIDs </span><span class="cov8" title="1">{
                if errors := uv.validator.ValidateInterestID(interestID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                result.AddError("interests", err)
                        }</span>
                }

                // Проверка на дубликаты
                <span class="cov8" title="1">for j, otherID := range interestIDs </span><span class="cov8" title="1">{
                        if index != j &amp;&amp; interestID == otherID </span><span class="cov0" title="0">{
                                result.AddError("interests", "Дублирующиеся интересы не допускаются")

                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateUserLanguages валидирует языки пользователя.
func (uv *UserValidator) ValidateUserLanguages(nativeLanguage, targetLanguage string) *Result <span class="cov8" title="1">{
        result := NewResult()

        // Валидация родного языка
        if errors := uv.validator.ValidateLanguageCode(nativeLanguage); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("native_language", err)
                }</span>
        }

        // Валидация целевого языка
        <span class="cov8" title="1">if errors := uv.validator.ValidateLanguageCode(targetLanguage); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("target_language", err)
                }</span>
        }

        // Проверка, что языки разные
        <span class="cov8" title="1">if nativeLanguage == targetLanguage </span><span class="cov8" title="1">{
                result.AddError("languages", "Родной и целевой языки должны отличаться")
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ValidateUserLanguageLevel валидирует уровень языка пользователя.
func (uv *UserValidator) ValidateUserLanguageLevel(level int) *Result <span class="cov8" title="1">{
        result := NewResult()

        if errors := uv.validator.ValidateLanguageLevel(level); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("language_level", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Package validation provides input validation and data sanitization.
package validation

import (
        "fmt"
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/models"
)

// Service предоставляет сервис валидации с интеграцией ошибок.
type Service struct {
        userValidator    *UserValidator
        messageValidator *MessageValidator
        errorHandler     *errors.ErrorHandler
}

// NewService создает новый сервис валидации.
func NewService(errorHandler *errors.ErrorHandler) *Service <span class="cov8" title="1">{
        return &amp;Service{
                userValidator:    NewUserValidator(),
                messageValidator: NewMessageValidator(),
                errorHandler:     errorHandler,
        }
}</span>

// ValidateUserWithErrorHandling валидирует пользователя с обработкой ошибок.
func (vs *Service) ValidateUserWithErrorHandling(user *models.User, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUser(user)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации пользователя",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserRegistrationWithErrorHandling валидирует регистрацию пользователя.
func (vs *Service) ValidateUserRegistrationWithErrorHandling(
        telegramID int,
        username, firstName, languageCode string,
        userID, chatID int64,
        operation string,
) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserRegistration(telegramID, username, firstName, languageCode)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации при регистрации",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserUpdateWithErrorHandling валидирует обновление пользователя.
func (vs *Service) ValidateUserUpdateWithErrorHandling(
        user *models.User,
        userID, chatID int64,
        operation string,
) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserUpdate(user)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации при обновлении",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserInterestsWithErrorHandling валидирует интересы пользователя.
func (vs *Service) ValidateUserInterestsWithErrorHandling(
        interestIDs []int,
        userID, chatID int64,
        operation string,
) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserInterests(interestIDs)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации интересов",
                        "Проверьте выбранные интересы",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserLanguagesWithErrorHandling валидирует языки пользователя.
func (vs *Service) ValidateUserLanguagesWithErrorHandling(
        nativeLanguage, targetLanguage string,
        userID, chatID int64,
        operation string,
) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserLanguages(nativeLanguage, targetLanguage)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации языков",
                        "Проверьте выбранные языки",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateMessageWithErrorHandling валидирует сообщение с обработкой ошибок.
func (vs *Service) ValidateMessageWithErrorHandling(chatID, userID int64, text, operation string) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateMessage(chatID, userID, text)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации сообщения",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateCallbackQueryWithErrorHandling валидирует callback query с обработкой ошибок.
func (vs *Service) ValidateCallbackQueryWithErrorHandling(chatID, userID int64, data, operation string) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateCallbackQuery(chatID, userID, data)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации callback query",
                        "Проверьте данные запроса",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateFeedbackMessageWithErrorHandling валидирует сообщение отзыва с обработкой ошибок.
func (vs *Service) ValidateFeedbackMessageWithErrorHandling(chatID, userID int64, text, operation string) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateFeedbackMessage(chatID, userID, text)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации отзыва",
                        "Проверьте текст отзыва",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateCommandWithErrorHandling валидирует команду с обработкой ошибок.
func (vs *Service) ValidateCommandWithErrorHandling(chatID, userID int64, command, operation string) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateCommand(chatID, userID, command)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации команды",
                        "Проверьте команду",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateLanguageSelectionWithErrorHandling валидирует выбор языка с обработкой ошибок.
func (vs *Service) ValidateLanguageSelectionWithErrorHandling(
        chatID, userID int64,
        languageCode, operation string,
) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateLanguageSelection(chatID, userID, languageCode)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации выбора языка",
                        "Проверьте выбранный язык",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateInterestSelectionWithErrorHandling валидирует выбор интереса с обработкой ошибок.
func (vs *Service) ValidateInterestSelectionWithErrorHandling(
        chatID, userID int64,
        interestID int,
        operation string,
) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateInterestSelection(chatID, userID, interestID)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации выбора интереса",
                        "Проверьте выбранный интерес",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateLanguageLevelSelectionWithErrorHandling валидирует выбор уровня языка с обработкой ошибок.
func (vs *Service) ValidateLanguageLevelSelectionWithErrorHandling(
        chatID, userID int64,
        level int,
        operation string,
) error <span class="cov8" title="1">{
        result := vs.messageValidator.ValidateLanguageLevelSelection(chatID, userID, level)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации выбора уровня языка",
                        "Проверьте выбранный уровень",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("validation error handling failed: %w", vs.errorHandler.Handle(validationErr, ctx))</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package validation

import (
        "fmt"
        "regexp"
        "strings"
        "unicode/utf8"

        "language-exchange-bot/internal/localization"
)

// Validation constants are now centralized in localization/constants.go

// Rule представляет правило валидации.
type Rule struct {
        Field    string
        Value    interface{}
        Rules    []string
        Messages map[string]string
}

// Result содержит результат валидации.
type Result struct {
        IsValid bool
        Errors  map[string][]string
}

// NewResult создает новый результат валидации.
func NewResult() *Result <span class="cov8" title="1">{
        return &amp;Result{
                IsValid: true,
                Errors:  make(map[string][]string),
        }
}</span>

// AddError добавляет ошибку валидации.
func (vr *Result) AddError(field, message string) <span class="cov8" title="1">{
        vr.IsValid = false
        vr.Errors[field] = append(vr.Errors[field], message)
}</span>

// GetErrors возвращает все ошибки валидации.
func (vr *Result) GetErrors() map[string][]string <span class="cov8" title="1">{
        return vr.Errors
}</span>

// HasErrors проверяет, есть ли ошибки.
func (vr *Result) HasErrors() bool <span class="cov8" title="1">{
        return !vr.IsValid
}</span>

// Validator содержит методы валидации.
type Validator struct{}

// NewValidator создает новый валидатор.
func NewValidator() *Validator <span class="cov8" title="1">{
        return &amp;Validator{}
}</span>

// ValidateString валидирует строковое значение.
func (v *Validator) ValidateString(value string, rules []string) []string <span class="cov8" title="1">{
        var errors []string

        for _, rule := range rules </span><span class="cov8" title="1">{
                if err := v.validateStringRule(value, rule); err != "" </span><span class="cov8" title="1">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

// validateStringRule валидирует одно правило для строки.
func (v *Validator) validateStringRule(value, rule string) string <span class="cov8" title="1">{
        switch rule </span>{
        case "required":<span class="cov8" title="1">
                return v.validateRequired(value)</span>
        case "min:3":<span class="cov8" title="1">
                return v.validateMinLength(value, localization.MinStringLength)</span>
        case "max:50":<span class="cov8" title="1">
                return v.validateMaxLength(value, localization.MaxUsernameLength, "50 символов")</span>
        case "max:100":<span class="cov0" title="0">
                return v.validateMaxLength(value, localization.MaxStringLength, "100 символов")</span>
        case "max:500":<span class="cov0" title="0">
                return v.validateMaxLength(value, localization.MaxBioLength, "500 символов")</span>
        case "alphanumeric":<span class="cov8" title="1">
                return v.validatePattern(value, `^[a-zA-Z0-9]+$`, "Только буквы и цифры")</span>
        case "username":<span class="cov8" title="1">
                return v.validatePattern(value, `^[a-zA-Z0-9_]+$`, "Некорректный username")</span>
        case "email":<span class="cov0" title="0">
                return v.validatePattern(value, `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`, "Некорректный email")</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// validateRequired проверяет обязательность поля.
func (v *Validator) validateRequired(value string) string <span class="cov8" title="1">{
        if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                return "Поле обязательно для заполнения"
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// validateMinLength проверяет минимальную длину.
func (v *Validator) validateMinLength(value string, minLen int) string <span class="cov8" title="1">{
        if utf8.RuneCountInString(value) &lt; minLen </span><span class="cov8" title="1">{
                return fmt.Sprintf("Минимум %d символов", minLen)
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// validateMaxLength проверяет максимальную длину.
func (v *Validator) validateMaxLength(value string, maxLen int, message string) string <span class="cov8" title="1">{
        if utf8.RuneCountInString(value) &gt; maxLen </span><span class="cov0" title="0">{
                return "Максимум " + message
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// validatePattern проверяет соответствие паттерну.
func (v *Validator) validatePattern(value, pattern, message string) string <span class="cov8" title="1">{
        if !regexp.MustCompile(pattern).MatchString(value) </span><span class="cov8" title="1">{
                return message
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// ValidateInt валидирует целочисленное значение.
func (v *Validator) ValidateInt(value int, rules []string) []string <span class="cov8" title="1">{
        var errors []string

        for _, rule := range rules </span><span class="cov8" title="1">{
                switch rule </span>{
                case "required":<span class="cov8" title="1">
                        if value == 0 </span><span class="cov8" title="1">{
                                errors = append(errors, "Значение обязательно")
                        }</span>
                case "min:1":<span class="cov8" title="1">
                        if value &lt; 1 </span><span class="cov8" title="1">{
                                errors = append(errors, "Минимум 1")
                        }</span>
                case "max:100":<span class="cov8" title="1">
                        if value &gt; localization.MaxStringLength </span><span class="cov8" title="1">{
                                errors = append(errors, "Максимум 100")
                        }</span>
                case "positive":<span class="cov8" title="1">
                        if value &lt;= 0 </span><span class="cov8" title="1">{
                                errors = append(errors, "Должно быть положительным")
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// ValidateLanguageCode валидирует код языка.
func (v *Validator) ValidateLanguageCode(code string) []string <span class="cov8" title="1">{
        var errors []string

        if strings.TrimSpace(code) == "" </span><span class="cov8" title="1">{
                errors = append(errors, "Код языка обязателен")

                return errors
        }</span>

        // Проверяем формат кода языка (2 символа)
        <span class="cov8" title="1">if len(code) != localization.LanguageCodeLength </span><span class="cov8" title="1">{
                errors = append(errors, "Код языка должен содержать 2 символа")
        }</span>

        // Проверяем, что код содержит только буквы
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z]{2}$`).MatchString(code) </span><span class="cov8" title="1">{
                errors = append(errors, "Код языка должен содержать только буквы")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateTelegramID валидирует Telegram ID.
func (v *Validator) ValidateTelegramID(telegramID int64) []string <span class="cov8" title="1">{
        var errors []string

        if telegramID &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "Telegram ID должен быть положительным")
        }</span>

        // Telegram ID обычно больше MinTelegramID
        <span class="cov8" title="1">if telegramID &lt; localization.MinTelegramID </span><span class="cov8" title="1">{
                errors = append(errors, "Некорректный Telegram ID")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateChatID валидирует Chat ID.
func (v *Validator) ValidateChatID(chatID int64) []string <span class="cov8" title="1">{
        var errors []string

        if chatID == 0 </span><span class="cov8" title="1">{
                errors = append(errors, "Chat ID обязателен")

                return errors
        }</span>

        // Chat ID может быть отрицательным для групп
        <span class="cov8" title="1">if chatID &gt; 0 &amp;&amp; chatID &lt; 100000000 </span><span class="cov8" title="1">{
                errors = append(errors, "Некорректный Chat ID")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateUserState валидирует состояние пользователя.
func (v *Validator) ValidateUserState(state string) []string <span class="cov8" title="1">{
        var errors []string

        validStates := []string{
                "idle", "setting_language", "setting_native_language",
                "setting_target_language", "setting_interests", "setting_profile",
                "waiting_for_feedback", "viewing_profile", "editing_profile",
        }

        isValid := false

        for _, validState := range validStates </span><span class="cov8" title="1">{
                if state == validState </span><span class="cov8" title="1">{
                        isValid = true

                        break</span>
                }
        }

        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                errors = append(errors, "Некорректное состояние пользователя: "+state)
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateInterestID валидирует ID интереса.
func (v *Validator) ValidateInterestID(id int) []string <span class="cov8" title="1">{
        var errors []string

        if id &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "ID интереса должен быть положительным")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateLanguageLevel валидирует уровень языка.
func (v *Validator) ValidateLanguageLevel(level int) []string <span class="cov8" title="1">{
        var errors []string

        if level &lt; 1 || level &gt; 5 </span><span class="cov8" title="1">{
                errors = append(errors, "Уровень языка должен быть от 1 до 5")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateFeedbackText валидирует текст отзыва.
func (v *Validator) ValidateFeedbackText(text string) []string <span class="cov8" title="1">{
        var errors []string

        if strings.TrimSpace(text) == "" </span><span class="cov0" title="0">{
                errors = append(errors, "Текст отзыва обязателен")

                return errors
        }</span>

        <span class="cov8" title="1">textLength := utf8.RuneCountInString(strings.TrimSpace(text))
        if textLength &lt; localization.MinTextLength </span><span class="cov8" title="1">{
                errors = append(errors, "Минимум 10 символов")
        }</span>

        <span class="cov8" title="1">if textLength &gt; localization.MaxTextLength </span><span class="cov8" title="1">{
                errors = append(errors, "Максимум 1000 символов")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateCallbackData валидирует данные callback query.
func (v *Validator) ValidateCallbackData(data string) []string <span class="cov8" title="1">{
        var errors []string

        if strings.TrimSpace(data) == "" </span><span class="cov8" title="1">{
                errors = append(errors, "Данные callback обязательны")

                return errors
        }</span>

        <span class="cov8" title="1">if len(data) &gt; localization.MaxContactInfoLength </span><span class="cov8" title="1">{
                errors = append(errors, "Максимум 64 символа")
        }</span>

        // Проверяем, что данные содержат только разрешенные символы
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z0-9_:.-]+$`).MatchString(data) </span><span class="cov0" title="0">{
                errors = append(errors, "Некорректные символы в данных")
        }</span>

        <span class="cov8" title="1">return errors</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Package helpers provides test helper functions and utilities.
package helpers

import (
        "language-exchange-bot/internal/config"
)

// GetTestConfig возвращает конфигурацию для тестов.
func GetTestConfig() *config.Config <span class="cov0" title="0">{
        return &amp;config.Config{
                TelegramToken:  "test_token_12345",
                DatabaseURL:    "postgres://test:test@localhost:5432/test_db",
                Debug:          true,
                EnableTelegram: true,
                EnableDiscord:  false,
                AdminChatIDs:   []int64{123456789, 987654321},
                AdminUsernames: []string{"testadmin", "testadmin2"},
        }
}</span>

// GetTestAdminUser возвращает данные тестового администратора.
//
//nolint:mnd
func GetTestAdminUser() (int64, string) <span class="cov0" title="0">{
        return 123456789, "testadmin"
}</span>

// GetTestRegularUser возвращает данные тестового обычного пользователя.
//
//nolint:mnd
func GetTestRegularUser() (int64, string) <span class="cov0" title="0">{
        return 555666777, "testuser"
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package helpers

import (
        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/database"
        "language-exchange-bot/internal/localization"
        "language-exchange-bot/internal/models"
        "language-exchange-bot/tests/mocks"
        "time"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// SetupTestBot создает тестовый бот с моками.
func SetupTestBot(mockDB database.Database) (*mocks.TelegramHandlerWrapper, *core.BotService) <span class="cov0" title="0">{
        // Создаем простой локализатор для тестов - используем реальный с nil DB
        localizer := localization.NewLocalizer(nil)

        // Создаем тестовый сервис
        service := core.NewBotServiceWithInterface(mockDB, localizer)

        // Создаем обертку хендлера для тестирования
        wrapper := &amp;mocks.TelegramHandlerWrapper{
                Service:        service,
                SentMessages:   make([]tgbotapi.MessageConfig, 0),
                SentCallbacks:  make([]tgbotapi.CallbackConfig, 0),
                EditedMessages: make([]tgbotapi.EditMessageTextConfig, 0),
        }

        return wrapper, service
}</span>

// CreateTestMessage создает тестовое сообщение Telegram.
func CreateTestMessage(text string, userID int64, username string) *tgbotapi.Message <span class="cov0" title="0">{
        return &amp;tgbotapi.Message{
                MessageID: int(time.Now().Unix()),
                From: &amp;tgbotapi.User{
                        ID:           userID,
                        UserName:     username,
                        FirstName:    "Test",
                        LastName:     "User",
                        LanguageCode: "en",
                },
                Chat: &amp;tgbotapi.Chat{
                        ID:   userID,
                        Type: "private",
                },
                Date: int(time.Now().Unix()),
                Text: text,
        }
}</span>

// CreateTestCommand создает тестовую команду.
func CreateTestCommand(command string, userID int64, username string) *tgbotapi.Message <span class="cov0" title="0">{
        msg := CreateTestMessage("/"+command, userID, username)
        // Дополнительно устанавливаем поля для команды
        entities := []tgbotapi.MessageEntity{
                {
                        Type:   "bot_command",
                        Offset: 0,
                        Length: len(command) + 1,
                },
        }
        msg.Entities = entities

        return msg
}</span>

// CreateTestCallback создает тестовый callback query.
func CreateTestCallback(data string, userID int64) *tgbotapi.CallbackQuery <span class="cov0" title="0">{
        return &amp;tgbotapi.CallbackQuery{
                ID: "test_callback_" + data,
                From: &amp;tgbotapi.User{
                        ID:           userID,
                        UserName:     "testuser",
                        FirstName:    "Test",
                        LastName:     "User",
                        LanguageCode: "en",
                },
                Message: &amp;tgbotapi.Message{
                        MessageID: int(time.Now().Unix()),
                        Chat: &amp;tgbotapi.Chat{
                                ID:   userID,
                                Type: "private",
                        },
                },
                Data: data,
        }
}</span>

// CreateUpdateWithMessage создает Update с сообщением.
func CreateUpdateWithMessage(message *tgbotapi.Message) tgbotapi.Update <span class="cov0" title="0">{
        return tgbotapi.Update{
                UpdateID: int(time.Now().Unix()),
                Message:  message,
        }
}</span>

// CreateUpdateWithCallback создает Update с callback query.
func CreateUpdateWithCallback(callback *tgbotapi.CallbackQuery) tgbotapi.Update <span class="cov0" title="0">{
        return tgbotapi.Update{
                UpdateID:      int(time.Now().Unix()),
                CallbackQuery: callback,
        }
}</span>

// CreateTestUser создает тестового пользователя.
//
//nolint:mnd
func CreateTestUser() *models.User <span class="cov0" title="0">{
        return &amp;models.User{
                ID:                     1,
                TelegramID:             555666777,
                Username:               "testuser",
                FirstName:              "Test",
                NativeLanguageCode:     "",
                TargetLanguageCode:     "",
                InterfaceLanguageCode:  "en",
                CreatedAt:              time.Now(),
                UpdatedAt:              time.Now(),
                State:                  "new",
                ProfileCompletionLevel: 0,
                Status:                 "new",
        }
}</span>

// CreateTestAdminUser создает тестового администратора.
//
//nolint:mnd
func CreateTestAdminUser() *models.User <span class="cov0" title="0">{
        return &amp;models.User{
                ID:                     2,
                TelegramID:             123456789,
                Username:               "testadmin",
                FirstName:              "Admin",
                NativeLanguageCode:     "en",
                TargetLanguageCode:     "ru",
                InterfaceLanguageCode:  "en",
                CreatedAt:              time.Now(),
                UpdatedAt:              time.Now(),
                State:                  "ready",
                ProfileCompletionLevel: 100,
                Status:                 "active",
        }
}</span>

// CreateTestLocalizer создает простой локализатор для тестов.
func CreateTestLocalizer() *mocks.LocalizerMock <span class="cov0" title="0">{
        // Возвращаем мок локализатора вместо реального
        return mocks.NewLocalizerMock()
}</span>

// LocalizerInterface интерфейс для локализатора (чтобы можно было использовать мок).
type LocalizerInterface interface {
        Get(langCode, key string) string
        GetWithParams(langCode, key string, params map[string]string) string
        GetLanguageName(langCode, interfaceLangCode string) string
        GetInterests(langCode string) (map[int]string, error)
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Package mocks provides mock implementations for testing.
package mocks

import (
        "database/sql"
        "fmt"
        "language-exchange-bot/internal/models"
        "time"
)

// DatabaseMock имитирует базу данных для тестов.
type DatabaseMock struct {
        users     map[int64]*models.User
        languages map[string]*models.Language
        interests map[int]*models.Interest
        lastError error
}

// NewDatabaseMock создает новый мок базы данных.
func NewDatabaseMock() *DatabaseMock <span class="cov0" title="0">{
        db := &amp;DatabaseMock{
                users:     make(map[int64]*models.User),
                languages: make(map[string]*models.Language),
                interests: make(map[int]*models.Interest),
        }

        // Предзаполняем тестовыми языками
        db.seedLanguages()
        db.seedInterests()

        return db
}</span>

// seedLanguages добавляет тестовые языки.
//
//nolint:mnd
func (db *DatabaseMock) seedLanguages() <span class="cov0" title="0">{
        languages := []*models.Language{
                {ID: 1, Code: "en", NameNative: "English", NameEn: "English", IsInterfaceLanguage: true},
                {ID: 2, Code: "ru", NameNative: "Русский", NameEn: "Russian", IsInterfaceLanguage: true},
                {ID: 3, Code: "es", NameNative: "Español", NameEn: "Spanish", IsInterfaceLanguage: true},
                {ID: 4, Code: "zh", NameNative: "中文", NameEn: "Chinese", IsInterfaceLanguage: true},
        }

        for _, lang := range languages </span><span class="cov0" title="0">{
                db.languages[lang.Code] = lang
        }</span>
}

// seedInterests добавляет тестовые интересы.
//
//nolint:mnd
func (db *DatabaseMock) seedInterests() <span class="cov0" title="0">{
        interests := []*models.Interest{
                {ID: 1, KeyName: "movies", Type: "entertainment"},
                {ID: 2, KeyName: "music", Type: "entertainment"},
                {ID: 3, KeyName: "sports", Type: "activity"},
                {ID: 4, KeyName: "travel", Type: "activity"},
                {ID: 5, KeyName: "technology", Type: "knowledge"},
                {ID: 6, KeyName: "food", Type: "lifestyle"},
        }

        for _, interest := range interests </span><span class="cov0" title="0">{
                db.interests[interest.ID] = interest
        }</span>
}

// GetUserByTelegramID находит пользователя по Telegram ID.
func (db *DatabaseMock) GetUserByTelegramID(telegramID int64) (*models.User, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        <span class="cov0" title="0">user, exists := db.users[telegramID]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// CreateUser создает нового пользователя.
func (db *DatabaseMock) CreateUser(telegramID int64, username, firstName, languageCode string) (*models.User, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        <span class="cov0" title="0">user := &amp;models.User{
                ID:                     len(db.users) + 1,
                TelegramID:             telegramID,
                Username:               username,
                FirstName:              firstName,
                NativeLanguageCode:     "",
                TargetLanguageCode:     "",
                InterfaceLanguageCode:  languageCode,
                CreatedAt:              time.Now(),
                UpdatedAt:              time.Now(),
                State:                  "new",
                ProfileCompletionLevel: 0,
                Status:                 "new",
        }

        db.users[telegramID] = user

        return user, nil</span>
}

// FindOrCreateUser находит или создает пользователя (основной метод для BotService).
func (db *DatabaseMock) FindOrCreateUser(telegramID int64, username, firstName string) (*models.User, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        // Сначала пытаемся найти существующего пользователя
        <span class="cov0" title="0">if user, exists := db.users[telegramID]; exists </span><span class="cov0" title="0">{
                // Обновляем информацию если она изменилась
                user.Username = username
                user.FirstName = firstName
                user.UpdatedAt = time.Now()

                return user, nil
        }</span>

        // Если не найден, создаем нового
        <span class="cov0" title="0">return db.CreateUser(telegramID, username, firstName, "en")</span>
}

// UpdateUser обновляет пользователя.
func (db *DatabaseMock) UpdateUser(user *models.User) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">user.UpdatedAt = time.Now()
        db.users[user.TelegramID] = user

        return nil</span>
}

// GetLanguages возвращает все языки.
func (db *DatabaseMock) GetLanguages() ([]*models.Language, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        <span class="cov0" title="0">languages := make([]*models.Language, 0, len(db.languages))
        for _, lang := range db.languages </span><span class="cov0" title="0">{
                languages = append(languages, lang)
        }</span>

        <span class="cov0" title="0">return languages, nil</span>
}

// GetLanguageByCode возвращает язык по коду.
func (db *DatabaseMock) GetLanguageByCode(code string) (*models.Language, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        <span class="cov0" title="0">lang, exists := db.languages[code]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return lang, nil</span>
}

// GetInterests возвращает все интересы.
func (db *DatabaseMock) GetInterests() ([]*models.Interest, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        <span class="cov0" title="0">interests := make([]*models.Interest, 0, len(db.interests))
        for _, interest := range db.interests </span><span class="cov0" title="0">{
                interests = append(interests, interest)
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}

// SaveUserInterests сохраняет интересы пользователя.
func (db *DatabaseMock) SaveUserInterests(userID int, interestIDs []int) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        // В реальной БД здесь была бы таблица user_interests
        // Для мока просто сохраняем в пользователе
        // userID здесь database ID, но в mock используем telegram ID
        // Для простоты сохраняем по первому найденному пользователю
        <span class="cov0" title="0">for telegramID, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.Interests = interestIDs
                        user.UpdatedAt = time.Now()
                        break</span>
                }
                // Альтернативно, если userID совпадает с telegramID
                <span class="cov0" title="0">if int64(userID) == telegramID </span><span class="cov0" title="0">{
                        user.Interests = interestIDs
                        user.UpdatedAt = time.Now()
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetUserInterests возвращает интересы пользователя.
func (db *DatabaseMock) GetUserInterests(userID int64) ([]int, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        <span class="cov0" title="0">user, exists := db.users[userID]
        if !exists </span><span class="cov0" title="0">{
                return []int{}, nil
        }</span>

        <span class="cov0" title="0">return user.Interests, nil</span>
}

// GetUserSelectedInterests возвращает выбранные интересы пользователя.
func (db *DatabaseMock) GetUserSelectedInterests(userID int) ([]int, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        // Ищем пользователя по database ID
        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        return user.Interests, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("user not found")</span>
}

// UpdateUserInterfaceLanguage обновляет язык интерфейса пользователя.
func (db *DatabaseMock) UpdateUserInterfaceLanguage(userID int, language string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.InterfaceLanguageCode = language
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserState обновляет состояние пользователя.
func (db *DatabaseMock) UpdateUserState(userID int, state string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.State = state
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserStatus обновляет статус пользователя.
func (db *DatabaseMock) UpdateUserStatus(userID int, status string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.Status = status
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// SaveUserFeedback сохраняет отзыв пользователя (заглушка).
func (db *DatabaseMock) SaveUserFeedback(_ int, _ string, _ *string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        // Для тестов просто возвращаем успех
        <span class="cov0" title="0">return nil</span>
}

// GetUnprocessedFeedback возвращает необработанные отзывы (заглушка).
func (db *DatabaseMock) GetUnprocessedFeedback() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        // Для тестов возвращаем пустой список
        <span class="cov0" title="0">return []map[string]interface{}{}, nil</span>
}

// MarkFeedbackProcessed помечает отзыв как обработанный (заглушка).
func (db *DatabaseMock) MarkFeedbackProcessed(_ int, _ string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        // Для тестов просто возвращаем успех
        <span class="cov0" title="0">return nil</span>
}

// UpdateUserNativeLanguage обновляет родной язык пользователя.
func (db *DatabaseMock) UpdateUserNativeLanguage(userID int, langCode string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.NativeLanguageCode = langCode
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserTargetLanguage обновляет изучаемый язык пользователя.
func (db *DatabaseMock) UpdateUserTargetLanguage(userID int, langCode string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.TargetLanguageCode = langCode
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserTargetLanguageLevel обновляет уровень изучаемого языка.
func (db *DatabaseMock) UpdateUserTargetLanguageLevel(userID int, level string) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.TargetLanguageLevel = level
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ResetUserProfile сбрасывает профиль пользователя.
func (db *DatabaseMock) ResetUserProfile(userID int) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.NativeLanguageCode = ""
                        user.TargetLanguageCode = ""
                        user.TargetLanguageLevel = ""
                        user.State = "new"
                        user.Status = "new"
                        user.ProfileCompletionLevel = 0
                        user.Interests = []int{}
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// SaveUserInterest сохраняет один интерес пользователя.
func (db *DatabaseMock) SaveUserInterest(userID, interestID int, _ bool) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        // Находим пользователя по ID
        <span class="cov0" title="0">var targetUser *models.User

        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        targetUser = user

                        break</span>
                }
        }

        <span class="cov0" title="0">if targetUser == nil </span><span class="cov0" title="0">{
                return nil // Пользователь не найден
        }</span>

        // Проверяем, есть ли уже такой интерес
        <span class="cov0" title="0">for _, existingID := range targetUser.Interests </span><span class="cov0" title="0">{
                if existingID == interestID </span><span class="cov0" title="0">{
                        return nil // Интерес уже есть
                }</span>
        }

        // Добавляем новый интерес
        <span class="cov0" title="0">targetUser.Interests = append(targetUser.Interests, interestID)
        targetUser.UpdatedAt = time.Now()

        return nil</span>
}

// RemoveUserInterest удаляет интерес пользователя.
func (db *DatabaseMock) RemoveUserInterest(userID, interestID int) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        // Находим пользователя по ID
        <span class="cov0" title="0">var targetUser *models.User

        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        targetUser = user

                        break</span>
                }
        }

        <span class="cov0" title="0">if targetUser == nil </span><span class="cov0" title="0">{
                return nil // Пользователь не найден
        }</span>

        // Ищем и удаляем интерес
        <span class="cov0" title="0">for i, existingID := range targetUser.Interests </span><span class="cov0" title="0">{
                if existingID == interestID </span><span class="cov0" title="0">{
                        targetUser.Interests = append(targetUser.Interests[:i], targetUser.Interests[i+1:]...)
                        targetUser.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ClearUserInterests очищает все интересы пользователя.
func (db *DatabaseMock) ClearUserInterests(userID int) error <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return db.lastError
        }</span>

        // Находим пользователя по ID
        <span class="cov0" title="0">for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.Interests = []int{}
                        user.UpdatedAt = time.Now()

                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetConnection возвращает соединение с БД (для мока возвращаем заглушку).
func (db *DatabaseMock) GetConnection() *sql.DB <span class="cov0" title="0">{
        // Возвращаем nil - локализатор должен справляться с этим
        return nil
}</span>

// Close закрывает соединение с БД (для мока ничего не делает).
func (db *DatabaseMock) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// GetUserInterestSelections получает выборы интересов пользователя.
func (db *DatabaseMock) GetUserInterestSelections(userID int) ([]models.InterestSelection, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        // Возвращаем пустой список для тестов
        <span class="cov0" title="0">return []models.InterestSelection{}, nil</span>
}

// GetInterestByID получает интерес по ID.
func (db *DatabaseMock) GetInterestByID(interestID int) (*models.Interest, error) <span class="cov0" title="0">{
        if db.lastError != nil </span><span class="cov0" title="0">{
                return nil, db.lastError
        }</span>

        // Возвращаем тестовый интерес
        <span class="cov0" title="0">if interest, exists := db.interests[interestID]; exists </span><span class="cov0" title="0">{
                return interest, nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// Вспомогательные методы для тестов

// SetError устанавливает ошибку, которую будут возвращать методы.
func (db *DatabaseMock) SetError(err error) <span class="cov0" title="0">{
        db.lastError = err
}</span>

// ClearError очищает установленную ошибку.
func (db *DatabaseMock) ClearError() <span class="cov0" title="0">{
        db.lastError = nil
}</span>

// GetUser возвращает пользователя по Telegram ID (для тестов).
func (db *DatabaseMock) GetUser(telegramID int64) *models.User <span class="cov0" title="0">{
        return db.users[telegramID]
}</span>

// UpdateUserProfileCompletionLevel обновляет уровень завершения профиля
func (db *DatabaseMock) UpdateUserProfileCompletionLevel(userID int, level int) error <span class="cov0" title="0">{
        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.ProfileCompletionLevel = level
                        user.UpdatedAt = time.Now()
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("user not found")</span>
}

// SaveTimeAvailability сохраняет временную доступность пользователя
func (db *DatabaseMock) SaveTimeAvailability(userID int, availability *models.TimeAvailability) error <span class="cov0" title="0">{
        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.TimeAvailability = availability
                        user.UpdatedAt = time.Now()
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("user not found")</span>
}

// GetTimeAvailability получает временную доступность пользователя
func (db *DatabaseMock) GetTimeAvailability(userID int) (*models.TimeAvailability, error) <span class="cov0" title="0">{
        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        if user.TimeAvailability == nil </span><span class="cov0" title="0">{
                                return &amp;models.TimeAvailability{
                                        DayType:      "any",
                                        SpecificDays: []string{},
                                        TimeSlot:     "any",
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return user.TimeAvailability, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("user not found")</span>
}

// SaveFriendshipPreferences сохраняет предпочтения общения пользователя
func (db *DatabaseMock) SaveFriendshipPreferences(userID int, preferences *models.FriendshipPreferences) error <span class="cov0" title="0">{
        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        user.FriendshipPreferences = preferences
                        user.UpdatedAt = time.Now()
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("user not found")</span>
}

// GetFriendshipPreferences получает предпочтения общения пользователя
func (db *DatabaseMock) GetFriendshipPreferences(userID int) (*models.FriendshipPreferences, error) <span class="cov0" title="0">{
        for _, user := range db.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        if user.FriendshipPreferences == nil </span><span class="cov0" title="0">{
                                return &amp;models.FriendshipPreferences{
                                        ActivityType:       "casual_chat",
                                        CommunicationStyle: "text",
                                        CommunicationFreq:  "weekly",
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return user.FriendshipPreferences, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("user not found")</span>
}

// Reset очищает все данные в моке.
func (db *DatabaseMock) Reset() <span class="cov0" title="0">{
        db.users = make(map[int64]*models.User)
        db.lastError = nil
        db.seedLanguages()
        db.seedInterests()
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package mocks

import (
        "strings"
)

// LocalizerMock простой мок локализатора для тестов.
type LocalizerMock struct {
        translations map[string]map[string]string
}

// NewLocalizerMock создает новый мок локализатора.
func NewLocalizerMock() *LocalizerMock <span class="cov0" title="0">{
        return &amp;LocalizerMock{
                translations: map[string]map[string]string{
                        "en": {
                                "welcome_message":         "👋 Hi, {name}! Welcome to Language Exchange Bot!",
                                "choose_native_language":  "🌍 Choose your native language:",
                                "choose_target_language":  "📚 What language are you learning?",
                                "profile_summary_title":   "👤 Your profile",
                                "profile_field_native":    "Native language",
                                "profile_field_target":    "Learning language",
                                "profile_field_interests": "Interests",
                                "unknown_command":         "❓ Unknown command. Use /start to begin",
                        },
                        "ru": {
                                "welcome_message":         "👋 Привет, {name}! Добро пожаловать в Language Exchange Bot!",
                                "choose_native_language":  "🌍 Выбери свой родной язык:",
                                "choose_target_language":  "📚 Какой язык ты изучаешь?",
                                "profile_summary_title":   "👤 Твой профиль",
                                "profile_field_native":    "Родной язык",
                                "profile_field_target":    "Изучаемый язык",
                                "profile_field_interests": "Интересы",
                                "unknown_command":         "❓ Неизвестная команда. Используй /start для начала",
                        },
                },
        }
}</span>

// Get возвращает перевод для ключа и языка.
func (l *LocalizerMock) Get(langCode, key string) string <span class="cov0" title="0">{
        if lang, exists := l.translations[langCode]; exists </span><span class="cov0" title="0">{
                if value, exists := lang[key]; exists </span><span class="cov0" title="0">{
                        return value
                }</span>
        }

        // Fallback на английский
        <span class="cov0" title="0">if lang, exists := l.translations["en"]; exists </span><span class="cov0" title="0">{
                if value, exists := lang[key]; exists </span><span class="cov0" title="0">{
                        return value
                }</span>
        }

        // Если ничего не найдено, возвращаем ключ
        <span class="cov0" title="0">return key</span>
}

// GetWithParams возвращает перевод с заменой параметров.
func (l *LocalizerMock) GetWithParams(langCode, key string, params map[string]string) string <span class="cov0" title="0">{
        text := l.Get(langCode, key)

        // Заменяем параметры в тексте
        for paramKey, paramValue := range params </span><span class="cov0" title="0">{
                placeholder := "{" + paramKey + "}"
                text = strings.ReplaceAll(text, placeholder, paramValue)
        }</span>

        <span class="cov0" title="0">return text</span>
}

// GetLanguageName возвращает название языка.
func (l *LocalizerMock) GetLanguageName(langCode, interfaceLangCode string) string <span class="cov0" title="0">{
        names := map[string]map[string]string{
                "en": {"en": "English", "ru": "Russian", "es": "Spanish", "zh": "Chinese"},
                "ru": {"en": "Английский", "ru": "Русский", "es": "Испанский", "zh": "Китайский"},
                "es": {"en": "Inglés", "ru": "Ruso", "es": "Español", "zh": "Chino"},
                "zh": {"en": "英语", "ru": "俄语", "es": "西班牙语", "zh": "中文"},
        }

        if lang, exists := names[interfaceLangCode]; exists </span><span class="cov0" title="0">{
                if name, exists := lang[langCode]; exists </span><span class="cov0" title="0">{
                        return name
                }</span>
        }

        // Fallback
        <span class="cov0" title="0">return langCode</span>
}

// GetInterests возвращает список интересов (заглушка для тестов).
func (l *LocalizerMock) GetInterests(langCode string) (map[int]string, error) <span class="cov0" title="0">{
        interests := map[int]string{
                1: "Movies",
                2: "Music",
                3: "Sports",
                4: "Travel",
                5: "Technology",
                6: "Food",
        }

        if langCode == "ru" </span><span class="cov0" title="0">{
                interests = map[int]string{
                        1: "Фильмы",
                        2: "Музыка",
                        3: "Спорт",
                        4: "Путешествия",
                        5: "Технологии",
                        6: "Еда",
                }
        }</span>

        <span class="cov0" title="0">return interests, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package mocks

import (
        "fmt"
        "language-exchange-bot/internal/core"
        "language-exchange-bot/internal/models"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// TelegramHandlerWrapper обертка для тестирования обработчика Telegram.
type TelegramHandlerWrapper struct {
        Service        *core.BotService
        SentMessages   []tgbotapi.MessageConfig
        SentCallbacks  []tgbotapi.CallbackConfig
        EditedMessages []tgbotapi.EditMessageTextConfig
        LastError      error
}

// HandleUpdate обрабатывает update и записывает отправленные сообщения.
func (w *TelegramHandlerWrapper) HandleUpdate(update tgbotapi.Update) error <span class="cov0" title="0">{
        if update.Message != nil </span><span class="cov0" title="0">{
                return w.handleMessage(update.Message)
        }</span>

        <span class="cov0" title="0">if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                return w.handleCallbackQuery(update.CallbackQuery)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleMessage имитирует обработку сообщения.
func (w *TelegramHandlerWrapper) handleMessage(message *tgbotapi.Message) error <span class="cov0" title="0">{
        user, err := w.Service.HandleUserRegistration(
                message.From.ID,
                message.From.UserName,
                message.From.FirstName,
                message.From.LanguageCode,
        )
        if err != nil </span><span class="cov0" title="0">{
                w.LastError = err

                return err
        }</span>

        <span class="cov0" title="0">if message.IsCommand() </span><span class="cov0" title="0">{
                return w.handleCommand(message, user)
        }</span>

        <span class="cov0" title="0">return w.handleState(message, user)</span>
}

// handleCommand имитирует обработку команд.
func (w *TelegramHandlerWrapper) handleCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        switch message.Command() </span>{
        case "start":<span class="cov0" title="0">
                return w.handleStartCommand(message, user)</span>
        case "status":<span class="cov0" title="0">
                return w.handleStatusCommand(message, user)</span>
        case "profile":<span class="cov0" title="0">
                return w.handleProfileCommand(message, user)</span>
        case "feedback":<span class="cov0" title="0">
                return w.handleFeedbackCommand(message, user)</span>
        default:<span class="cov0" title="0">
                // Неизвестная команда
                msg := tgbotapi.NewMessage(message.Chat.ID, "Unknown command")
                w.SentMessages = append(w.SentMessages, msg)

                return nil</span>
        }
}

// handleStartCommand имитирует обработку команды /start.
func (w *TelegramHandlerWrapper) handleStartCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        welcomeText := w.Service.GetWelcomeMessage(user)

        msg := tgbotapi.NewMessage(message.Chat.ID, welcomeText)
        // Создаем простую клавиатуру для теста
        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("👤 My Profile", "profile_show"),
                        tgbotapi.NewInlineKeyboardButtonData("🔄 Edit Profile", "profile_edit"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🌐 Interface Language", "language_interface"),
                        tgbotapi.NewInlineKeyboardButtonData("💬 Feedback", "feedback_create"),
                ),
        )
        msg.ReplyMarkup = keyboard

        w.SentMessages = append(w.SentMessages, msg)

        return nil
}</span>

// handleStatusCommand имитирует обработку команды /status.
func (w *TelegramHandlerWrapper) handleStatusCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        // Создаем простое сообщение со статусом пользователя
        statusText := fmt.Sprintf("User ID: %d\nStatus: %s\nProfile completion: %d%%",
                user.TelegramID, user.Status, user.ProfileCompletionLevel)

        msg := tgbotapi.NewMessage(message.Chat.ID, statusText)
        w.SentMessages = append(w.SentMessages, msg)

        return nil
}</span>

// handleProfileCommand имитирует обработку команды /profile.
func (w *TelegramHandlerWrapper) handleProfileCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        profileText, err := w.Service.BuildProfileSummary(user)
        if err != nil </span><span class="cov0" title="0">{
                profileText = "Error loading profile"
        }</span>

        <span class="cov0" title="0">msg := tgbotapi.NewMessage(message.Chat.ID, profileText)
        w.SentMessages = append(w.SentMessages, msg)

        return nil</span>
}

// handleFeedbackCommand имитирует обработку команды /feedback.
func (w *TelegramHandlerWrapper) handleFeedbackCommand(message *tgbotapi.Message, user *models.User) error <span class="cov0" title="0">{
        // Проверяем, является ли пользователь администратором
        isAdmin := false

        for _, adminID := range []int64{123456789, 987654321} </span><span class="cov0" title="0">{
                if user.TelegramID == adminID </span><span class="cov0" title="0">{
                        isAdmin = true

                        break</span>
                }
        }

        <span class="cov0" title="0">var msg tgbotapi.MessageConfig
        if isAdmin </span><span class="cov0" title="0">{
                msg = tgbotapi.NewMessage(message.Chat.ID, "Admin feedback interface")
        }</span> else<span class="cov0" title="0"> {
                msg = tgbotapi.NewMessage(message.Chat.ID, "Please send your feedback:")
        }</span>

        <span class="cov0" title="0">w.SentMessages = append(w.SentMessages, msg)

        return nil</span>
}

// handleState имитирует обработку состояний пользователя.
func (w *TelegramHandlerWrapper) handleState(message *tgbotapi.Message, _ *models.User) error <span class="cov0" title="0">{
        // Простая имитация обработки состояний
        msg := tgbotapi.NewMessage(message.Chat.ID, "Processing your message...")
        w.SentMessages = append(w.SentMessages, msg)

        return nil
}</span>

// handleCallbackQuery имитирует обработку callback запросов.
func (w *TelegramHandlerWrapper) handleCallbackQuery(callback *tgbotapi.CallbackQuery) error <span class="cov0" title="0">{
        user, err := w.Service.HandleUserRegistration(
                callback.From.ID,
                callback.From.UserName,
                callback.From.FirstName,
                callback.From.LanguageCode,
        )
        if err != nil </span><span class="cov0" title="0">{
                w.LastError = err

                return err
        }</span>

        // Имитируем обработку разных callback'ов
        <span class="cov0" title="0">switch callback.Data </span>{
        case "profile_show":<span class="cov0" title="0">
                profileText, err := w.Service.BuildProfileSummary(user)
                if err != nil </span><span class="cov0" title="0">{
                        profileText = "Error loading profile"
                }</span>

                <span class="cov0" title="0">edit := tgbotapi.NewEditMessageText(callback.Message.Chat.ID, callback.Message.MessageID, profileText)
                w.EditedMessages = append(w.EditedMessages, edit)</span>

        case "profile_edit":<span class="cov0" title="0">
                editText := "Choose what to edit:"
                edit := tgbotapi.NewEditMessageText(callback.Message.Chat.ID, callback.Message.MessageID, editText)
                w.EditedMessages = append(w.EditedMessages, edit)</span>

        default:<span class="cov0" title="0">
                // Неизвестный callback
                callbackResponse := tgbotapi.NewCallback(callback.ID, "Unknown action")
                w.SentCallbacks = append(w.SentCallbacks, callbackResponse)</span>
        }

        // Отправляем ответ на callback
        <span class="cov0" title="0">callbackResponse := tgbotapi.NewCallback(callback.ID, "")
        w.SentCallbacks = append(w.SentCallbacks, callbackResponse)

        return nil</span>
}

// GetSentMessagesCount возвращает количество отправленных сообщений.
func (w *TelegramHandlerWrapper) GetSentMessagesCount() int <span class="cov0" title="0">{
        return len(w.SentMessages)
}</span>

// GetLastSentMessage возвращает последнее отправленное сообщение.
func (w *TelegramHandlerWrapper) GetLastSentMessage() *tgbotapi.MessageConfig <span class="cov0" title="0">{
        if len(w.SentMessages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;w.SentMessages[len(w.SentMessages)-1]</span>
}

// Reset очищает все записанные сообщения.
func (w *TelegramHandlerWrapper) Reset() <span class="cov0" title="0">{
        w.SentMessages = make([]tgbotapi.MessageConfig, 0)
        w.SentCallbacks = make([]tgbotapi.CallbackConfig, 0)
        w.EditedMessages = make([]tgbotapi.EditMessageTextConfig, 0)
        w.LastError = nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
