
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>validation: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">language-exchange-bot/internal/validation/message_validator.go (1.2%)</option>
				
				<option value="file1">language-exchange-bot/internal/validation/user_validator.go (62.5%)</option>
				
				<option value="file2">language-exchange-bot/internal/validation/validation_service.go (34.0%)</option>
				
				<option value="file3">language-exchange-bot/internal/validation/validators.go (76.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package validation

import (
        "strings"
)

// MessageValidator валидирует сообщения и callback'и
type MessageValidator struct {
        validator *Validator
}

// NewMessageValidator создает новый валидатор сообщений
func NewMessageValidator() *MessageValidator <span class="cov8" title="1">{
        return &amp;MessageValidator{
                validator: NewValidator(),
        }
}</span>

// ValidateMessage валидирует входящее сообщение
func (mv *MessageValidator) ValidateMessage(chatID int64, userID int64, text string) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация текста сообщения
        <span class="cov0" title="0">if text != "" </span><span class="cov0" title="0">{
                if errors := mv.validator.ValidateString(text, []string{"max:4096"}); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                result.AddError("text", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateCallbackQuery валидирует callback query
func (mv *MessageValidator) ValidateCallbackQuery(chatID int64, userID int64, data string) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация данных callback
        <span class="cov0" title="0">if errors := mv.validator.ValidateCallbackData(data); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("callback_data", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateFeedbackMessage валидирует сообщение отзыва
func (mv *MessageValidator) ValidateFeedbackMessage(chatID int64, userID int64, text string) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация текста отзыва
        <span class="cov0" title="0">if errors := mv.validator.ValidateFeedbackText(text); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("feedback_text", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateCommand валидирует команду
func (mv *MessageValidator) ValidateCommand(chatID int64, userID int64, command string) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация команды
        <span class="cov0" title="0">if strings.TrimSpace(command) == "" </span><span class="cov0" title="0">{
                result.AddError("command", "Команда обязательна")
                return result
        }</span>

        // Проверяем, что команда начинается с /
        <span class="cov0" title="0">if !strings.HasPrefix(command, "/") </span><span class="cov0" title="0">{
                result.AddError("command", "Команда должна начинаться с /")
        }</span>

        // Проверяем длину команды
        <span class="cov0" title="0">if len(command) &gt; 32 </span><span class="cov0" title="0">{
                result.AddError("command", "Команда слишком длинная")
        }</span>

        // Проверяем, что команда содержит только разрешенные символы
        <span class="cov0" title="0">if errors := mv.validator.ValidateString(command, []string{"alphanumeric"}); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                result.AddError("command", "Команда содержит недопустимые символы")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLanguageSelection валидирует выбор языка
func (mv *MessageValidator) ValidateLanguageSelection(chatID int64, userID int64, languageCode string) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация кода языка
        <span class="cov0" title="0">if errors := mv.validator.ValidateLanguageCode(languageCode); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("language_code", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateInterestSelection валидирует выбор интереса
func (mv *MessageValidator) ValidateInterestSelection(chatID int64, userID int64, interestID int) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация ID интереса
        <span class="cov0" title="0">if errors := mv.validator.ValidateInterestID(interestID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("interest_id", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateLanguageLevelSelection валидирует выбор уровня языка
func (mv *MessageValidator) ValidateLanguageLevelSelection(chatID int64, userID int64, level int) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация Chat ID
        if errors := mv.validator.ValidateChatID(chatID); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("chat_id", err)
                }</span>
        }

        // Валидация User ID
        <span class="cov0" title="0">if errors := mv.validator.ValidateTelegramID(int64(userID)); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("user_id", err)
                }</span>
        }

        // Валидация уровня языка
        <span class="cov0" title="0">if errors := mv.validator.ValidateLanguageLevel(level); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("language_level", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package validation

import (
        "language-exchange-bot/internal/models"
)

// UserValidator валидирует данные пользователя
type UserValidator struct {
        validator *Validator
}

// NewUserValidator создает новый валидатор пользователей
func NewUserValidator() *UserValidator <span class="cov8" title="1">{
        return &amp;UserValidator{
                validator: NewValidator(),
        }
}</span>

// ValidateUser валидирует данные пользователя
func (uv *UserValidator) ValidateUser(user *models.User) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        // Валидация Telegram ID
        if errors := uv.validator.ValidateTelegramID(int64(user.TelegramID)); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("telegram_id", err)
                }</span>
        }

        // Валидация имени пользователя
        <span class="cov8" title="1">if errors := uv.validator.ValidateString(user.FirstName, []string{"required", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("first_name", err)
                }</span>
        }

        // Валидация username (если есть)
        <span class="cov8" title="1">if user.Username != "" </span><span class="cov8" title="1">{
                if errors := uv.validator.ValidateString(user.Username, []string{"username", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        for _, err := range errors </span><span class="cov8" title="1">{
                                result.AddError("username", err)
                        }</span>
                }
        }

        // Валидация кода языка интерфейса
        <span class="cov8" title="1">if errors := uv.validator.ValidateLanguageCode(user.InterfaceLanguageCode); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("interface_language_code", err)
                }</span>
        }

        // Валидация состояния пользователя
        <span class="cov8" title="1">if errors := uv.validator.ValidateUserState(user.State); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("state", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateUserRegistration валидирует данные при регистрации пользователя
func (uv *UserValidator) ValidateUserRegistration(telegramID int, username, firstName, languageCode string) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        // Валидация Telegram ID
        if errors := uv.validator.ValidateTelegramID(int64(telegramID)); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("telegram_id", err)
                }</span>
        }

        // Валидация имени пользователя
        <span class="cov8" title="1">if errors := uv.validator.ValidateString(firstName, []string{"required", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("first_name", err)
                }</span>
        }

        // Валидация username (если есть)
        <span class="cov8" title="1">if username != "" </span><span class="cov8" title="1">{
                if errors := uv.validator.ValidateString(username, []string{"username", "max:50"}); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        for _, err := range errors </span><span class="cov8" title="1">{
                                result.AddError("username", err)
                        }</span>
                }
        }

        // Валидация кода языка
        <span class="cov8" title="1">if errors := uv.validator.ValidateLanguageCode(languageCode); len(errors) &gt; 0 </span><span class="cov8" title="1">{
                for _, err := range errors </span><span class="cov8" title="1">{
                        result.AddError("language_code", err)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateUserUpdate валидирует данные при обновлении пользователя
func (uv *UserValidator) ValidateUserUpdate(user *models.User) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        // Валидация имени пользователя
        if errors := uv.validator.ValidateString(user.FirstName, []string{"required", "max:50"}); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("first_name", err)
                }</span>
        }

        // Валидация username (если есть)
        <span class="cov0" title="0">if user.Username != "" </span><span class="cov0" title="0">{
                if errors := uv.validator.ValidateString(user.Username, []string{"username", "max:50"}); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                result.AddError("username", err)
                        }</span>
                }
        }

        // Валидация кода языка интерфейса
        <span class="cov0" title="0">if errors := uv.validator.ValidateLanguageCode(user.InterfaceLanguageCode); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("interface_language_code", err)
                }</span>
        }

        // Валидация состояния пользователя
        <span class="cov0" title="0">if errors := uv.validator.ValidateUserState(user.State); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("state", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateUserInterests валидирует интересы пользователя
func (uv *UserValidator) ValidateUserInterests(interestIDs []int) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        if len(interestIDs) == 0 </span><span class="cov8" title="1">{
                result.AddError("interests", "Необходимо выбрать хотя бы один интерес")
                return result
        }</span>

        <span class="cov8" title="1">if len(interestIDs) &gt; 10 </span><span class="cov0" title="0">{
                result.AddError("interests", "Максимум 10 интересов")
                return result
        }</span>

        // Валидация каждого ID интереса
        <span class="cov8" title="1">for i, id := range interestIDs </span><span class="cov8" title="1">{
                if errors := uv.validator.ValidateInterestID(id); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                result.AddError("interests", err)
                        }</span>
                }

                // Проверка на дубликаты
                <span class="cov8" title="1">for j, otherID := range interestIDs </span><span class="cov8" title="1">{
                        if i != j &amp;&amp; id == otherID </span><span class="cov0" title="0">{
                                result.AddError("interests", "Дублирующиеся интересы не допускаются")
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateUserLanguages валидирует языки пользователя
func (uv *UserValidator) ValidateUserLanguages(nativeLanguage, targetLanguage string) *ValidationResult <span class="cov8" title="1">{
        result := NewValidationResult()

        // Валидация родного языка
        if errors := uv.validator.ValidateLanguageCode(nativeLanguage); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("native_language", err)
                }</span>
        }

        // Валидация целевого языка
        <span class="cov8" title="1">if errors := uv.validator.ValidateLanguageCode(targetLanguage); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("target_language", err)
                }</span>
        }

        // Проверка, что языки разные
        <span class="cov8" title="1">if nativeLanguage == targetLanguage </span><span class="cov8" title="1">{
                result.AddError("languages", "Родной и целевой языки должны отличаться")
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ValidateUserLanguageLevel валидирует уровень языка пользователя
func (uv *UserValidator) ValidateUserLanguageLevel(level int) *ValidationResult <span class="cov0" title="0">{
        result := NewValidationResult()

        if errors := uv.validator.ValidateLanguageLevel(level); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        result.AddError("language_level", err)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package validation

import (
        "language-exchange-bot/internal/errors"
        "language-exchange-bot/internal/models"
)

// ValidationService предоставляет сервис валидации с интеграцией ошибок
type ValidationService struct {
        userValidator    *UserValidator
        messageValidator *MessageValidator
        errorHandler     *errors.ErrorHandler
}

// NewValidationService создает новый сервис валидации
func NewValidationService(errorHandler *errors.ErrorHandler) *ValidationService <span class="cov8" title="1">{
        return &amp;ValidationService{
                userValidator:    NewUserValidator(),
                messageValidator: NewMessageValidator(),
                errorHandler:     errorHandler,
        }
}</span>

// ValidateUserWithErrorHandling валидирует пользователя с обработкой ошибок
func (vs *ValidationService) ValidateUserWithErrorHandling(user *models.User, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUser(user)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации пользователя",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserRegistrationWithErrorHandling валидирует регистрацию пользователя
func (vs *ValidationService) ValidateUserRegistrationWithErrorHandling(telegramID int, username, firstName, languageCode string, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserRegistration(telegramID, username, firstName, languageCode)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации при регистрации",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserUpdateWithErrorHandling валидирует обновление пользователя
func (vs *ValidationService) ValidateUserUpdateWithErrorHandling(user *models.User, userID, chatID int64, operation string) error <span class="cov0" title="0">{
        result := vs.userValidator.ValidateUserUpdate(user)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации при обновлении",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateUserInterestsWithErrorHandling валидирует интересы пользователя
func (vs *ValidationService) ValidateUserInterestsWithErrorHandling(interestIDs []int, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserInterests(interestIDs)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации интересов",
                        "Проверьте выбранные интересы",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserLanguagesWithErrorHandling валидирует языки пользователя
func (vs *ValidationService) ValidateUserLanguagesWithErrorHandling(nativeLanguage, targetLanguage string, userID, chatID int64, operation string) error <span class="cov8" title="1">{
        result := vs.userValidator.ValidateUserLanguages(nativeLanguage, targetLanguage)

        if result.HasErrors() </span><span class="cov8" title="1">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации языков",
                        "Проверьте выбранные языки",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov8" title="1">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov8" title="1">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateMessageWithErrorHandling валидирует сообщение с обработкой ошибок
func (vs *ValidationService) ValidateMessageWithErrorHandling(chatID, userID int64, text, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateMessage(chatID, userID, text)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации сообщения",
                        "Проверьте введенные данные",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateCallbackQueryWithErrorHandling валидирует callback query с обработкой ошибок
func (vs *ValidationService) ValidateCallbackQueryWithErrorHandling(chatID, userID int64, data, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateCallbackQuery(chatID, userID, data)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации callback query",
                        "Проверьте данные запроса",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateFeedbackMessageWithErrorHandling валидирует сообщение отзыва с обработкой ошибок
func (vs *ValidationService) ValidateFeedbackMessageWithErrorHandling(chatID, userID int64, text, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateFeedbackMessage(chatID, userID, text)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации отзыва",
                        "Проверьте текст отзыва",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateCommandWithErrorHandling валидирует команду с обработкой ошибок
func (vs *ValidationService) ValidateCommandWithErrorHandling(chatID, userID int64, command, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateCommand(chatID, userID, command)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации команды",
                        "Проверьте команду",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateLanguageSelectionWithErrorHandling валидирует выбор языка с обработкой ошибок
func (vs *ValidationService) ValidateLanguageSelectionWithErrorHandling(chatID, userID int64, languageCode, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateLanguageSelection(chatID, userID, languageCode)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации выбора языка",
                        "Проверьте выбранный язык",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateInterestSelectionWithErrorHandling валидирует выбор интереса с обработкой ошибок
func (vs *ValidationService) ValidateInterestSelectionWithErrorHandling(chatID, userID int64, interestID int, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateInterestSelection(chatID, userID, interestID)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации выбора интереса",
                        "Проверьте выбранный интерес",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateLanguageLevelSelectionWithErrorHandling валидирует выбор уровня языка с обработкой ошибок
func (vs *ValidationService) ValidateLanguageLevelSelectionWithErrorHandling(chatID, userID int64, level int, operation string) error <span class="cov0" title="0">{
        result := vs.messageValidator.ValidateLanguageLevelSelection(chatID, userID, level)

        if result.HasErrors() </span><span class="cov0" title="0">{
                // Создаем ошибку валидации с контекстом
                ctx := errors.NewRequestContext(userID, chatID, operation)
                validationErr := errors.NewValidationError(
                        "Ошибка валидации выбора уровня языка",
                        "Проверьте выбранный уровень",
                        ctx,
                )

                // Добавляем детали ошибок валидации в контекст
                for field, fieldErrors := range result.GetErrors() </span><span class="cov0" title="0">{
                        validationErr.Context[field] = fieldErrors
                }</span>

                <span class="cov0" title="0">return vs.errorHandler.Handle(validationErr, ctx)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package validation

import (
        "fmt"
        "regexp"
        "strings"
        "unicode/utf8"
)

// ValidationRule представляет правило валидации
type ValidationRule struct {
        Field    string
        Value    interface{}
        Rules    []string
        Messages map[string]string
}

// ValidationResult содержит результат валидации
type ValidationResult struct {
        IsValid bool
        Errors  map[string][]string
}

// NewValidationResult создает новый результат валидации
func NewValidationResult() *ValidationResult <span class="cov8" title="1">{
        return &amp;ValidationResult{
                IsValid: true,
                Errors:  make(map[string][]string),
        }
}</span>

// AddError добавляет ошибку валидации
func (vr *ValidationResult) AddError(field, message string) <span class="cov8" title="1">{
        vr.IsValid = false
        vr.Errors[field] = append(vr.Errors[field], message)
}</span>

// GetErrors возвращает все ошибки валидации
func (vr *ValidationResult) GetErrors() map[string][]string <span class="cov8" title="1">{
        return vr.Errors
}</span>

// HasErrors проверяет, есть ли ошибки
func (vr *ValidationResult) HasErrors() bool <span class="cov8" title="1">{
        return !vr.IsValid
}</span>

// Validator содержит методы валидации
type Validator struct{}

// NewValidator создает новый валидатор
func NewValidator() *Validator <span class="cov8" title="1">{
        return &amp;Validator{}
}</span>

// ValidateString валидирует строковое значение
func (v *Validator) ValidateString(value string, rules []string) []string <span class="cov8" title="1">{
        var errors []string

        for _, rule := range rules </span><span class="cov8" title="1">{
                switch rule </span>{
                case "required":<span class="cov8" title="1">
                        if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                                errors = append(errors, "Поле обязательно для заполнения")
                        }</span>
                case "min:3":<span class="cov0" title="0">
                        if utf8.RuneCountInString(value) &lt; 3 </span><span class="cov0" title="0">{
                                errors = append(errors, "Минимум 3 символа")
                        }</span>
                case "max:50":<span class="cov8" title="1">
                        if utf8.RuneCountInString(value) &gt; 50 </span><span class="cov0" title="0">{
                                errors = append(errors, "Максимум 50 символов")
                        }</span>
                case "max:100":<span class="cov0" title="0">
                        if utf8.RuneCountInString(value) &gt; 100 </span><span class="cov0" title="0">{
                                errors = append(errors, "Максимум 100 символов")
                        }</span>
                case "max:500":<span class="cov0" title="0">
                        if utf8.RuneCountInString(value) &gt; 500 </span><span class="cov0" title="0">{
                                errors = append(errors, "Максимум 500 символов")
                        }</span>
                case "alphanumeric":<span class="cov0" title="0">
                        if !regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(value) </span><span class="cov0" title="0">{
                                errors = append(errors, "Только буквы и цифры")
                        }</span>
                case "username":<span class="cov8" title="1">
                        if !regexp.MustCompile(`^[a-zA-Z0-9_]+$`).MatchString(value) </span><span class="cov8" title="1">{
                                errors = append(errors, "Некорректный username")
                        }</span>
                case "email":<span class="cov0" title="0">
                        if !regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`).MatchString(value) </span><span class="cov0" title="0">{
                                errors = append(errors, "Некорректный email")
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// ValidateInt валидирует целочисленное значение
func (v *Validator) ValidateInt(value int, rules []string) []string <span class="cov8" title="1">{
        var errors []string

        for _, rule := range rules </span><span class="cov8" title="1">{
                switch rule </span>{
                case "required":<span class="cov8" title="1">
                        if value == 0 </span><span class="cov8" title="1">{
                                errors = append(errors, "Значение обязательно")
                        }</span>
                case "min:1":<span class="cov8" title="1">
                        if value &lt; 1 </span><span class="cov0" title="0">{
                                errors = append(errors, "Минимум 1")
                        }</span>
                case "max:100":<span class="cov8" title="1">
                        if value &gt; 100 </span><span class="cov0" title="0">{
                                errors = append(errors, "Максимум 100")
                        }</span>
                case "positive":<span class="cov0" title="0">
                        if value &lt;= 0 </span><span class="cov0" title="0">{
                                errors = append(errors, "Должно быть положительным")
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// ValidateLanguageCode валидирует код языка
func (v *Validator) ValidateLanguageCode(code string) []string <span class="cov8" title="1">{
        var errors []string

        if strings.TrimSpace(code) == "" </span><span class="cov0" title="0">{
                errors = append(errors, "Код языка обязателен")
                return errors
        }</span>

        // Проверяем формат кода языка (2 символа)
        <span class="cov8" title="1">if len(code) != 2 </span><span class="cov8" title="1">{
                errors = append(errors, "Код языка должен содержать 2 символа")
        }</span>

        // Проверяем, что код содержит только буквы
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z]{2}$`).MatchString(code) </span><span class="cov8" title="1">{
                errors = append(errors, "Код языка должен содержать только буквы")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateTelegramID валидирует Telegram ID
func (v *Validator) ValidateTelegramID(id int64) []string <span class="cov8" title="1">{
        var errors []string

        if id &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "Telegram ID должен быть положительным")
        }</span>

        // Telegram ID обычно больше 100000000
        <span class="cov8" title="1">if id &lt; 100000000 </span><span class="cov8" title="1">{
                errors = append(errors, "Некорректный Telegram ID")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateChatID валидирует Chat ID
func (v *Validator) ValidateChatID(id int64) []string <span class="cov8" title="1">{
        var errors []string

        if id == 0 </span><span class="cov8" title="1">{
                errors = append(errors, "Chat ID обязателен")
                return errors
        }</span>

        // Chat ID может быть отрицательным для групп
        <span class="cov8" title="1">if id &gt; 0 &amp;&amp; id &lt; 100000000 </span><span class="cov0" title="0">{
                errors = append(errors, "Некорректный Chat ID")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateUserState валидирует состояние пользователя
func (v *Validator) ValidateUserState(state string) []string <span class="cov8" title="1">{
        var errors []string

        validStates := []string{
                "idle", "setting_language", "setting_native_language",
                "setting_target_language", "setting_interests", "setting_profile",
                "waiting_for_feedback", "viewing_profile", "editing_profile",
        }

        isValid := false
        for _, validState := range validStates </span><span class="cov8" title="1">{
                if state == validState </span><span class="cov8" title="1">{
                        isValid = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                errors = append(errors, fmt.Sprintf("Некорректное состояние пользователя: %s", state))
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateInterestID валидирует ID интереса
func (v *Validator) ValidateInterestID(id int) []string <span class="cov8" title="1">{
        var errors []string

        if id &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "ID интереса должен быть положительным")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateLanguageLevel валидирует уровень языка
func (v *Validator) ValidateLanguageLevel(level int) []string <span class="cov8" title="1">{
        var errors []string

        if level &lt; 1 || level &gt; 5 </span><span class="cov8" title="1">{
                errors = append(errors, "Уровень языка должен быть от 1 до 5")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateFeedbackText валидирует текст отзыва
func (v *Validator) ValidateFeedbackText(text string) []string <span class="cov8" title="1">{
        var errors []string

        if strings.TrimSpace(text) == "" </span><span class="cov0" title="0">{
                errors = append(errors, "Текст отзыва обязателен")
                return errors
        }</span>

        <span class="cov8" title="1">textLength := utf8.RuneCountInString(strings.TrimSpace(text))
        if textLength &lt; 10 </span><span class="cov8" title="1">{
                errors = append(errors, "Минимум 10 символов")
        }</span>

        <span class="cov8" title="1">if textLength &gt; 1000 </span><span class="cov0" title="0">{
                errors = append(errors, "Максимум 1000 символов")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ValidateCallbackData валидирует данные callback query
func (v *Validator) ValidateCallbackData(data string) []string <span class="cov8" title="1">{
        var errors []string

        if strings.TrimSpace(data) == "" </span><span class="cov8" title="1">{
                errors = append(errors, "Данные callback обязательны")
                return errors
        }</span>

        <span class="cov8" title="1">if len(data) &gt; 64 </span><span class="cov0" title="0">{
                errors = append(errors, "Максимум 64 символа")
        }</span>

        // Проверяем, что данные содержат только разрешенные символы
        <span class="cov8" title="1">if !regexp.MustCompile(`^[a-zA-Z0-9_:.-]+$`).MatchString(data) </span><span class="cov0" title="0">{
                errors = append(errors, "Некорректные символы в данных")
        }</span>

        <span class="cov8" title="1">return errors</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
